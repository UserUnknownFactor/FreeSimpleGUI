# -*- coding: utf-8 -*-

# Copyright 2024- FreeSimpleGUI
# This software is available for your use under a LGPL3+ license

version = "5.0.60"
__version__ = version.split()[0]  # For PEP 396 and PEP 345

# The shortened version
try:
    ver = version.split(' ')[0]
except:
    ver = ''

port = 'FreeSimpleGUI'

import os
import sys

# all of the tkinter involved imports
import tkinter as tk
from tkinter import ttk
# import tkinter.scrolledtext as tkst
import tkinter.font
# end of tkinter specific imports

# get the tkinter detailed version
tclversion_detailed = tkinter.Tcl().eval('info patchlevel')
framework_version = tclversion_detailed

import time
import pickle
import calendar
import datetime
import textwrap

import inspect
import traceback
import difflib
import copy
import pprint
import platform
import pydoc # for the built-in PSG SDK Help Window

try:  # Because Raspberry Pi is still on 3.4... it's not critical if this module isn't imported on the Pi
    from typing import List, Any, Union, Tuple, Dict, SupportsAbs, Optional
except:
    print('*** Skipping import of Typing module. "pip3 install typing" to remove this warning ***')

import random
import warnings
from math import floor
from math import fabs
from functools import wraps

try:  # Because Raspberry Pi is still on 3.4....
    # from subprocess import run, PIPE, Popen
    import subprocess
except Exception as e:
    print('** Import error {} **'.format(e))

import threading
import itertools
import json
import configparser
import queue

try:
    import webbrowser
    webbrowser_available = True
except:
    webbrowser_available = False

# import re
import ctypes

pil_import_attempted = pil_imported = False

warnings.simplefilter('always', UserWarning)

g_time_start = 0
g_time_end = 0
g_time_delta = 0

# These timer routines are to help you quickly time portions of code.
# Place the timer_start call at the point you want to start timing and the
# timer_stop at the end point. The delta between the start and stop calls
# is returned from calling timer_stop.

def timer_start():
    """Starts the timer

    Uses the time.time value, a technique known to not be terribly accurate,
    but is close enough for our purpose.s
    """
    global g_time_start

    g_time_start = time.time()


def timer_stop():
    """Stops the timer and print the number of ms since its start

    :return: delta in MILLISECONDS from timer_start was called
    :rtype:  int
    """
    global g_time_delta, g_time_end

    g_time_end = time.time()
    g_time_delta = g_time_end - g_time_start
    return int(g_time_delta * 1000)


def timer_stop_usec():
    """Stops the timer and print the number of ms since its start

    :return: delta in MICROSECONDS from timer_start was called
    :rtype:  int
    """
    global g_time_delta, g_time_end

    g_time_end = time.time()
    g_time_delta = g_time_end - g_time_start
    return int(g_time_delta * 1000000)


def _timeit(func):
    """Enables `@_timeit` decorator to functions to print time spent in them

    :param func: Decorated function
    :type func:
    :return:     Execution time for the decorated function
    :rtype:
    """
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print('{} executed in {:.4f} seconds'.format(func.__name__, end - start))
        return result
    return wrapper

_timeit_counter = 0
MAX_TIMEIT_COUNT = 1000
_timeit_total = 0

def _timeit_summary(func):
    """ Decorator same as `timeit()` except that the value is shown as an average

    Put `@_timeit_summary` as a decorator to a function to get the time spent in that function printed out.

    :param func: Decorated function
    :type func:
    :return:     Execution time for the decorated function
    :rtype:
    """
    @wraps(func)
    def wrapper(*args, **kwargs):
        global _timeit_counter, _timeit_total
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        _timeit_counter += 1
        _timeit_total += end - start
        if _timeit_counter > MAX_TIMEIT_COUNT:
            print('{} executed in {:.4f} seconds'.format(func.__name__, _timeit_total / MAX_TIMEIT_COUNT))
            _timeit_counter = 0
            _timeit_total = 0
        return result
    return wrapper


def formatted_datetime_now():
    """Returns a string with current date and time formatted
        YYYY-MM-DD HH:MM:SS for easier logging

    :return:    String with date and time formatted YYYY-MM-DD  HH:MM:SS
    :rtype:     (str)
    """
    now = datetime.datetime.now()
    current_time = now.strftime("%Y-%m-%d %H:%M:%S")
    return current_time


def running_linux():
    """Determines the OS is Linux by using `sys.platform`

    Returns True if Linux.

    :return: True if sys.platform indicates running Linux
    :rtype:  (bool)
    """
    return sys.platform.startswith('linux')


def running_mac():
    """Determines the OS is Mac by using `sys.platform`

    Returns True if Mac.

    :return: True if sys.platform indicates running Mac
    :rtype:  (bool)
    """
    return sys.platform.startswith('darwin')


def running_windows():
    """Determines the OS is Windows by using `sys.platform`

    Returns True if Windows.

    :return: True if sys.platform indicates running Windows
    :rtype:  (bool)
    """
    return sys.platform.startswith('win')


def running_trinket():
    """A special case for Trinket

    Checks both the OS and the number of environment variables.
    Currently, Trinket only has ONE environment variable.
    This fact is used to figure out if Trinket is being used.

    Returns True if "Trinket" (in theory)

    :return: True if sys.platform indicates Linux and the number of environment variables is 1
    :rtype:  (bool)
    """
    import socket
    if sys.platform.startswith('linux') and socket.gethostname().startswith('pygame-'):
        return True
    return False


def running_replit():
    """A special case for REPLIT

    Checks both the OS and for the existance of the number of environment variable REPL_OWNER.
    Currently, Trinket only has ONE environment variable.  This fact is used to figure out if Trinket is being used.

    Returns True if running on "replit"

    :return: True if sys.platform indicates Linux and setting REPL_OWNER is found in the environment variables
    :rtype:  (bool)
    """
    if 'REPL_OWNER' in os.environ and sys.platform.startswith('linux'):
        return True
    return False


# Handy python statements to increment and decrement with wrapping that I don't want to forget
# count = (count + (MAX - 1)) % MAX           # Decrement - roll over to MAX from 0
# count = (count + 1) % MAX                   # Increment to MAX then roll over to 0

# ----====----====----==== Constants the user CAN safely change ====----====----====----#

# Base64 encoded GIF file
DEFAULT_BASE64_ICON = b'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'
DEFAULT_BASE64_ICON_16_BY_16 = b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAOCAYAAAAmL5yKAAACmUlEQVR4nFWQS2icVRiGn++c8/+ZS2ZiJ4guQkGQULFgNS66cFMQ6wVR8EJFXBUKxVWpROOFEgXxAtqFSMGKXQiKurC2CeLKldZLxIobpQkEWy3SmcY680/m/8/5PhfTVvrsn5f3fQXADBHBAGx1x0E8e4icQvvPyOzaKH9j6bEy5fMgs6DH2fT7WNy1iZnIFdlsLuNM+oC6e5K+QstDHJ58fHnh2U+7Mz+4mmto0Tca1wllsUSzeoTed5WY4ViZ87SrT2hnD9ONMOWhn6AVIBZf33l88cOVf298W2TYtKiRdidnsHGEF3bvFwD7fcdepvxRejECl3DyKkmf0sxtd83gsfOfXX/syOle1nrZRoWaOABD3R2O8QlzlKZ4CRh/M/vzWyA/urrz2o0lccujr+z8fFUHqXBOPJoEHwLBbgoACBkOR6UR77bx220XgC38E6ObruXEv5ZfW3nwBmm4hpYpktUCqbpAPvH9OOAKAqhBkA5RE1MTAe2eeuDkix+vV9OHHQNV8R4Rw/snmN91fjzBcS2VJtq5h4vfPrR04L3l3q2HnRt01PD4LFKO9kE8879qyFXZTKkHR7r0ze4Tz7/zRff2N70vOppIZHmBpj2EsBPLfuXQlze7q9Uvk0wgU1nfmPnoq3O3LOQTo06qYiTLhWrzIMY91Jp7CVkTr/uv/QAQAUwZmquJKye10gR4yqGBWyDPttK/WFJv5SD9cQO1iGGAOUzxuW2bOb1u5fQijZZHSIDgw1ZGw5LaZE65eQ6Ro+OAJMqECEiGSCCYpI2ZaV7ffswVvXeptwPihVRBfTJHdZXM3c9L9/5x+QM9oYWuJeFscpzVQVpTcz9hSHzuvqephvM4/ych66LpfYaDu5i/+xcOmfsPXNAyV3hjwl8AAAAASUVORK5CYII='
DEFAULT_BASE64_LOADING_GIF = b'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'
PSG_DEBUGGER_LOGO = b'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'

BLANK_BASE64 = b'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='

DEFAULT_WINDOW_ICON = DEFAULT_BASE64_ICON
DEFAULT_ELEMENT_SIZE = (45, 1)  # In CHARACTERS
DEFAULT_BUTTON_ELEMENT_SIZE = (10, 1)  # In CHARACTERS
DEFAULT_MARGINS = (10, 5)  # Margins for each LEFT/RIGHT margin is first term
DEFAULT_ELEMENT_PADDING = (5, 3)  # Padding between elements (row, col) in pixels
DEFAULT_AUTOSIZE_TEXT = True
DEFAULT_AUTOSIZE_BUTTONS = True
DEFAULT_FONT = ("Tahoma", 10)
DEFAULT_TEXT_JUSTIFICATION = 'left'
DEFAULT_BORDER_WIDTH = 1
DEFAULT_AUTOCLOSE_TIME = 3  # time in seconds to show an autoclose form
DEFAULT_DEBUG_WINDOW_SIZE = (80, 20)
DEFAULT_WINDOW_LOCATION = (None, None)
MAX_SCROLLED_TEXT_BOX_HEIGHT = 50
DEFAULT_TOOLTIP_TIME = 400
DEFAULT_TOOLTIP_OFFSET = (0, -20)
DEFAULT_KEEP_ON_TOP = None
DEFAULT_SCALING = None
DEFAULT_ALPHA_CHANNEL = 1.0
DEFAULT_HIDE_WINDOW_WHEN_CREATING = True
TOOLTIP_BACKGROUND_COLOR = "#ffffe0"
TOOLTIP_FONT = None
DEFAULT_USE_BUTTON_SHORTCUTS = False
#################### COLOR STUFF ####################
BLUES = ("#082567", "#0A37A3", "#00345B")
PURPLES = ("#480656", "#4F2398", "#380474")
GREENS = ("#01826B", "#40A860", "#96D2AB", "#00A949", "#003532")
YELLOWS = ("#F3FB62", "#F0F595")
TANS = ("#FFF9D5", "#F4EFCF", "#DDD8BA")
NICE_BUTTON_COLORS = ((GREENS[3], TANS[0]),
                      ('#000000', '#FFFFFF'),
                      ('#FFFFFF', '#000000'),
                      (YELLOWS[0], PURPLES[1]),
                      (YELLOWS[0], GREENS[3]),
                      (YELLOWS[0], BLUES[2]))

COLOR_SYSTEM_DEFAULT = '1234567890'  # A Magic Number kind of signal to FreeSimpleGUI that the color should not be set at all
DEFAULT_BUTTON_COLOR = ('white', BLUES[0])  # Foreground, Background (None, None) == System Default
OFFICIAL_FREESIMPLEGUI_BUTTON_COLOR = ('white', BLUES[0])

# The "default FreeSimpleGUI theme"
OFFICIAL_FREESIMPLEGUI_THEME = CURRENT_LOOK_AND_FEEL = 'Dark Blue 3'

DEFAULT_ERROR_BUTTON_COLOR = ("#FFFFFF", "#FF0000")
DEFAULT_BACKGROUND_COLOR = None
DEFAULT_ELEMENT_BACKGROUND_COLOR = None
DEFAULT_ELEMENT_TEXT_COLOR = COLOR_SYSTEM_DEFAULT
DEFAULT_TEXT_ELEMENT_BACKGROUND_COLOR = None
DEFAULT_TEXT_COLOR = COLOR_SYSTEM_DEFAULT
DEFAULT_INPUT_ELEMENTS_COLOR = COLOR_SYSTEM_DEFAULT
DEFAULT_INPUT_TEXT_COLOR = COLOR_SYSTEM_DEFAULT
DEFAULT_SCROLLBAR_COLOR = None

# A transparent button is simply one that matches the background
# TRANSPARENT_BUTTON = 'This constant has been depricated. You must set your button background = background it is on for it to be transparent appearing'


# --------------------------------------------------------------------------------
# Progress Bar Relief Choices
RELIEF_RAISED = 'raised'
RELIEF_SUNKEN = 'sunken'
RELIEF_FLAT = 'flat'
RELIEF_RIDGE = 'ridge'
RELIEF_GROOVE = 'groove'
RELIEF_SOLID = 'solid'
RELIEF_LIST = (RELIEF_RAISED, RELIEF_FLAT, RELIEF_SUNKEN, RELIEF_RIDGE, RELIEF_SOLID, RELIEF_GROOVE)

# These are the spepific themes that tkinter offers
THEME_DEFAULT = 'default'  # this is a TTK theme, not a PSG theme!!!
THEME_WINNATIVE = 'winnative'
THEME_CLAM = 'clam'
THEME_ALT = 'alt'
THEME_CLASSIC = 'classic'
THEME_VISTA = 'vista'
THEME_XPNATIVE = 'xpnative'

# The theme to use by default for all windows
DEFAULT_TTK_THEME = THEME_DEFAULT
ttk_theme_in_use = None

USE_TTK_BUTTONS = None

DEFAULT_PROGRESS_BAR_COLOR = ("#01826B", '#D0D0D0')  # a nice green progress bar
DEFAULT_PROGRESS_BAR_COMPUTE = ('#000000', '#000000')  # Means that the progress bar colors should be computed from other colors
DEFAULT_PROGRESS_BAR_COLOR_OFFICIAL = ("#01826B", '#D0D0D0')  # a nice green progress bar
DEFAULT_PROGRESS_BAR_SIZE = (20, 20)  # Size of Progress Bar (characters for length, pixels for width)
DEFAULT_PROGRESS_BAR_BORDER_WIDTH = 1
DEFAULT_PROGRESS_BAR_RELIEF = RELIEF_GROOVE
# PROGRESS_BAR_STYLES = ('default', 'winnative', 'clam', 'alt', 'classic', 'vista', 'xpnative')
DEFAULT_PROGRESS_BAR_STYLE = DEFAULT_TTK_THEME
DEFAULT_METER_ORIENTATION = 'Horizontal'
DEFAULT_SLIDER_ORIENTATION = 'vertical'
DEFAULT_SLIDER_BORDER_WIDTH = 1
DEFAULT_SLIDER_RELIEF = tk.FLAT
DEFAULT_FRAME_RELIEF = tk.GROOVE

DEFAULT_LISTBOX_SELECT_MODE = tk.SINGLE
SELECT_MODE_MULTIPLE = tk.MULTIPLE
LISTBOX_SELECT_MODE_MULTIPLE = 'multiple'
SELECT_MODE_BROWSE = tk.BROWSE
LISTBOX_SELECT_MODE_BROWSE = 'browse'
SELECT_MODE_EXTENDED = tk.EXTENDED
LISTBOX_SELECT_MODE_EXTENDED = 'extended'
SELECT_MODE_SINGLE = tk.SINGLE
LISTBOX_SELECT_MODE_SINGLE = 'single'

TABLE_SELECT_MODE_NONE = tk.NONE
TABLE_SELECT_MODE_BROWSE = tk.BROWSE
TABLE_SELECT_MODE_EXTENDED = tk.EXTENDED
DEFAULT_TABLE_SELECT_MODE = TABLE_SELECT_MODE_EXTENDED
TABLE_CLICKED_INDICATOR = '+CLICKED+'  # Part of the tuple returned as an event when a Table element has click events enabled
DEFAULT_MODAL_WINDOWS_ENABLED = True
DEFAULT_MODAL_WINDOWS_FORCED = False

TAB_LOCATION_TOP = 'top'
TAB_LOCATION_TOP_LEFT = 'topleft'
TAB_LOCATION_TOP_RIGHT = 'topright'
TAB_LOCATION_LEFT = 'left'
TAB_LOCATION_LEFT_TOP = 'lefttop'
TAB_LOCATION_LEFT_BOTTOM = 'leftbottom'
TAB_LOCATION_RIGHT = 'right'
TAB_LOCATION_RIGHT_TOP = 'righttop'
TAB_LOCATION_RIGHT_BOTTOM = 'rightbottom'
TAB_LOCATION_BOTTOM = 'bottom'
TAB_LOCATION_BOTTOM_LEFT = 'bottomleft'
TAB_LOCATION_BOTTOM_RIGHT = 'bottomright'

TITLE_LOCATION_TOP = tk.N
TITLE_LOCATION_BOTTOM = tk.S
TITLE_LOCATION_LEFT = tk.W
TITLE_LOCATION_RIGHT = tk.E
TITLE_LOCATION_TOP_LEFT = tk.NW
TITLE_LOCATION_TOP_RIGHT = tk.NE
TITLE_LOCATION_BOTTOM_LEFT = tk.SW
TITLE_LOCATION_BOTTOM_RIGHT = tk.SE

TEXT_LOCATION_TOP = tk.N
TEXT_LOCATION_BOTTOM = tk.S
TEXT_LOCATION_LEFT = tk.W
TEXT_LOCATION_RIGHT = tk.E
TEXT_LOCATION_TOP_LEFT = tk.NW
TEXT_LOCATION_TOP_RIGHT = tk.NE
TEXT_LOCATION_BOTTOM_LEFT = tk.SW
TEXT_LOCATION_BOTTOM_RIGHT = tk.SE
TEXT_LOCATION_CENTER = tk.CENTER

GRAB_ANYWHERE_IGNORE_THESE_WIDGETS = (
    ttk.Sizegrip, tk.Scale, ttk.Scrollbar, tk.Scrollbar, tk.Entry, tk.Text, tk.PanedWindow, tk.Listbox, tk.OptionMenu, ttk.Treeview
)

# ----====----====----==== Constants the user should NOT f-with ====----====----====----#
ThisRow = 555666777  # magic number

# DEFAULT_WINDOW_ICON = ''
MESSAGE_BOX_LINE_WIDTH = 60

# "Special" Key Values.. reserved
# Key representing a Read timeout
EVENT_TIMEOUT = TIMEOUT_EVENT = TIMEOUT_KEY = '__TIMEOUT__'
EVENT_TIMER = TIMER_KEY = '__TIMER EVENT__'
WIN_CLOSED = WINDOW_CLOSED = None
WINDOW_CLOSE_ATTEMPTED_EVENT = WIN_X_EVENT = WIN_CLOSE_ATTEMPTED_EVENT = '-WINDOW CLOSE ATTEMPTED-'
WINDOW_CONFIG_EVENT = '__WINDOW CONFIG__'
TITLEBAR_MINIMIZE_KEY = '__TITLEBAR MINIMIZE__'
TITLEBAR_MAXIMIZE_KEY = '__TITLEBAR MAXIMIZE__'
TITLEBAR_CLOSE_KEY = '__TITLEBAR CLOSE__'
TITLEBAR_IMAGE_KEY = '__TITLEBAR IMAGE__'
TITLEBAR_TEXT_KEY = '__TITLEBAR TEXT__'
TITLEBAR_KEY = '__TITLEBAR__'
TITLEBAR_DO_NOT_USE_AN_ICON = '__TITLEBAR_NO_ICON__'

# Key indicating should not create any return values for element
WRITE_ONLY_KEY = '__WRITE ONLY__'

MENU_DISABLED_CHARACTER = '!'
MENU_SHORTCUT_CHARACTER = '&'
MENU_KEY_SEPARATOR = '::'
MENU_SEPARATOR_LINE = '---'
MENU_RIGHT_CLICK_EDITME_EXIT = ['', ['Edit Me', 'Exit']]
MENU_RIGHT_CLICK_EDITME_VER_EXIT = ['', ['Edit Me', 'Version', 'Exit']]
MENU_RIGHT_CLICK_EDITME_VER_EXPLORER_EXIT = ['', ['Edit Me', 'Version', 'Show in Explorer', 'Exit']]
MENU_RIGHT_CLICK_EDITME_VER_LOC_EXIT = ['', ['Edit Me', 'Version', 'File Location', 'Exit']]
MENU_RIGHT_CLICK_EDITME_VER_SETTINGS_EXIT = ['', ['Edit Me', 'Settings', 'Version', 'Exit']]
MENU_RIGHT_CLICK_EXIT = ['', ['Exit']]
MENU_RIGHT_CLICK_DISABLED = ['', []]
_MENU_RIGHT_CLICK_TABGROUP_DEFAULT = ['TABGROUP DEFAULT', []]
ENABLE_TK_WINDOWS = False

USE_CUSTOM_TITLEBAR = None
CUSTOM_TITLEBAR_BACKGROUND_COLOR = None
CUSTOM_TITLEBAR_TEXT_COLOR = None
CUSTOM_TITLEBAR_ICON = None
CUSTOM_TITLEBAR_FONT = None
TITLEBAR_METADATA_MARKER = 'This window has a titlebar'

CUSTOM_MENUBAR_METADATA_MARKER = 'This is a custom menubar'

SUPPRESS_ERROR_POPUPS = False
SUPPRESS_RAISE_KEY_ERRORS = True
SUPPRESS_KEY_GUESSING = False
SUPPRESS_WIDGET_NOT_FINALIZED_WARNINGS = False
ENABLE_TREEVIEW_869_PATCH = True

# These are now set based on the global settings file
ENABLE_MAC_NOTITLEBAR_PATCH = False
ENABLE_MAC_MODAL_DISABLE_PATCH = False
ENABLE_MAC_DISABLE_GRAB_ANYWHERE_WITH_TITLEBAR = True
ENABLE_MAC_ALPHA_99_PATCH = False

OLD_TABLE_TREE_SELECTED_ROW_COLORS = ('#FFFFFF', '#4A6984')
ALTERNATE_TABLE_AND_TREE_SELECTED_ROW_COLORS = ('SystemHighlightText', 'SystemHighlight')

# Some handy unicode symbols
SYMBOL_SQUARE = '█'
SYMBOL_CIRCLE = '⚫'
SYMBOL_CIRCLE_OUTLINE = '◯'
SYMBOL_BULLET = '•'
SYMBOL_UP = '▲'
SYMBOL_RIGHT = '►'
SYMBOL_LEFT = '◄'
SYMBOL_DOWN = '▼'
SYMBOL_X = '❎'
SYMBOL_CHECK = '✅'
SYMBOL_CHECK_SMALL = '✓'
SYMBOL_X_SMALL = '✗'
SYMBOL_BALLOT_X = '☒'
SYMBOL_BALLOT_CHECK = '☑'
SYMBOL_LEFT_DOUBLE = '«'
SYMBOL_RIGHT_DOUBLE = '»'
SYMBOL_LEFT_ARROWHEAD = '⮜'
SYMBOL_RIGHT_ARROWHEAD = '⮞'
SYMBOL_UP_ARROWHEAD = '⮝'
SYMBOL_DOWN_ARROWHEAD = '⮟'
SYMBOL_HOURGLASS = '⌛' if running_windows() or running_mac() else ''

if sum([int(i) for i in tclversion_detailed.split('.')]) > 19:
    SYMBOL_TITLEBAR_MINIMIZE = '_'
    SYMBOL_TITLEBAR_MAXIMIZE = '◻'
    SYMBOL_TITLEBAR_CLOSE = 'Ｘ'
else:
    SYMBOL_TITLEBAR_MINIMIZE = '_'
    SYMBOL_TITLEBAR_MAXIMIZE = 'O'
    SYMBOL_TITLEBAR_CLOSE = 'X'

#################### PATHS for user_settings APIs ####################
# These paths are passed to os.path.expanduser to get the default path for user_settings
# They can be changed using set_options

DEFAULT_USER_SETTINGS_WIN_PATH = r'%AppData%\Local\FreeSimpleGUI\settings'
DEFAULT_USER_SETTINGS_LINUX_PATH = r'~/.config/FreeSimpleGUI/settings'
DEFAULT_USER_SETTINGS_MAC_PATH = r'~/Library/Application Support/FreeSimpleGUI/settings'
DEFAULT_USER_SETTINGS_TRINKET_PATH = r'.'
DEFAULT_USER_SETTINGS_REPLIT_PATH = r'.'
DEFAULT_USER_SETTINGS_UNKNOWN_OS_PATH = r'~/Library/Application Support/FreeSimpleGUI/settings'
DEFAULT_USER_SETTINGS_PATH = None  # value set by user to override all paths above
DEFAULT_USER_SETTINGS_FREESIMPLEGUI_PATH = None  # location of the global FreeSimpleGUI settings
DEFAULT_USER_SETTINGS_FREESIMPLEGUI_FILENAME = '_FreeSimpleGUI_settings_global_.json'  # location of the global FreeSimpleGUI settings


# ====================================================================== #
# One-liner functions that are handy as f_ck                             #
# ====================================================================== #
def rgb(red, green, blue):
    """Given integer values of Red, Green, Blue, return a color string "#RRGGBB"

    :param red:   Red portion from 0 to 255
    :type red:    (int)
    :param green: Green portion from 0 to 255
    :type green:  (int)
    :param blue:  Blue portion from 0 to 255
    :type  blue:  (int)
    :return:      A single RGB String in the format "#RRGGBB" where each pair is a hex number.
    :rtype:       (str)
    """
    red = min(int(red), 255) if red > 0 else 0
    blue = min(int(blue), 255) if blue > 0 else 0
    green = min(int(green), 255) if green > 0 else 0
    return '#%02x%02x%02x' % (red, green, blue)


# ====================================================================== #
# Enums for types                                                        #
# ====================================================================== #
# -------------------------  Button types  ------------------------- #
# uncomment this line and indent to go back to using Enums
BUTTON_TYPE_BROWSE_FOLDER = 1
BUTTON_TYPE_BROWSE_FILE = 2
BUTTON_TYPE_BROWSE_FILES = 21
BUTTON_TYPE_SAVEAS_FILE = 3
BUTTON_TYPE_CLOSES_WIN = 5
BUTTON_TYPE_CLOSES_WIN_ONLY = 6
BUTTON_TYPE_READ_FORM = 7
BUTTON_TYPE_REALTIME = 9
BUTTON_TYPE_CALENDAR_CHOOSER = 30
BUTTON_TYPE_COLOR_CHOOSER = 40
BUTTON_TYPE_SHOW_DEBUGGER = 50

BROWSE_FILES_DELIMITER = ';'  # the delimiter to be used between each file in the returned string

FILE_TYPES_ALL_FILES = (("ALL Files", "*.* *"),)

BUTTON_DISABLED_MEANS_IGNORE = 'ignore'

# -------------------------  Element types  ------------------------- #

ELEM_TYPE_TEXT = 'text'
ELEM_TYPE_INPUT_TEXT = 'input'
ELEM_TYPE_INPUT_COMBO = 'combo'
ELEM_TYPE_INPUT_OPTION_MENU = 'option menu'
ELEM_TYPE_INPUT_RADIO = 'radio'
ELEM_TYPE_INPUT_MULTILINE = 'multiline'
ELEM_TYPE_INPUT_CHECKBOX = 'checkbox'
ELEM_TYPE_INPUT_SPIN = 'spind'
ELEM_TYPE_BUTTON = 'button'
ELEM_TYPE_IMAGE = 'image'
ELEM_TYPE_CANVAS = 'canvas'
ELEM_TYPE_FRAME = 'frame'
ELEM_TYPE_GRAPH = 'graph'
ELEM_TYPE_TAB = 'tab'
ELEM_TYPE_TAB_GROUP = 'tabgroup'
ELEM_TYPE_INPUT_SLIDER = 'slider'
ELEM_TYPE_INPUT_LISTBOX = 'listbox'
ELEM_TYPE_OUTPUT = 'output'
ELEM_TYPE_COLUMN = 'column'
ELEM_TYPE_MENUBAR = 'menubar'
ELEM_TYPE_PROGRESS_BAR = 'progressbar'
ELEM_TYPE_BLANK = 'blank'
ELEM_TYPE_TABLE = 'table'
ELEM_TYPE_TREE = 'tree'
ELEM_TYPE_ERROR = 'error'
ELEM_TYPE_SEPARATOR = 'separator'
ELEM_TYPE_STATUSBAR = 'statusbar'
ELEM_TYPE_PANE = 'pane'
ELEM_TYPE_BUTTONMENU = 'buttonmenu'
ELEM_TYPE_TITLEBAR = 'titlebar'
ELEM_TYPE_SIZEGRIP = 'sizegrip'

# STRETCH == ERROR ELEMENT as a filler

# -------------------------  Popup Buttons Types  ------------------------- #
POPUP_BUTTONS_YES_NO = 1
POPUP_BUTTONS_CANCELLED = 2
POPUP_BUTTONS_ERROR = 3
POPUP_BUTTONS_OK_CANCEL = 4
POPUP_BUTTONS_OK = 0
POPUP_BUTTONS_NO_BUTTONS = 5

PSG_THEME_PART_BUTTON_TEXT = 'Button Text Color'
PSG_THEME_PART_BUTTON_BACKGROUND = 'Button Background Color'
PSG_THEME_PART_BACKGROUND = 'Background Color'
PSG_THEME_PART_INPUT_BACKGROUND = 'Input Element Background Color'
PSG_THEME_PART_INPUT_TEXT = 'Input Element Text Color'
PSG_THEME_PART_TEXT = 'Text Color'
PSG_THEME_PART_SLIDER = 'Slider Color'
PSG_THEME_PART_LIST = [PSG_THEME_PART_BACKGROUND, PSG_THEME_PART_BUTTON_BACKGROUND, PSG_THEME_PART_BUTTON_TEXT, PSG_THEME_PART_INPUT_BACKGROUND, PSG_THEME_PART_INPUT_TEXT,
                       PSG_THEME_PART_TEXT, PSG_THEME_PART_SLIDER]

# theme_button

TTK_SCROLLBAR_PART_TROUGH_COLOR = 'Trough Color'
TTK_SCROLLBAR_PART_BACKGROUND_COLOR = 'Background Color'
TTK_SCROLLBAR_PART_ARROW_BUTTON_ARROW_COLOR = 'Arrow Button Arrow Color'
TTK_SCROLLBAR_PART_FRAME_COLOR = 'Frame Color'
TTK_SCROLLBAR_PART_SCROLL_WIDTH = 'Frame Width'
TTK_SCROLLBAR_PART_ARROW_WIDTH = 'Arrow Width'
TTK_SCROLLBAR_PART_RELIEF = 'Relief'
TTK_SCROLLBAR_PART_LIST = [TTK_SCROLLBAR_PART_TROUGH_COLOR, TTK_SCROLLBAR_PART_BACKGROUND_COLOR, TTK_SCROLLBAR_PART_ARROW_BUTTON_ARROW_COLOR,
                           TTK_SCROLLBAR_PART_FRAME_COLOR, TTK_SCROLLBAR_PART_SCROLL_WIDTH, TTK_SCROLLBAR_PART_ARROW_WIDTH, TTK_SCROLLBAR_PART_RELIEF]
TTK_SCROLLBAR_PART_THEME_BASED_LIST = [TTK_SCROLLBAR_PART_TROUGH_COLOR, TTK_SCROLLBAR_PART_BACKGROUND_COLOR, TTK_SCROLLBAR_PART_ARROW_BUTTON_ARROW_COLOR,
                                       TTK_SCROLLBAR_PART_FRAME_COLOR]
DEFAULT_TTK_PART_MAPPING_DICT = {TTK_SCROLLBAR_PART_TROUGH_COLOR: PSG_THEME_PART_SLIDER,
                                 TTK_SCROLLBAR_PART_BACKGROUND_COLOR: PSG_THEME_PART_BUTTON_BACKGROUND,
                                 TTK_SCROLLBAR_PART_ARROW_BUTTON_ARROW_COLOR: PSG_THEME_PART_BUTTON_TEXT,
                                 TTK_SCROLLBAR_PART_FRAME_COLOR: PSG_THEME_PART_BACKGROUND,
                                 TTK_SCROLLBAR_PART_SCROLL_WIDTH: 12,
                                 TTK_SCROLLBAR_PART_ARROW_WIDTH: 12,
                                 TTK_SCROLLBAR_PART_RELIEF: RELIEF_RAISED}

ttk_part_mapping_dict = copy.copy(DEFAULT_TTK_PART_MAPPING_DICT)

class TTKPartOverrides():
    """
    This class contains "overrides" to the defaults for ttk scrollbars that are defined in the global settings file.
    This class is used in every element, in the Window class and there's a global one that is used by set_options.
    """

    def __init__(self, sbar_trough_color=None, sbar_background_color=None, sbar_arrow_color=None, sbar_width=None, sbar_arrow_width=None, sbar_frame_color=None, sbar_relief=None):
        self.sbar_trough_color = sbar_trough_color
        self.sbar_background_color = sbar_background_color
        self.sbar_arrow_color = sbar_arrow_color
        self.sbar_width = sbar_width
        self.sbar_arrow_width = sbar_arrow_width
        self.sbar_frame_color = sbar_frame_color
        self.sbar_relief = sbar_relief


ttk_part_overrides_from_options = TTKPartOverrides()

# -------------------------  tkinter BASIC cursors... there are some OS dependent ones too  ------------------------- #
TKINTER_CURSORS = ['X_cursor', 'arrow', 'based_arrow_down', 'based_arrow_up', 'boat',
                   'bogosity', 'bottom_left_corner', 'bottom_right_corner', 'bottom_side',
                   'bottom_tee', 'box_spiral', 'center_ptr', 'circle', 'clock',
                   'coffee_mug', 'cross', 'cross_reverse', 'crosshair', 'diamond_cross',
                   'dot', 'dotbox', 'double_arrow', 'draft_large', 'draft_small', 'draped_box',
                   'exchange', 'fleur', 'gobbler', 'gumby', 'hand1', 'hand2', 'heart',
                   'icon', 'iron_cross', 'left_ptr', 'left_side', 'left_tee', 'leftbutton',
                   'll_angle', 'lr_angle', 'man', 'middlebutton', 'mouse', 'pencil', 'pirate',
                   'plus', 'question_arrow', 'right_ptr', 'right_side', 'right_tee',
                   'rightbutton', 'rtl_logo', 'sailboat', 'sb_down_arrow', 'sb_h_double_arrow',
                   'sb_left_arrow', 'sb_right_arrow', 'sb_up_arrow', 'sb_v_double_arrow',
                   'shuttle', 'sizing', 'spider', 'spraycan', 'star', 'target', 'tcross',
                   'top_left_arrow', 'top_left_corner', 'top_right_corner', 'top_side', 'top_tee',
                   'trek', 'ul_angle', 'umbrella', 'ur_angle', 'watch', 'xterm']

# -------------------------  tkinter key codes for bindings  ------------------------- #

# The keycode that when pressed will take a snapshot of the current window
DEFAULT_WINDOW_SNAPSHOT_KEY_CODE = None
DEFAULT_WINDOW_SNAPSHOT_KEY = '--SCREENSHOT THIS WINDOW--'

tkinter_keysyms = (
'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'minus', 'period', 'slash',
'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e',
'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'nobreakspace',
'exclamdown', 'cent', 'sterling', 'currency', 'yen', 'brokenbar', 'section', 'diaeresis', 'copyright', 'ordfeminine', 'guillemotleft', 'notsign', 'hyphen', 'registered', 'macron',
'degree', 'plusminus', 'twosuperior', 'threesuperior', 'acute', 'mu', 'paragraph', 'periodcentered', 'cedilla', 'onesuperior', 'masculine', 'guillemotright', 'onequarter',
'onehalf', 'threequarters', 'questiondown', 'Agrave', 'Aacute', 'Acircumflex', 'Atilde', 'Adiaeresis', 'Aring', 'AE', 'Ccedilla', 'Egrave', 'Eacute', 'Ecircumflex', 'Ediaeresis',
'Igrave', 'Iacute', 'Icircumflex', 'Idiaeresis', 'Eth', 'Ntilde', 'Ograve', 'Oacute', 'Ocircumflex', 'Otilde', 'Odiaeresis', 'multiply', 'Ooblique', 'Ugrave', 'Uacute',
'Ucircumflex', 'Udiaeresis', 'Yacute', 'Thorn', 'ssharp', 'agrave', 'aacute', 'acircumflex', 'atilde', 'adiaeresis', 'aring', 'ae', 'ccedilla', 'egrave', 'eacute', 'ecircumflex',
'ediaeresis', 'igrave', 'iacute', 'icircumflex', 'idiaeresis', 'eth', 'ntilde', 'ograve', 'oacute', 'ocircumflex', 'otilde', 'odiaeresis', 'division', 'oslash', 'ugrave', 'uacute',
'ucircumflex', 'udiaeresis', 'yacute', 'thorn', 'ydiaeresis', 'Aogonek', 'breve', 'Lstroke', 'Lcaron', 'Sacute', 'Scaron', 'Scedilla', 'Tcaron', 'Zacute', 'Zcaron', 'Zabovedot',
'aogonek', 'ogonek', 'lstroke', 'lcaron', 'sacute', 'caron', 'scaron', 'scedilla', 'tcaron', 'zacute', 'doubleacute', 'zcaron', 'zabovedot', 'Racute', 'Abreve', 'Cacute', 'Ccaron',
'Eogonek', 'Ecaron', 'Dcaron', 'Nacute', 'Ncaron', 'Odoubleacute', 'Rcaron', 'Uring', 'Udoubleacute', 'Tcedilla', 'racute', 'abreve', 'cacute', 'ccaron', 'eogonek', 'ecaron',
'dcaron', 'nacute', 'ncaron', 'odoubleacute', 'rcaron', 'uring', 'udoubleacute', 'tcedilla', 'abovedot',
'leftradical', 'topleftradical', 'horizconnector', 'topintegral', 'botintegral', 'vertconnector', 'topleftsqbracket', 'botleftsqbracket', 'toprightsqbracket', 'botrightsqbracket',
'topleftparens', 'botleftparens', 'toprightparens', 'botrightparens', 'leftmiddlecurlybrace', 'rightmiddlecurlybrace', 'topleftsummation', 'botleftsummation',
'topvertsummationconnector', 'botvertsummationconnector', 'toprightsummation', 'botrightsummation', 'rightmiddlesummation', 'lessthanequal', 'notequal', 'greaterthanequal',
'integral', 'therefore', 'variation', 'infinity', 'nabla', 'approximate', 'similarequal', 'ifonlyif', 'implies', 'identical', 'radical', 'includedin', 'includes', 'intersection',
'union', 'logicaland', 'logicalor', 'partialderivative', 'function', 'leftarrow', 'uparrow', 'rightarrow', 'downarrow', 'blank', 'soliddiamond', 'checkerboard', 'ht', 'ff', 'cr',
'lf', 'nl', 'vt', 'lowrightcorner', 'uprightcorner', 'upleftcorner', 'lowleftcorner', 'crossinglines', 'horizlinescan1', 'horizlinescan3', 'horizlinescan5', 'horizlinescan7',
'horizlinescan9', 'leftt', 'rightt', 'bott', 'topt', 'vertbar', 'emspace', 'enspace', 'em3space', 'em4space', 'digitspace', 'punctspace', 'thinspace', 'hairspace', 'emdash',
'endash', 'signifblank', 'ellipsis', 'doubbaselinedot', 'onethird', 'twothirds', 'onefifth', 'twofifths', 'threefifths', 'fourfifths', 'onesixth', 'fivesixths', 'careof',
'figdash', 'leftanglebracket', 'decimalpoint', 'rightanglebracket', 'marker', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'trademark', 'signaturemark',
'trademarkincircle', 'leftopentriangle', 'rightopentriangle', 'emopencircle', 'emopenrectangle', 'leftsinglequotemark', 'rightsinglequotemark', 'leftdoublequotemark',
'rightdoublequotemark', 'prescription', 'minutes', 'seconds', 'latincross', 'hexagram', 'filledrectbullet', 'filledlefttribullet', 'filledrighttribullet', 'emfilledcircle',
'emfilledrect', 'enopencircbullet', 'enopensquarebullet', 'openrectbullet', 'opentribulletup', 'opentribulletdown', 'openstar', 'enfilledcircbullet', 'enfilledsqbullet',
'filledtribulletup', 'filledtribulletdown', 'leftpointer', 'rightpointer', 'club', 'diamond', 'heart', 'maltesecross', 'dagger', 'doubledagger', 'checkmark', 'ballotcross',
'musicalsharp', 'musicalflat', 'malesymbol', 'femalesymbol', 'telephone', 'telephonerecorder', 'phonographcopyright', 'caret', 'singlelowquotemark', 'doublelowquotemark', 'cursor',
'leftcaret', 'rightcaret', 'downcaret', 'upcaret', 'overbar', 'downtack', 'upshoe', 'downstile', 'underbar', 'jot', 'quad', 'uptack', 'circle', 'upstile', 'downshoe', 'rightshoe',
'leftshoe', 'lefttack', 'righttack', 'BackSpace', 'Tab', 'Linefeed', 'Clear', 'Return', 'Pause', 'Scroll_Lock',
'Sys_Req', 'Escape', 'Multi_key', 'Kanji', 'Home', 'Left', 'Up', 'Right', 'Down', 'Prior', 'Next', 'End', 'Begin', 'Win_L', 'Win_R', 'App', 'Select', 'Print', 'Execute', 'Insert',
'Undo', 'Redo', 'Menu', 'Find', 'Cancel', 'Help', 'Break', 'Hebrew_switch', 'Num_Lock', 'KP_Space', 'KP_Tab', 'KP_Enter', 'KP_F1', 'KP_F2', 'KP_F3', 'KP_F4', 'KP_Multiply',
'KP_Add', 'KP_Separator', 'KP_Subtract', 'KP_Decimal', 'KP_Divide', 'KP_0', 'KP_1', 'KP_2', 'KP_3', 'KP_4', 'KP_5', 'KP_6', 'KP_7', 'KP_8', 'KP_9', 'KP_Equal', 'F1', 'F2', 'F3',
'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12', 'L1', 'L2', 'L3', 'L4', 'L5', 'L6', 'L7', 'L8', 'L9', 'L10', 'R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8', 'R9', 'R10',
'R11', 'R12', 'F33', 'R14', 'R15', 'Shift_L', 'Shift_R', 'Control_L', 'Control_R', 'Caps_Lock', 'Shift_Lock', 'Meta_L', 'Meta_R', 'Alt_L', 'Alt_R', 'Super_L', 'Super_R', 'Hyper_L',
'Hyper_R', 'Delete')


# ------------------------------------------------------------------------- #
#                       ToolTip used by the Elements                        #
# ------------------------------------------------------------------------- #

class ToolTip:
    """Create a tooltip for a given widget

    This is an INTERNALLY USED only class.
    Users should not refer to this class at all.
    """

    def __init__(self, widget, text, timeout=DEFAULT_TOOLTIP_TIME):
        """
        :param widget:  The tkinter widget
        :type widget:   widget type varies
        :param text:    text for the tooltip. It can inslude. If None tip won't be shown
        :type text:     str | None
        :param timeout: Time in milliseconds that mouse must remain still before tip is shown
        :type timeout:  (int)
        """
        self.widget = widget
        self.text = text            # Set to None and tooltip will be not shown
        self.timeout = timeout
        # self.wraplength = wraplength if wraplength else widget.winfo_screenwidth() // 2
        self.tipwindow = None
        self.id = None
        self.x = self.y = 0
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)
        self.widget.bind("<ButtonPress>", self.leave)

    def enter(self, event=None):
        """Called by tkinter when mouse enters a widget

        :param event: from tkinter.  Has x,y coordinates of mouse
        :type event:

        """
        if self.text is None: # if tip is diabled
            return
        self.x = event.x
        self.y = event.y
        self.schedule()

    def leave(self, event=None):
        """Called by tktiner when mouse exits a widget

        :param event: from tkinter.  Event info that's not used by function.
        :type event:

        """
        self.unschedule()
        self.hidetip()

    def schedule(self):
        """Schedules a timer to time how long mouse is hovering"""

        self.unschedule()
        self.id = self.widget.after(self.timeout, self.showtip)

    def unschedule(self):
        """Cancels timer used to time mouse hover"""
        if self.id:
            self.widget.after_cancel(self.id)
        self.id = None

    def showtip(self):
        """Creates a topoltip window with the tooltip text inside of it"""

        if self.tipwindow:
            return
        x = self.widget.winfo_rootx() + self.x + DEFAULT_TOOLTIP_OFFSET[0]
        y = self.widget.winfo_rooty() + self.y + DEFAULT_TOOLTIP_OFFSET[1]
        self.tipwindow = tk.Toplevel(self.widget)
        # if not sys.platform.startswith('darwin'):
        try:
            self.tipwindow.wm_overrideredirect(True)
            # if running_mac() and ENABLE_MAC_NOTITLEBAR_PATCH:
            if _mac_should_apply_notitlebar_patch():
                self.tipwindow.wm_overrideredirect(False)
        except Exception as e:
            print('* Error performing wm_overrideredirect in showtip *', e)
        self.tipwindow.wm_geometry("+%d+%d" % (x, y))
        self.tipwindow.wm_attributes("-topmost", 1)

        label = ttk.Label(self.tipwindow, text=self.text, justify=tk.LEFT,
                          background=TOOLTIP_BACKGROUND_COLOR, relief=tk.SOLID, borderwidth=1)
        if TOOLTIP_FONT is not None:
            label.config(font=TOOLTIP_FONT)
        label.pack()

    def hidetip(self):
        """Destroys the tooltip window"""
        if self.tipwindow:
            self.tipwindow.destroy()
        self.tipwindow = None

    def remove(self):
        """Removes the tooltip from the widget"""
        self.text = None

# ---------------------------------------------------------------------- #
# Cascading structure.... Objects get larger                             #
#   Button                                                               #
#       Element                                                          #
#           Row                                                          #
#               Form                                                     #
# ---------------------------------------------------------------------- #
# ------------------------------------------------------------------------- #
#                       Element CLASS                                       #
# ------------------------------------------------------------------------- #
class Element():
    """ The base class for all Elements. Holds the basic description of an Element like size and colors """

    def __init__(self, type, size=(None, None), auto_size_text=None, font=None, background_color=None, text_color=None, key=None, pad=None, tooltip=None,
                 visible=True, metadata=None, sbar_trough_color=None, sbar_background_color=None, sbar_arrow_color=None, sbar_width=None, sbar_arrow_width=None, sbar_frame_color=None, sbar_relief=None):
        """Element base class

        NOTE: Only used internally.
        User need not create an Element objects.

        :param type:                        The type of element. These constants all start with "ELEM_TYPE_"
        :type type:                         (int) (could be enum)
        :param size:                        w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                         (int, int) | (None, None) | int
        :param auto_size_text:              True if the Widget should be shrunk to exactly fit the number of chars to show
        :type auto_size_text:               bool
        :param font:                        specifies the font family, size. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                         (str or (str, int[, str]) or None)
        :param background_color:            color of background. Can be in #RRGGBB format or a color name "black"
        :type background_color:             (str)
        :param text_color:                  element's text color. Can be in #RRGGBB format or a color name "black"
        :type text_color:                   (str)
        :param key:                         Identifies an Element. Should be UNIQUE to this window.
        :type key:                          str | int | tuple | object
        :param pad:                         Amount of padding to put around element in pixels (left/right, top/bottom). If an int is given, then auto-converted to tuple (int, int)
        :type pad:                          (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:                     text, that will appear when mouse hovers over the element
        :type tooltip:                      (str)
        :param visible:                     set visibility state of the element (Default = True)
        :type visible:                      (bool)
        :param metadata:                    User metadata that can be set to ANYTHING
        :type metadata:                     (Any)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        """

        if size is not None and size != (None, None):
            if isinstance(size, int):
                size = (size, 1)
            if isinstance(size, tuple) and len(size) == 1:
                size = (size[0], 1)

        if pad is not None and pad != (None, None):
            if isinstance(pad, int):
                pad = (pad, pad)

        self.Size = size
        self.Type = type
        self.AutoSizeText = auto_size_text

        self.Pad = pad
        self.Font = font

        self.TKStringVar = None
        self.TKIntVar = None
        self.TKText = None
        self.TKEntry = None
        self.TKImage = None
        self.ttk_style_name = ''  # The ttk style name (if this is a ttk widget)
        self.ttk_style = None  # The ttk Style object (if this is a ttk widget)
        self._metadata = None  # type: Any
        if not hasattr(self, 'setting'):
            self.setting = None       # If no setting has been set yet, set it to None
        self.ParentForm = None  # type: Window
        self.ParentContainer = None  # will be a Form, Column, or Frame element # UNBIND
        self.TextInputDefault = None
        self.Position = (0, 0)  # Default position Row 0, Col 0
        self.BackgroundColor = background_color if background_color is not None else DEFAULT_ELEMENT_BACKGROUND_COLOR
        self.TextColor = text_color if text_color is not None else DEFAULT_ELEMENT_TEXT_COLOR
        self.Key = key  # dictionary key for return values
        self.Tooltip = tooltip
        self.TooltipObject = None       # type: ToolTip
        self._visible = visible
        self.TKRightClickMenu = None
        self.Widget = None  # Set when creating window. Has the main tkinter widget for element
        self.Tearoff = False  # needed because of right click menu code
        self.ParentRowFrame = None  # type tk.Frame
        self.metadata = metadata
        self.user_bind_dict = {}  # Used when user defines a tkinter binding using bind method - convert bind string to key modifier
        self.user_bind_event = None  # Used when user defines a tkinter binding using bind method - event data from tkinter
        # self.pad_used = (0, 0)  # the amount of pad used when was inserted into the layout
        self._popup_menu_location = (None, None)
        self.pack_settings = None
        self.vsb_style_name = None  # ttk style name used for the verical scrollbar if one is attached to element
        self.hsb_style_name = None  # ttk style name used for the horizontal scrollbar if one is attached to element
        self.vsb_style = None  # The ttk style used for the vertical scrollbar if one is attached to element
        self.hsb_style = None  # The ttk style used for the horizontal scrollbar if one is attached to element
        self.hsb = None  # The horizontal scrollbar if one is attached to element
        self.vsb = None  # The vertical scrollbar if one is attached to element
        ## TTK Scrollbar Settings
        self.ttk_part_overrides = TTKPartOverrides(sbar_trough_color=sbar_trough_color, sbar_background_color=sbar_background_color, sbar_arrow_color=sbar_arrow_color,
                                                   sbar_width=sbar_width, sbar_arrow_width=sbar_arrow_width, sbar_frame_color=sbar_frame_color, sbar_relief=sbar_relief)

        PSG_THEME_PART_FUNC_MAP = {PSG_THEME_PART_BACKGROUND: theme_background_color,
                                   PSG_THEME_PART_BUTTON_BACKGROUND: theme_button_color_background,
                                   PSG_THEME_PART_BUTTON_TEXT: theme_button_color_text,
                                   PSG_THEME_PART_INPUT_BACKGROUND: theme_input_background_color,
                                   PSG_THEME_PART_INPUT_TEXT: theme_input_text_color,
                                   PSG_THEME_PART_TEXT: theme_text_color,
                                   PSG_THEME_PART_SLIDER: theme_slider_color}

        # class Theme_Parts():
        #     PSG_THEME_PART_FUNC_MAP = {PSG_THEME_PART_BACKGROUND: theme_background_color,
        if sbar_trough_color is not None:
            self.scroll_trough_color = sbar_trough_color
        else:
            self.scroll_trough_color = PSG_THEME_PART_FUNC_MAP.get(ttk_part_mapping_dict[TTK_SCROLLBAR_PART_TROUGH_COLOR], ttk_part_mapping_dict[TTK_SCROLLBAR_PART_TROUGH_COLOR])
            if callable(self.scroll_trough_color):
                self.scroll_trough_color = self.scroll_trough_color()

        if sbar_background_color is not None:
            self.scroll_background_color = sbar_background_color
        else:
            self.scroll_background_color = PSG_THEME_PART_FUNC_MAP.get(ttk_part_mapping_dict[TTK_SCROLLBAR_PART_BACKGROUND_COLOR],
                                                                       ttk_part_mapping_dict[TTK_SCROLLBAR_PART_BACKGROUND_COLOR])
            if callable(self.scroll_background_color):
                self.scroll_background_color = self.scroll_background_color()

        if sbar_arrow_color is not None:
            self.scroll_arrow_color = sbar_arrow_color
        else:
            self.scroll_arrow_color = PSG_THEME_PART_FUNC_MAP.get(
                ttk_part_mapping_dict[TTK_SCROLLBAR_PART_ARROW_BUTTON_ARROW_COLOR],
                ttk_part_mapping_dict[TTK_SCROLLBAR_PART_ARROW_BUTTON_ARROW_COLOR])
            if callable(self.scroll_arrow_color):
                self.scroll_arrow_color = self.scroll_arrow_color()

        if sbar_frame_color is not None:
            self.scroll_frame_color = sbar_frame_color
        else:
            self.scroll_frame_color = PSG_THEME_PART_FUNC_MAP.get(ttk_part_mapping_dict[TTK_SCROLLBAR_PART_FRAME_COLOR], ttk_part_mapping_dict[TTK_SCROLLBAR_PART_FRAME_COLOR])
            if callable(self.scroll_frame_color):
                self.scroll_frame_color = self.scroll_frame_color()

        if sbar_relief is not None:
            self.scroll_relief = sbar_relief
        else:
            self.scroll_relief = ttk_part_mapping_dict[TTK_SCROLLBAR_PART_RELIEF]

        if sbar_width is not None:
            self.scroll_width = sbar_width
        else:
            self.scroll_width = ttk_part_mapping_dict[TTK_SCROLLBAR_PART_SCROLL_WIDTH]

        if sbar_arrow_width is not None:
            self.scroll_arrow_width = sbar_arrow_width
        else:
            self.scroll_arrow_width = ttk_part_mapping_dict[TTK_SCROLLBAR_PART_ARROW_WIDTH]

        if not hasattr(self, 'DisabledTextColor'):
            self.DisabledTextColor = None
        if not hasattr(self, 'ItemFont'):
            self.ItemFont = None
        if not hasattr(self, 'RightClickMenu'):
            self.RightClickMenu = None
        if not hasattr(self, 'Disabled'):
            self.Disabled = None  # in case the element hasn't defined this, add it here

    @property
    def visible(self):
        """Returns visibility state for the element

        This is a `readonly` property.

        :return: Visibility state for element
        :rtype:  (bool)
        """
        return self._visible

    @property
    def metadata(self):
        """Metadata is an Element property that you can use at any time to hold any value

        :return: the current metadata value
        :rtype:  (Any)
        """
        return self._metadata

    @metadata.setter
    def metadata(self, value):
        """Metadata is an Element property that you can use at any time to hold any value

        :param value: Anything you want it to be
        :type value:  (Any)
        """
        self._metadata = value

    @property
    def key(self):
        """Returns key for the element

        This is a `readonly` property.
        Keys can be any hashable objects (basically anything except a list; tuples are OK though).

        :return: The window's Key
        :rtype:  (Any)
        """
        return self.Key

    @property
    def widget(self):
        """Returns tkinter widget for the element

        This is a `readonly` property.
        The implementation is that the Widget member variable is returned.
        This is a backward compatible addition.

        :return:    The element's underlying tkinter widget
        :rtype:     (tkinter.Widget)
        """
        return self.Widget

    def _RightClickMenuCallback(self, event):
        """Callback function that's called when a right click happens

        Shows right click menu as result.

        :param event: information provided by tkinter about the event including x,y location of click
        :type event:

        """
        if self.Type == ELEM_TYPE_TAB_GROUP:
            try:
                index = self.Widget.index('@{},{}'.format(event.x, event.y))
                tab = self.Widget.tab(index, 'text')
                key = self.find_key_from_tab_name(tab)
                tab_element = self.ParentForm.key_dict[key]
                if tab_element.RightClickMenu is None:  # if this tab didn't explicitly have a menu, then don't show anything
                    return
                tab_element.TKRightClickMenu.tk_popup(event.x_root, event.y_root, 0)
                self.TKRightClickMenu.grab_release()
            except:
                pass
            return
        self.TKRightClickMenu.tk_popup(event.x_root, event.y_root, 0)
        self.TKRightClickMenu.grab_release()
        if self.Type == ELEM_TYPE_GRAPH:
            self._update_position_for_returned_values(event)

    def _tearoff_menu_callback(self, parent, menu):
        """Callback function that's called when a right click menu is torn off

        The reason for this function is to relocate the torn-off menu. It will default to 0,0 otherwise.
        This callback moves the right click menu window to the location of the current window.

        :param parent: information provided by tkinter - the parent of the Meny
        :type parent:
        :param menu:   information provided by tkinter - the menu window
        :type menu:

        """
        if self._popup_menu_location == (None, None):
            winx, winy = self.ParentForm.current_location()
        else:
            winx, winy = self._popup_menu_location
        # self.ParentForm.TKroot.update()
        self.ParentForm.TKroot.tk.call('wm', 'geometry', menu, "+{}+{}".format(winx, winy))

    def _MenuItemChosenCallback(self, item_chosen):  # TEXT Menu item callback
        """
        Callback function called when user chooses a menu item from menubar, Button Menu or right click menu

        :param item_chosen: String holding the value chosen.
        :type item_chosen:  str

        """
        # print('IN MENU ITEM CALLBACK', item_chosen)
        self.MenuItemChosen = item_chosen
        self.ParentForm.LastButtonClicked = self.MenuItemChosen
        self.ParentForm.FormRemainedOpen = True
        _exit_mainloop(self.ParentForm)
        # Window._window_that_exited = self.ParentForm
        # self.ParentForm.TKroot.quit()  # kick the users out of the mainloop

    def _FindReturnKeyBoundButton(self, form):
        """Searches for which Button has the flag Button.BindReturnKey set

        It is called recursively when a 'Container Element' is encountered.
        Func has to walk entire window including these 'sub-forms'.

        :param form: the Window object to search
        :type form:
        :return:     Button Object if a button is found, else None
        :rtype:      Button | None
        """
        for row in form.Rows:
            for element in row:
                if element.Type == ELEM_TYPE_BUTTON:
                    if element.BindReturnKey:
                        return element
                if element.Type == ELEM_TYPE_COLUMN:
                    rc = self._FindReturnKeyBoundButton(element)
                    if rc is not None:
                        return rc
                if element.Type == ELEM_TYPE_FRAME:
                    rc = self._FindReturnKeyBoundButton(element)
                    if rc is not None:
                        return rc
                if element.Type == ELEM_TYPE_TAB_GROUP:
                    rc = self._FindReturnKeyBoundButton(element)
                    if rc is not None:
                        return rc
                if element.Type == ELEM_TYPE_TAB:
                    rc = self._FindReturnKeyBoundButton(element)
                    if rc is not None:
                        return rc
                if element.Type == ELEM_TYPE_PANE:
                    rc = self._FindReturnKeyBoundButton(element)
                    if rc is not None:
                        return rc
        return None

    def _TextClickedHandler(self, event):
        """Callback that's called when a text element is clicked on
        with events enabled on the Text Element

        Result is that control is returned back to user (quits main loop).

        :param event:
        :type event:

        """
        # If this is a minimize button for a custom titlebar, then minimize the window
        if self.Key == TITLEBAR_MINIMIZE_KEY:
            if running_linux():
                self.ParentForm.TKroot.wm_attributes("-type", "normal")
                self.ParentForm.TKroot.wm_overrideredirect(False)
                self.ParentForm.TKroot.iconify()
                self.ParentForm.TKroot.bind('<Button-1>', self._titlebar_restore)
            else:
                self.ParentForm.TKroot.wm_overrideredirect(False)
                self.ParentForm.Minimize()
                self.ParentForm.TKroot.bind('<Expose>', self._titlebar_restore)
        elif self.Key == TITLEBAR_MAXIMIZE_KEY:
            if self.ParentForm.maximized:
                self.ParentForm.normal()
            else:
                self.ParentForm.maximize()
        elif self.Key == TITLEBAR_CLOSE_KEY:
            self.ParentForm._OnClosingCallback()
        else:
            self._generic_callback_handler(self.DisplayText)
        return
    def _titlebar_restore(self, event):
        if running_linux():
            self.ParentForm.TKroot.unbind('<Button-1>')
            self.ParentForm.TKroot.deiconify()
            self.ParentForm.TKroot.wm_attributes("-type", 'dock')
        else:
            self.ParentForm.TKroot.unbind('<Expose>')
            self.ParentForm.TKroot.wm_overrideredirect(True)
        self.ParentForm.normal()

    def _ReturnKeyHandler(self, event):
        """Internal callback for the ENTER / RETURN key

        Results in calling the ButtonCallBack for element that has the return key bound to it, just as if button was clicked.

        :param event:
        :type event:

        """
        # if the element is disabled, ignore the event
        if self.Disabled:
            return

        MyForm = self.ParentForm
        button_element = self._FindReturnKeyBoundButton(MyForm)
        if button_element is not None:
            # if the Button has been disabled, then don't perform the callback
            if button_element.Disabled:
                return
            button_element.ButtonCallBack()

    def _generic_callback_handler(self, alternative_to_key=None, force_key_to_be=None):
        """Peforms the actions that were in many of the callback functions previously

        Combined so that it's easier to modify and is in one place now.

        :param event:            From tkinter and is not used
        :type event:             Any
        :param alternate_to_key: If key is None, then use this instead
        :type alternate_to_key:  Any
        """
        if force_key_to_be is not None:
            self.ParentForm.LastButtonClicked = force_key_to_be
        elif self.Key is not None:
            self.ParentForm.LastButtonClicked = self.Key
        else:
            self.ParentForm.LastButtonClicked = alternative_to_key
        self.ParentForm.FormRemainedOpen = True

        _exit_mainloop(self.ParentForm)
        # if self.ParentForm.CurrentlyRunningMainloop:
        #     Window._window_that_exited = self.ParentForm
        #     self.ParentForm.TKroot.quit()  # kick the users out of the mainloop

    def _ListboxSelectHandler(self, event):
        """Internal callback function for when a listbox item is selected

        :param event: Information from tkinter about the callback
        :type event:

        """
        self._generic_callback_handler('')

    def _ComboboxSelectHandler(self, event):
        """Internal callback function for when an entry is selected in a Combobox

        :param event: Event data from tkinter (not used)
        :type event:

        """
        self._generic_callback_handler('')

    def _OptionMenuSelectHandler(self, var, index, mode):
        """Internal callback function for when
            an entry is selected in a OptionMenu

        :param var:     tkinter control variable
        :param index:   index of var, '' if var is not a list
        :param mode:    'w' for 'write' here
        """
        self._generic_callback_handler('')

    def _SpinboxSelectHandler(self, event=None):
        """Internal callback function for when an entry is selected in a Spinbox

        NOTE: The parm is optional because it's not used if arrows are used
                   to change the value but if the return key is pressed,
                   it will include the event parm.

        :param event: Event data passed in by tkinter (not used)
        :type event:
        """
        self._generic_callback_handler('')

    def _RadioHandler(self):
        """Internal callback for when a radio button is selected
            and enable events was set for radio
        """
        self._generic_callback_handler('')

    def _CheckboxHandler(self):
        """Internal callback for when a checkbnox is selected
            and enable events was set for checkbox
        """
        self._generic_callback_handler('')

    def _TabGroupSelectHandler(self, event):
        """Internal callback for when a Tab is selected
            and enable events was set for TabGroup

        :param event: Event data passed in by tkinter (not used)
        :type event:
        """
        self._generic_callback_handler('')

    def _KeyboardHandler(self, event):
        """Internal callback for when a key is pressed
            and return keyboard events was set for window

        :param event: Event data passed in by tkinter (not used)
        :type event:
        """
        # if the element is disabled, ignore the event
        if self.Disabled:
            return
        self._generic_callback_handler('')

    def _ClickHandler(self, event):
        """Internal callback for when a mouse was clicked... maybe

        :param event: Event data passed in by tkinter (not used)
        :type event:
        """
        self._generic_callback_handler('')

    def _this_elements_window_closed(self, quick_check=True):
        if self.ParentForm is not None:
            return self.ParentForm.is_closed(quick_check=quick_check)

        return True

    def _user_bind_callback(self, bind_string, event, propagate=True):
        """Used when user binds a tkinter event directly to an element

        :param bind_string: The event that was bound so can lookup the key modifier
        :type bind_string:  (str)
        :param event:       Event data passed in by tkinter (not used)
        :type event:        (Any)
        :param propagate:   If True then tkinter will be told to propagate the event to the element
        :type propagate:    (bool)
        """
        key_suffix = self.user_bind_dict.get(bind_string, '')
        self.user_bind_event = event
        if self.Type == ELEM_TYPE_GRAPH:
            self._update_position_for_returned_values(event)
        if self.Key is not None:
            if isinstance(self.Key, str):
                key = self.Key + str(key_suffix)
            else:
                key = (self.Key, key_suffix)  # old way (pre 2021) was to make a brand new tuple
                # key = self.Key + (key_suffix,)   # in 2021 tried this. It will break existing applications though - if key is a tuple, add one more item
        else:
            key = bind_string

        self._generic_callback_handler(force_key_to_be=key)

        return 'break' if propagate is not True else None

    def bind(self, bind_string, key_modifier, propagate=True):
        """Used to add tkinter events to an Element

        The tkinter specific data is in the Element's member variable `user_bind_event`.

        :param bind_string:  The string tkinter expected in its bind function
        :type bind_string:   (str)
        :param key_modifier: Additional data to be added to the element's key when event is returned
        :type key_modifier:  (str)
        :param propagate:    If True then tkinter will be told to propagate the event to the element
        :type propagate:     (bool)
        """
        if not self._widget_was_created():  # if widget hasn't been created yet, then don't allow
            return

        try:
            self.Widget.bind(bind_string, lambda evt: self._user_bind_callback(bind_string, evt, propagate))
        except Exception as e:
            self.Widget.unbind_all(bind_string)
            return

        self.user_bind_dict[bind_string] = key_modifier

    def unbind(self, bind_string):
        """Removes a previously bound tkinter event from an Element

        :param bind_string: The string tkinter expected in its `bind` function
        :type bind_string:  (str)
        """
        if not self._widget_was_created():  # if widget hasn't been created yet, then don't allow
            return
        self.Widget.unbind(bind_string)
        self.user_bind_dict.pop(bind_string, None)

    def set_tooltip(self, tooltip_text):
        """Called by application to change the tooltip text for an Element

        Normally invoked using the Element Object such as:
            `window.Element('key').SetToolTip('New tip')`

        :param tooltip_text: The text to show in tooltip.
                             If None then no tooltip will be shown.
        :type tooltip_text:  str | None
        """
        if self.TooltipObject:
            try:
                self.TooltipObject.leave()
            except:
                pass
        self.TooltipObject = ToolTip(self.Widget, text=tooltip_text, timeout=DEFAULT_TOOLTIP_TIME)

    def remove_tooltip(self):
        """Removes a previiously created tooltip for an element"""
        if self.TooltipObject:
            try:
                self.TooltipObject.remove()
            except:
                pass

    def set_focus(self, force=False):
        """Sets the current focus to be on this element

        :param force: if True will call focus_force otherwise calls focus_set
        :type force:  bool
        """
        if not self._widget_was_created():  # if widget hasn't been created yet, then don't allow
            return
        try:
            if force:
                self.Widget.focus_force()
            else:
                self.Widget.focus_set()
        except Exception as e:
            _error_popup_with_traceback("Exception blocking focus. Check your element's Widget", e)

    def block_focus(self, block=True):
        """Enables or disables the element from getting focus by using the keyboard

        If the block parameter is True, then this element will not be given focus
        by using the keyboard to go from one element to another.
        You **can** click on the element and utilize it.

        :param block: if True the element will not get focus via the keyboard
        :type block:  bool
        """
        if not self._widget_was_created():  # if widget hasn't been created yet, then don't allow
            return
        try:
            self.ParentForm.TKroot.focus_force()
            if block:
                self.Widget.configure(takefocus=0)
            else:
                self.Widget.configure(takefocus=1)
        except Exception as e:
            _error_popup_with_traceback("Exception blocking focus. Check your element's Widget", e)

    def get_next_focus(self):
        """Gets the next element that should get focus after this element

        :return:    Element that will get focus after this one
        :rtype:     (Element)
        """
        if not self._widget_was_created():  # if widget hasn't been created yet, then don't allow
            return None
        try:
            next_widget_focus = self.widget.tk_focusNext()
            return self.ParentForm.widget_to_element(next_widget_focus)
        except Exception as e:
            _error_popup_with_traceback("Exception getting next focus. Check your element's Widget", e)

    def get_previous_focus(self):
        """Gets the element that should get focus previous to this element

        :return:    Element that should get the focus before this one
        :rtype:     (Element)
        """
        if not self._widget_was_created():  # if widget hasn't been created yet, then don't allow
            return None
        try:
            next_widget_focus = self.widget.tk_focusPrev()  # tkinter.Widget
            return self.ParentForm.widget_to_element(next_widget_focus)
        except Exception as e:
            _error_popup_with_traceback("Exception getting previous focus. Check your element's Widget", e)

    def set_size(self, size=(None, None)):
        """Changes the size of an element to a specific size

        It's possible to specify None for one of sizes so that only 1 of the element's dimensions are changed.

        :param size: The size in characters, rows typically. In some cases they are pixels
        :type size:  (int, int)
        """
        try:
            if size[0] != None:
                self.Widget.config(width=size[0])
        except:
            print('Warning, error setting width on element with key=', self.Key)
        try:
            if size[1] != None:
                self.Widget.config(height=size[1])
        except:
            try:
                self.Widget.config(length=size[1])
            except:
                print('Warning, error setting height on element with key=', self.Key)

        if self.Type == ELEM_TYPE_GRAPH:
            self.CanvasSize = size

    def get_size(self):
        """Return the size of an element in pixels

        Care must be taken as some elements use characters to specify their size
        but will return pixels when calling this `get_size` method.

        :return: width and height of the element
        :rtype:  (int, int)
        """
        try:
            w = self.Widget.winfo_width()
            h = self.Widget.winfo_height()
        except:
            print('Warning, error getting size of element', self.Key)
            w = h = None
        return w, h

    def hide_row(self):
        """Hides the entire row an Element is located on

        Use this if you must have all space removed when you are hiding an element,
        including the row container
        """
        try:
            self.ParentRowFrame.pack_forget()
        except:
            print('Warning, error hiding element row for key =', self.Key)

    def unhide_row(self):
        """Unhides (makes visible) the row container that the Element is located on

        NOTE: it will re-appear at the bottom of the window / container, most likely.
        """
        try:
            self.ParentRowFrame.pack()
        except:
            print('Warning, error hiding element row for key =', self.Key)

    def expand(self, expand_x=False, expand_y=False, expand_row=True):
        """Causes the Element to expand to fill available space in the X and Y directions

        Can specify which or both directions.

        :param expand_x:   If True Element will expand in the Horizontal directions
        :type expand_x:    (bool)
        :param expand_y:   If True Element will expand in the Vertical directions
        :type expand_y:    (bool)
        :param expand_row: If True the row containing the element will also expand. Without this your element is "trapped" within the row
        :type expand_row:  (bool)
        """
        if expand_x and expand_y:
            fill = tk.BOTH
        elif expand_x:
            fill = tk.X
        elif expand_y:
            fill = tk.Y
        else:
            return

        if not self._widget_was_created():
            return
        self.Widget.pack(expand=True, fill=fill)
        self.ParentRowFrame.pack(expand=expand_row, fill=fill)
        if self.element_frame is not None:
            self.element_frame.pack(expand=True, fill=fill)

    def set_cursor(self, cursor=None, cursor_color=None):
        """Sets the cursor for the current Element

        `cursor` is used in 2 different ways in this call:
            - For the parameter `cursor` it's actually the mouse pointer.
            - If you do not want any mouse pointer, then use the string "none".

        For the parameter `cursor_color` it's the color of the I-beam used when typing into an input element.

        :param cursor:       The tkinter cursor name
        :type cursor:        (str)
        :param cursor_color: color to set the "cursor" to
        :type cursor_color:  (str)
        """
        if not self._widget_was_created():
            return
        if cursor is not None:
            try:
                self.Widget.config(cursor=cursor)
            except Exception as e:
                print('Warning bad cursor specified ', cursor)
                print(e)
        if cursor_color is not None:
            try:
                self.Widget.config(insertbackground=cursor_color)
            except Exception as e:
                print('Warning bad cursor color', cursor_color)
                print(e)

    def set_vscroll_position(self, percent_from_top):
        """Attempts to set the vertical scroll postition for an element's Widget

        :param percent_from_top: From 0 to 1.0, the percentage from the top to move scrollbar to
        :type percent_from_top:  (float)
        """
        if self.Type == ELEM_TYPE_COLUMN and self.Scrollable:
            widget = self.widget.canvas  # scrollable column is a special case
        else:
            widget = self.widget

        try:
            widget.yview_moveto(percent_from_top)
        except Exception as e:
            print('Warning setting the vertical scroll (yview_moveto failed)')
            print(e)

    def _widget_was_created(self):
        """Determines if a Widget was created for this element

        :return: True if a Widget has been created previously (Widget is not None)
        :rtype:  (bool)
        """
        if self.Widget is not None:
            return True
        else:
            if SUPPRESS_WIDGET_NOT_FINALIZED_WARNINGS:
                return False

            warnings.warn('You cannot Update element with key = {}' +
                'until the window.read() is called or finalize=True ' +
                'when creating window'.format(self.Key), UserWarning)
            if not SUPPRESS_ERROR_POPUPS:
                _error_popup_with_traceback('Unable to complete operation on element with key {}'.format(self.Key),
                                            'You cannot perform operations (such as calling update) on an Element until:',
                                            ' window.read() is called or finalize=True when Window created.',
                                            'Adding a "finalize=True" parameter to your Window creation will likely fix this.',
                                            _create_error_message(),
                                            )
            return False

    def _grab_anywhere_on_using_control_key(self):
        """Turns on 'Grab Anywhere' functionality AFTER a window has been created

        Don't try on a window that's not yet been Finalized or Read.
        """
        self.Widget.bind("<Control-Button-1>", self.ParentForm._StartMove)
        self.Widget.bind("<Control-ButtonRelease-1>", self.ParentForm._StopMove)
        self.Widget.bind("<Control-B1-Motion>", self.ParentForm._OnMotion)

    def _grab_anywhere_on(self):
        """Turns on 'Grab Anywhere' functionality AFTER a window has been created

        Don't try on a window that's not yet been Finalized or Read.
        """
        self.Widget.bind("<ButtonPress-1>", self.ParentForm._StartMove)
        self.Widget.bind("<ButtonRelease-1>", self.ParentForm._StopMove)
        self.Widget.bind("<B1-Motion>", self.ParentForm._OnMotion)

    def _grab_anywhere_off(self):
        """Turns off 'Grab Anywhere' functionality AFTER a window has been created

        Don't try on a window that's not yet been Finalized or Read.
        """
        self.Widget.unbind("<ButtonPress-1>")
        self.Widget.unbind("<ButtonRelease-1>")
        self.Widget.unbind("<B1-Motion>")

    def grab_anywhere_exclude(self):
        """Excludes this element from being used by the `grab_anywhere` feature

        Handy for elements like a Graph element when dragging is enabled.
        You want the `Graph` element to get the drag events instead of the window dragging.
        """
        self.ParentForm._grab_anywhere_ignore_these_list.append(self.Widget)

    def grab_anywhere_include(self):
        """Includes this element in the `grab_anywhere` feature

        This will allow you to make a `Multline` element drag a window for example.
        """
        self.ParentForm._grab_anywhere_include_these_list.append(self.Widget)

    def set_right_click_menu(self, menu=None):
        """Sets a right click menu for an element

        If a menu is already set for the element,
        it will call the tkinter destroy method to remove it.

        :param menu:                   A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type menu:                    List[List[ List[str] | str ]]
        """
        if menu == MENU_RIGHT_CLICK_DISABLED:
            return
        if menu is None:
            menu = self.ParentForm.RightClickMenu
            if menu is None:
                return
        if menu:
            # If previously had a menu destroy it
            if self.TKRightClickMenu:
                try:
                    self.TKRightClickMenu.destroy() # just in case there's a problem let's not crash
                except:
                    pass
            top_menu = tk.Menu(self.ParentForm.TKroot, tearoff=self.ParentForm.right_click_menu_tearoff, tearoffcommand=self._tearoff_menu_callback)

            if self.ParentForm.right_click_menu_background_color not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(bg=self.ParentForm.right_click_menu_background_color)
            if self.ParentForm.right_click_menu_text_color not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(fg=self.ParentForm.right_click_menu_text_color)
            if self.ParentForm.right_click_menu_disabled_text_color not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(disabledforeground=self.ParentForm.right_click_menu_disabled_text_color)
            if self.ParentForm.right_click_menu_font is not None:
                top_menu.config(font=self.ParentForm.right_click_menu_font)

            if self.ParentForm.right_click_menu_selected_colors[0] not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(activeforeground=self.ParentForm.right_click_menu_selected_colors[0])
            if self.ParentForm.right_click_menu_selected_colors[1] not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(activebackground=self.ParentForm.right_click_menu_selected_colors[1])
            AddMenuItem(top_menu, menu[1], self, right_click_menu=True)
            self.TKRightClickMenu = top_menu
            if self.ParentForm.RightClickMenu:            # if the top level has a right click menu, then setup a callback for the Window itself
                if self.ParentForm.TKRightClickMenu is None:
                    self.ParentForm.TKRightClickMenu = top_menu
                    if (running_mac()):
                        self.ParentForm.TKroot.bind('<ButtonRelease-2>', self.ParentForm._RightClickMenuCallback)
                    else:
                        self.ParentForm.TKroot.bind('<ButtonRelease-3>', self.ParentForm._RightClickMenuCallback)
            if (running_mac()):
                self.Widget.bind('<ButtonRelease-2>', self._RightClickMenuCallback)
            else:
                self.Widget.bind('<ButtonRelease-3>', self._RightClickMenuCallback)


    def save_element_screenshot_to_disk(self, filename=None):
        """Saves an image of the FreeSimpleGUI window provided
            into the filename provided

        :param filename:        Optional filename to save screenshot to. If not included, the User Settinds are used to get the filename
        :return:                A PIL ImageGrab object that can be saved or manipulated
        :rtype:                 (PIL.ImageGrab | None)
        """
        global pil_import_attempted, pil_imported, PIL, ImageGrab, Image

        if not pil_import_attempted:
            try:
                import PIL as PIL
                from PIL import ImageGrab
                from PIL import Image
                pil_imported = True
                pil_import_attempted = True
            except:
                pil_imported = False
                pil_import_attempted = True
                print('FAILED TO IMPORT PIL!')
                return None
        try:
            # Add a little to the X direction if window has a titlebar
            rect = (
                self.widget.winfo_rootx(),
                self.widget.winfo_rooty(),
                self.widget.winfo_rootx() + self.widget.winfo_width(),
                self.widget.winfo_rooty() + self.widget.winfo_height()
            )

            grab = ImageGrab.grab(bbox=rect)
        except Exception as e:
            popup_error_with_traceback('Screen capture failure', 'Error happened while trying to save screencapture of an element', e)
            return None

        if filename is None:
            folder = freesimplegui_user_settings.get('-screenshots folder-', '')
            filename = freesimplegui_user_settings.get('-screenshots filename-', '')
            full_filename = os.path.join(folder, filename)
        else:
            full_filename = filename
        if full_filename:
            try:
                grab.save(full_filename)
            except Exception as e:
                popup_error_with_traceback('Screen capture failure', 'Error happened while trying to save screencapture', e)
        else:
            popup_error_with_traceback('Screen capture failure', 'You have attempted a screen capture but have not set up a good filename to save to')
        return grab

    def _pack_forget_save_settings(self, alternate_widget=None):
        """Performs a pack_forget which will make a widget invisible

        This method saves the pack settings so that they can be restored if the element is made visible again.

        :param alternate_widget:   Widget to use that's different than the one defined in Element.Widget. These are usually Frame widgets
        :type alternate_widget:    (tk.Widget)
        """

        if alternate_widget is not None and self.Widget is None:
            return

        widget = alternate_widget if alternate_widget is not None else self.Widget
        # if the widget is already invisible (i.e. not packed) then will get an error
        try:
            pack_settings = widget.pack_info()
            self.pack_settings = pack_settings
            widget.pack_forget()
        except:
            pass

    def _pack_restore_settings(self, alternate_widget=None):
        """Restores a previously packaged widget which will make it visible again

        If no settings saved, then the widget is assumed to have not been unpacked and will not try to pack again.

        :param alternate_widget:   Widget to use that's different than the one defined in Element.Widget. These are usually Frame widgets
        :type alternate_widget:    (tk.Widget)
        """

        # if there are no saved pack settings, then assume it hasnb't been packaed before. The request will be ignored
        if self.pack_settings is None:
            return

        widget = alternate_widget if alternate_widget is not None else self.Widget
        if widget is not None:
            widget.pack(**self.pack_settings)

    def update(self, *args, **kwargs):
        """A dummy update call

        This will only be called if an element hasn't implemented an update method.

        It is provided here for docstring purposes.
        If you got here by browing code via PyCharm,
        know that this is not the function that will be called.
        Your actual element's update method will be called.

        If you call update, you must call `window.refresh` if you want
        the change to happen prior to your next `window.read` call.
        Normally you don't do this as the `window.read` call is likely
        going to happen next.
        """
        print('* Base Element Class update was called. Your element does not seem to have an update method')

    def __call__(self, *args, **kwargs):
        """Makes it possible to `call` an already existing element

        When you do make the `call`, it actually calls the Update method for the element.
        **Example**:    If this text element was in your layout:
                    sg.Text('foo', key='T')
                    #Then you can call the Update method for that element by writing:
                    window.find_element('T')('new text value')
        """
        return self.update(*args, **kwargs)

    SetTooltip = set_tooltip
    SetFocus = set_focus


# ---------------------------------------------------------------------- #
#                           Input Class                                  #
# ---------------------------------------------------------------------- #
class Input(Element):
    """Displays a single text input field

    Based on the tkinter Widget `Entry`
    """

    def __init__(self, default_text='', size=(None, None), s=(None, None), disabled=False, password_char='', setting=None,
                 justification=None, background_color=None, text_color=None, font=None, tooltip=None, border_width=None,
                 change_submits=False, enable_events=False, do_not_clear=True, key=None, k=None, focus=False, pad=None, p=None,
                 use_readonly_for_disable=True, readonly=False, disabled_readonly_background_color=None, disabled_readonly_text_color=None, selected_text_color=None,
                 selected_background_color=None, expand_x=False, expand_y=False,
                 right_click_menu=None, visible=True, metadata=None):
        """
        :param default_text:                       Text initially shown in the input box as a default value(Default value = ''). Will automatically be converted to string
        :type default_text:                        (Any)
        :param size:                               w=characters-wide, h=rows-high. If an int is supplied rather than a tuple, then a tuple is created width=int supplied and heigh=1
        :type size:                                (int, int) |  (int, None) | int
        :param s:                                  Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                                   (int, int)  | (None, None) | int
        :param disabled:                           set disable state for element (Default = False)
        :type disabled:                            (bool)
        :param password_char:                      Password character if this is a password field (Default value = '')
        :type password_char:                       (char)
        :param setting:                            If not None, then this element will be saved in a settings file using the key for the element
        :type setting:                             (Any)
        :param justification:                      justification for data display. Valid choices - left, right, center
        :type justification:                       (str)
        :param background_color:                   color of background in one of the color formats
        :type background_color:                    (str)
        :param text_color:                         color of the text
        :type text_color:                          (str)
        :param font:                               specifies the font family, size. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                                (str or (str, int[, str]) or None)
        :param tooltip:                            text, that will appear when mouse hovers over the element
        :type tooltip:                             (str)
        :param border_width:                       width of border around element in pixels
        :type border_width:                        (int)
        :param change_submits:                     * DEPRICATED DO NOT USE. Use `enable_events` instead
        :type change_submits:                      (bool)
        :param enable_events:                      If True then changes to this element are immediately reported as an event. Use this instead of change_submits (Default = False)
        :type enable_events:                       (bool)
        :param do_not_clear:                       If False then the field will be set to blank after ANY event (button, any event) (Default = True)
        :type do_not_clear:                        (bool)
        :param key:                                Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                                 str | int | tuple | object
        :param k:                                  Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                                   str | int | tuple | object
        :param focus:                              Determines if initial focus should go to this element.
        :type focus:                               (bool)
        :param pad:                                Amount of padding to put around element. Normally (horizontal pixels, vertical pixels) but can be split apart further into ((horizontal left, horizontal right), (vertical above, vertical below)). If int is given, then converted to tuple (int, int) with the value provided duplicated
        :type pad:                                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                                  Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                                   (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param use_readonly_for_disable:           If True (the default) tkinter state set to 'readonly'. Otherwise state set to 'disabled'
        :type use_readonly_for_disable:            (bool)
        :param readonly:                           If True tkinter state set to 'readonly'.  Use this in place of use_readonly_for_disable as another way of achieving readonly.  Note cannot set BOTH readonly and disabled as tkinter only supplies a single flag
        :type readonly:                            (bool)
        :param disabled_readonly_background_color: If state is set to readonly or disabled, the color to use for the background
        :type disabled_readonly_background_color:  (str)
        :param disabled_readonly_text_color:       If state is set to readonly or disabled, the color to use for the text
        :type disabled_readonly_text_color:        (str)
        :param selected_text_color:                Color of text when it is selected (using mouse or control+A, etc)
        :type selected_text_color:                 (str)
        :param selected_background_color:          Color of background when it is selected (using mouse or control+A, etc)
        :type selected_background_color:           (str)
        :param expand_x:                           If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                            (bool)
        :param expand_y:                           If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                            (bool)
        :param right_click_menu:                   A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:                    List[List[ List[str] | str ]]
        :param visible:                            set visibility state of the element (Default = True)
        :type visible:                             (bool)
        :param metadata:                           User metadata that can be set to ANYTHING
        :type metadata:                            (Any)
        """

        self.DefaultText = default_text if default_text is not None else ''
        self.PasswordCharacter = password_char
        bg = background_color if background_color is not None else DEFAULT_INPUT_ELEMENTS_COLOR
        fg = text_color if text_color is not None else DEFAULT_INPUT_TEXT_COLOR
        self.selected_text_color = selected_text_color
        self.selected_background_color = selected_background_color
        self.Focus = focus
        self.do_not_clear = do_not_clear
        self.Justification = justification
        self.Disabled = disabled
        self.ChangeSubmits = change_submits or enable_events
        self.RightClickMenu = right_click_menu
        self.UseReadonlyForDisable = use_readonly_for_disable
        self.disabled_readonly_background_color = disabled_readonly_background_color
        self.disabled_readonly_text_color = disabled_readonly_text_color
        self.ReadOnly = readonly
        self.BorderWidth = border_width if border_width is not None else DEFAULT_BORDER_WIDTH
        self.TKEntry = self.Widget = None  # type: tk.Entry
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y
        if setting is not None:
            self.setting = setting
            self.DefaultText = user_settings_get_entry(key, setting)

        super().__init__(ELEM_TYPE_INPUT_TEXT, size=sz, background_color=bg, text_color=fg, key=key, pad=pad,
                         font=font, tooltip=tooltip, visible=visible, metadata=metadata)

    def update(self, value=None, disabled=None, select=None, visible=None,
        text_color=None, background_color=None, font=None, move_cursor_to='end',
        password_char=None, paste=None, readonly=None):
        """Changes some of the settings for the Input Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE.
        If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location
        in your layout so that it returns there when made visible.

        :param value:            new text to display as default text in Input field
        :type value:             (str)
        :param disabled:         disable or enable state of the element (sets Entry `Widget` to read-only or normal)
        :type disabled:          (bool)
        :param select:           if True, then the text will be selected
        :type select:            (bool)
        :param visible:          change visibility of element
        :type visible:           (bool)
        :param text_color:       change color of text being typed
        :type text_color:        (str)
        :param background_color: change color of the background
        :type background_color:  (str)
        :param font:             specifies the font family, size. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param move_cursor_to:   Moves the cursor to a particular offset. Defaults to 'end'
        :type move_cursor_to:    int | str
        :param password_char:    Password character if this is a password field
        :type password_char:     str
        :param paste:            If True "Pastes" the value into the element rather than replacing the entire element. If anything is selected it is replaced. The text is inserted at the current cursor location.
        :type paste:             bool
        :param readonly:         if True make element readonly (user cannot change any choices). Enables the element if either choice are made.
        :type readonly:          (bool)
        """
        if not self._widget_was_created():  # if widget hasn't been created yet, then don't allow
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Input.update:\n- The window was closed')
            return

        if background_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.TKEntry.configure(background=background_color)
            self.BackgroundColor = background_color
        if text_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.TKEntry.configure(fg=text_color)
            self.TextColor = text_color

        if disabled is True:
            if self.UseReadonlyForDisable:
                self.TKEntry.configure(fg=self.disabled_readonly_text_color)
                self.TKEntry['state'] = 'readonly'
            else:
                self.TKEntry.configure(fg=self.TextColor)
                self.TKEntry['state'] = 'disabled'
            self.Disabled = True
        elif disabled is False:
            self.TKEntry['state'] = 'normal'
            self.TKEntry.configure(fg=self.TextColor)
            self.Disabled = False

        if readonly is True:
            self.TKEntry['state'] = 'readonly'
        elif readonly is False:
            self.TKEntry['state'] = 'normal'

        if value is not None:
            if paste is not True:
                try:
                    self.TKStringVar.set(value)
                except:
                    pass
            self.DefaultText = value
            if paste is True:
                try:
                    self.TKEntry.delete('sel.first', 'sel.last')
                except:
                    pass
                self.TKEntry.insert("insert", value)
            if move_cursor_to == 'end':
                self.TKEntry.icursor(tk.END)
            elif move_cursor_to is not None:
                self.TKEntry.icursor(move_cursor_to)
        if select:
            self.TKEntry.select_range(0, 'end')
        if visible is False:
            self._pack_forget_save_settings()
            # self.TKEntry.pack_forget()
        elif visible is True:
            self._pack_restore_settings()
            # self.TKEntry.pack(padx=self.pad_used[0], pady=self.pad_used[1])
            # self.TKEntry.pack(padx=self.pad_used[0], pady=self.pad_used[1], in_=self.ParentRowFrame)
        if visible is not None:
            self._visible = visible
        if password_char is not None:
            self.TKEntry.configure(show=password_char)
            self.PasswordCharacter = password_char
        if font is not None:
            self.TKEntry.configure(font=font)

    def set_ibeam_color(self, ibeam_color=None):
        """Sets the color of the I-beam that is used to "insert" characters.

         This is oftens called a "Cursor" by many users.
         To keep from being confused with tkinter's definition of cursor
         (the mouse pointer), the term ibeam is used in this case.

        :param ibeam_color: color to set the "I-beam" used to indicate where characters will be inserted
        :type ibeam_color:  (str)
        """

        if not self._widget_was_created():
            return
        if ibeam_color is not None:
            try:
                self.Widget.config(insertbackground=ibeam_color)
            except Exception as e:
                _error_popup_with_traceback('Error setting I-beam color in set_ibeam_color',
                           'The element has a key:', self.Key,
                            'The color passed in was:', ibeam_color)

    def get(self):
        """Reads and returns the current value of the input element

        Must call `Window.Read` or `Window.Finalize` prior.

        :return: current value of Input field or '' if error encountered
        :rtype:  (str)
        """
        try:
            text = self.TKStringVar.get()
        except:
            text = ''
        return text

    Get = get
    Update = update


# -------------------------  INPUT TEXT Element lazy functions  ------------------------- #
In = Input
InputText = Input
I = Input


# ---------------------------------------------------------------------- #
#                           Combo                                        #
# ---------------------------------------------------------------------- #
class Combo(Element):
    """ComboBox Element

    A combination of a single-line input and a drop-down menu.
    User can type in their own value or choose from list.
    """

    def __init__(self, values, default_value=None, size=(None, None), s=(None, None), auto_size_text=None, background_color=None, text_color=None, button_background_color=None,
                 button_arrow_color=None, bind_return_key=False, setting=None, change_submits=False, enable_events=False, enable_per_char_events=None, disabled=False, key=None, k=None, pad=None,
                 p=None, expand_x=False, expand_y=False, tooltip=None, readonly=False, font=None, visible=True, metadata=None):
        """
        :param values:                  values to choose. While displayed as text, the items returned are what the caller supplied, not text
        :type values:                   List[Any] or Tuple[Any]
        :param default_value:           Choice to be displayed as initial value. Must match one of values variable contents
        :type default_value:            (Any)
        :param size:                    width, height. Width = characters-wide, height = NOTE it's the number of entries to show in the list. If an Int is passed rather than a tuple, then height is auto-set to 1 and width is value of the int
        :type size:                     (int, int)  | (None, None) | int
        :param s:                       Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                        (int, int)  | (None, None) | int
        :param auto_size_text:          True if element should be the same size as the contents
        :type auto_size_text:           (bool)
        :param background_color:        color of background
        :type background_color:         (str)
        :param text_color:              color of the text
        :type text_color:               (str)
        :param button_background_color: The color of the background of the button on the combo box
        :type button_background_color:  (str)
        :param button_arrow_color:      The color of the arrow on the button on the combo box
        :type button_arrow_color:       (str)
        :param bind_return_key:         If True, then the return key will cause a the Combo to generate an event when return key is pressed
        :type bind_return_key:          (bool)
        :param setting:                 If not None, then this element will be saved in a settings file using the key for the element
        :type setting:                  (Any)
        :param change_submits:          DEPRICATED DO NOT USE. Use `enable_events` instead
        :type change_submits:           (bool)
        :param enable_events:           Turns on the element specific events. Combo event is when a choice is made
        :type enable_events:            (bool)
        :param enable_per_char_events:  Enables generation of events for every character that's input. This is like the Input element's events
        :type enable_per_char_events:   (bool)
        :param disabled:                set disable state for element
        :type disabled:                 (bool)
        :param key:                     Used with window.find_element and with return values to uniquely identify this element
        :type key:                      str | int | tuple | object
        :param k:                       Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                        str | int | tuple | object
        :param pad:                     Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                       Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                        (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param expand_x:                If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                 (bool)
        :param expand_y:                If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                 (bool)
        :param tooltip:                 text that will appear when mouse hovers over this element
        :type tooltip:                  (str)
        :param readonly:                make element readonly (user can't change). True means user cannot change
        :type readonly:                 (bool)
        :param font:                    specifies the font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                     (str or (str, int[, str]) or None)
        :param visible:                 set visibility state of the element
        :type visible:                  (bool)
        :param metadata:                User metadata that can be set to ANYTHING
        :type metadata:                 (Any)
        """

        self.Values = values
        self.DefaultValue = default_value
        self.ChangeSubmits = change_submits or enable_events
        self.Widget = self.TKCombo = None  # type: ttk.Combobox
        self.Disabled = disabled
        self.Readonly = readonly
        self.BindReturnKey = bind_return_key
        bg = background_color if background_color else DEFAULT_INPUT_ELEMENTS_COLOR
        fg = text_color if text_color is not None else DEFAULT_INPUT_TEXT_COLOR
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y
        if button_background_color is None:
            self.button_background_color = theme_button_color()[1]
        else:
            self.button_background_color = button_background_color
        if button_arrow_color is None:
            self.button_arrow_color = theme_button_color()[0]
        else:
            self.button_arrow_color = button_arrow_color
        self.enable_per_char_events = enable_per_char_events
        if setting is not None:
            self.setting = setting
            self.DefaultValue = user_settings_get_entry(key, setting)

        super().__init__(ELEM_TYPE_INPUT_COMBO, size=sz, auto_size_text=auto_size_text, background_color=bg,
                         text_color=fg, key=key, pad=pad, tooltip=tooltip, font=font or DEFAULT_FONT, visible=visible, metadata=metadata)

    def update(self, value=None, values=None, set_to_index=None, disabled=None,
        readonly=None, font=None, visible=None, size=(None, None), select=None,
        text_color=None, background_color=None):
        """Changes some of the settings for the Combo Element

        Must call `Window.Read` or `Window.Finalize` prior.
        NOTE: The state can be in 3 states only....
        `enabled, disabled, readonly` even though more combinations are available.
        The easy way to remember is that if you change the readonly parameter
        then you are enabling the element.

        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain
        stationary, use the "layout helper" function "pin" to ensure your element
        is "pinned" to that location in your layout so that it returns there
        when made visible.

        :param value:            change which value is current selected based on new list of previous list of choices
        :type value:             (Any)
        :param values:           change list of choices
        :type values:            List[Any]
        :param set_to_index:     change selection to a particular choice starting with index = 0
        :type set_to_index:      (int)
        :param disabled:         disable or enable state of the element
        :type disabled:          (bool)
        :param readonly:         if True make element readonly (user cannot change any choices). Enables the element if either choice are made.
        :type readonly:          (bool)
        :param font:             specifies the font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param visible:          control visibility of element
        :type visible:           (bool)
        :param size:             width, height. Width = characters-wide, height = NOTE it's the number of entries to show in the list
        :type size:              (int, int)
        :param select:           if True, then the text will be selected, if False then selection will be cleared
        :type select:            (bool)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text
        :type text_color:        (str)
        """
        if size != (None, None):
            if isinstance(size, int):
                size = (size, 1)
            if isinstance(size, tuple) and len(size) == 1:
                size = (size[0], 1)

        if not self._widget_was_created():  # if widget hasn't been created yet, then don't allow
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Combo.update:\n- The window was closed')
            return

        if values is not None:
            try:
                self.TKCombo['values'] = values
            except:
                pass
            self.Values = values
            if value is None:
                self.TKCombo.set('')
            if size == (None, None):
                max_line_len = max([len(str(l)) for l in self.Values]) if len(self.Values) else 0
                if self.AutoSizeText is False:
                    width = self.Size[0]
                else:
                    width = max_line_len + 1
                self.TKCombo.configure(width=width)
            else:
                self.TKCombo.configure(height=size[1])
                self.TKCombo.configure(width=size[0])
        if value is not None:
            if value not in self.Values:
                self.TKCombo.set(value)
            else:
                for index, v in enumerate(self.Values):
                    if v == value:
                        try:
                            self.TKCombo.current(index)
                        except:
                            pass
                        self.DefaultValue = value
                        break
        if set_to_index is not None:
            try:
                self.TKCombo.current(set_to_index)
                self.DefaultValue = self.Values[set_to_index]
            except:
                pass
        if readonly:
            self.Readonly = True
            self.TKCombo['state'] = 'readonly'
        elif readonly is False:
            self.Readonly = False
            self.TKCombo['state'] = 'enable'
        if disabled is True:
            self.TKCombo['state'] = 'disable'
        elif disabled is False and self.Readonly is True:
            self.TKCombo['state'] = 'readonly'
        elif disabled is False and self.Readonly is False:
            self.TKCombo['state'] = 'enable'
        self.Disabled = disabled if disabled is not None else self.Disabled

        combostyle = self.ttk_style
        style_name = self.ttk_style_name
        if text_color is not None:
            combostyle.configure(style_name, foreground=text_color)
            combostyle.configure(style_name, selectforeground=text_color)
            combostyle.configure(style_name, insertcolor=text_color)
            combostyle.map(style_name, fieldforeground=[('readonly', text_color)])
            self.TextColor = text_color
        if background_color is not None:
            combostyle.configure(style_name, selectbackground=background_color)
            combostyle.map(style_name, fieldbackground=[('readonly', background_color)])
            combostyle.configure(style_name, fieldbackground=background_color)
            self.BackgroundColor = background_color


        if self.Readonly is True:
            if text_color not in (None, COLOR_SYSTEM_DEFAULT):
                combostyle.configure(style_name, selectforeground=text_color)
            if background_color not in (None, COLOR_SYSTEM_DEFAULT):
                combostyle.configure(style_name, selectbackground=background_color)


        if font is not None:
            self.Font = font
            self.TKCombo.configure(font=font)
            self._dropdown_newfont = tkinter.font.Font(font=font)
            self.ParentRowFrame.option_add("*TCombobox*Listbox*Font", self._dropdown_newfont)


        # make tcl call to deal with colors for the drop-down formatting
        try:
            if self.BackgroundColor not in (None, COLOR_SYSTEM_DEFAULT) and \
                self.TextColor not in (None, COLOR_SYSTEM_DEFAULT):
                self.Widget.tk.eval(
            '[ttk::combobox::PopdownWindow {}].f.l configure -foreground {} -background {} -selectforeground {} -selectbackground {} -font {}'.format(self.Widget, self.TextColor, self.BackgroundColor, self.BackgroundColor, self.TextColor, self._dropdown_newfont))
        except Exception as e:
            pass    # going to let this one slide

        if visible is False:
            self._pack_forget_save_settings()
            # self.TKCombo.pack_forget()
        elif visible is True:
            self._pack_restore_settings()
            # self.TKCombo.pack(padx=self.pad_used[0], pady=self.pad_used[1])
        if visible is not None:
            self._visible = visible
        if select is True:
           self.TKCombo.select_range(0, tk.END)
        elif select is False:
           self.TKCombo.select_clear()

    def get(self):
        """Returns the current (at the moment) value of the Combo

        NOTE: **DO NOT USE THIS AS THE NORMAL WAY OF READING A COMBO!**
        You should be using values from your call to `window.read` instead.
        Know what you're doing if you use it.

        :return: Returns the value of what is currently chosen
        :rtype:  Any | None
        """
        try:
            if self.TKCombo.current() == -1:  # if the current value was not in the original list
                value = self.TKCombo.get()  # then get the value typed in by user
            else:
                value = self.Values[self.TKCombo.current()]  # get value from original list given index
        except:
            value = None  # only would happen if user closes window
        return value

    Get = get
    Update = update


# -------------------------  INPUT COMBO Element lazy functions  ------------------------- #
InputCombo = Combo
DropDown = InputCombo
Drop = InputCombo
DD = Combo


# ---------------------------------------------------------------------- #
#                           Option Menu                                  #
# ---------------------------------------------------------------------- #
class OptionMenu(Element):
    """Option Menu

    NOTE: `OptionMenu` is available ONLY on the tkinter port.

    It's is a widget that is unique to tkinter.
    However, it looks much like a ComboBox.
    Instead of an arrow to click to pull down the list of choices,
    another little graphic is shown on the widget to indicate where
    you click. After clicking to activate, it looks like a Combo Box
    that you scroll to select a choice.
    """

    def __init__(self, values, default_value=None, size=(None, None), s=(None, None), disabled=False, enable_events=False, auto_size_text=None, expand_x=False, expand_y=False,
                 background_color=None, text_color=None, key=None, k=None, pad=None, p=None, tooltip=None, visible=True, metadata=None):
        """
        :param values:           Values to be displayed
        :type values:            List[Any] or Tuple[Any]
        :param default_value:    the value to choose by default
        :type default_value:     (Any)
        :param size:             (width, height) size in characters (wide), height is ignored and present to be consistent with other elements
        :type size:              (int, int) (width, UNUSED)
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param disabled:         control enabled / disabled
        :type disabled:          (bool)
        :param enable_events:    Turns on the element specific events. OptionMenu event is when a choice is made
        :type enable_events:     (bool)
        :param auto_size_text:   True if size of Element should match the contents of the items
        :type auto_size_text:    (bool)
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param key:              Used with window.find_element and with return values to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:          text that will appear when mouse hovers over this element
        :type tooltip:           (str)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """

        self.Values = values
        self.DefaultValue = default_value
        self.Widget = self.TKOptionMenu = None  # type: tk.OptionMenu
        self.Disabled = disabled
        bg = background_color if background_color else DEFAULT_INPUT_ELEMENTS_COLOR
        fg = text_color if text_color is not None else DEFAULT_INPUT_TEXT_COLOR
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y
        self.ChangeSubmits = enable_events

        super().__init__(ELEM_TYPE_INPUT_OPTION_MENU, size=sz, auto_size_text=auto_size_text, background_color=bg,
                         text_color=fg, key=key, pad=pad, tooltip=tooltip, visible=visible, metadata=metadata)

    def update(self, value=None, values=None, disabled=None, visible=None, size=(None, None)):
        """Changes some of the settings for the OptionMenu Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE.
        If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that
        location in your layout so that it returns there when made visible.

        :param value:    the value to choose by default
        :type value:     (Any)
        :param values:   Values to be displayed
        :type values:    List[Any]
        :param disabled: disable or enable state of the element
        :type disabled:  (bool)
        :param visible:  control visibility of element
        :type visible:   (bool)
        :param size:     (width, height) size in characters (wide), height is ignored and present to be consistent with other elements
        :type size:      (int, int) (width, UNUSED)
        """
        if not self._widget_was_created():  # if widget hasn't been created yet, then don't allow
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in OptionMenu.update:\n- The window was closed')
            return

        if values is not None:
            self.Values = values
            self.TKOptionMenu['menu'].delete(0, 'end')

            # Insert list of new options (tk._setit hooks them up to var)
            # self.TKStringVar.set(self.Values[0])
            for new_value in self.Values:
                self.TKOptionMenu['menu'].add_command(label=new_value, command=tk._setit(self.TKStringVar, new_value))
            if value is None:
                self.TKStringVar.set('')

            if size == (None, None):
                max_line_len = max([len(str(l)) for l in self.Values]) if len(self.Values) else 0
                if self.AutoSizeText is False:
                    width = self.Size[0]
                else:
                    width = max_line_len + 1
                self.TKOptionMenu.configure(width=width)
            else:
                self.TKOptionMenu.configure(width=size[0])

        if value is not None:
            self.DefaultValue = value
            self.TKStringVar.set(value)

        if disabled is True:
            self.TKOptionMenu['state'] = 'disabled'
        elif disabled is False:
            self.TKOptionMenu['state'] = 'normal'
        self.Disabled = disabled if disabled is not None else self.Disabled
        if visible is False:
            self._pack_forget_save_settings()
            # self.TKOptionMenu.pack_forget()
        elif visible is True:
            self._pack_restore_settings()
            # self.TKOptionMenu.pack(padx=self.pad_used[0], pady=self.pad_used[1])
        if visible is not None:
            self._visible = visible

    Update = update


# -------------------------  OPTION MENU Element lazy functions  ------------------------- #
InputOptionMenu = OptionMenu


# ---------------------------------------------------------------------- #
#                           Listbox                                      #
# ---------------------------------------------------------------------- #
class Listbox(Element):
    """A List Box

    Provides a list of values for the user to choose one or more of from.
    Returns a list of selected rows when a `window.read` is executed.
    """
    def __init__(self, values, default_values=None, select_mode=None, change_submits=False, enable_events=False,
                 bind_return_key=False, size=(None, None), s=(None, None), disabled=False, justification=None, auto_size_text=None, font=None, no_scrollbar=False,
                 horizontal_scroll=False, setting=None,
                 background_color=None, text_color=None, highlight_background_color=None, highlight_text_color=None,
                 sbar_trough_color=None, sbar_background_color=None, sbar_arrow_color=None, sbar_width=None, sbar_arrow_width=None, sbar_frame_color=None, sbar_relief=None,
                 key=None, k=None, pad=None, p=None, tooltip=None, expand_x=False, expand_y=False, right_click_menu=None, visible=True, metadata=None):
        """
        :param values:                     list of values to display. Can be any type including mixed types as long as they have `__str__` method
        :type values:                      List[Any] or Tuple[Any]
        :param default_values:             which values should be initially selected
        :type default_values:              List[Any]
        :param select_mode:                Select modes are used to determine if only 1 item can be selected or multiple and how they can be selected.   Valid choices begin with "LISTBOX_SELECT_MODE_" and include: LISTBOX_SELECT_MODE_SINGLE LISTBOX_SELECT_MODE_MULTIPLE LISTBOX_SELECT_MODE_BROWSE LISTBOX_SELECT_MODE_EXTENDED
        :type select_mode:                 [enum]
        :param change_submits:             DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:              (bool)
        :param enable_events:              Turns on the element specific events. Listbox generates events when an item is clicked
        :type enable_events:               (bool)
        :param bind_return_key:            If True, then the return key will cause a the Listbox to generate an event when return key is pressed
        :type bind_return_key:             (bool)
        :param size:                       w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                        (int, int) |  (int, None) | int
        :param s:                          Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                           (int, int)  | (None, None) | int
        :param disabled:                   set disable state for element
        :type disabled:                    (bool)
        :param justification:              justification for items in listbox. Valid choices - left, right, center.  Default is left. NOTE: on some older versions of tkinter, not available
        :type justification:               (str)
        :param auto_size_text:             True if element should be the same size as the contents
        :type auto_size_text:              (bool)
        :param font:                       specifies the font family, size, etc.  Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                        (str or (str, int[, str]) or None)
        :param no_scrollbar:               Controls if a scrollbar should be shown.  If True, no scrollbar will be shown
        :type no_scrollbar:                (bool)
        :param horizontal_scroll:          Controls if a horizontal scrollbar should be shown.  If True a horizontal scrollbar will be shown in addition to vertical
        :type horizontal_scroll:           (bool)
        :param setting:                    If not None, then this element will be saved in a settings file using the key for the element
        :type setting:                     (Any)
        :param background_color:           color of background
        :type background_color:            (str)
        :param text_color:                 color of the text
        :type text_color:                  (str)
        :param highlight_background_color: color of the background when an item is selected. Defaults to normal text color (a reverse look)
        :type highlight_background_color:  (str)
        :param highlight_text_color:       color of the text when an item is selected. Defaults to the normal background color (a rerverse look)
        :type highlight_text_color:        (str)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        :param key:                        Used with window.find_element and with return values to uniquely identify this element
        :type key:                         str | int | tuple | object
        :param k:                          Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                           str | int | tuple | object
        :param pad:                        Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                         (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                          Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                           (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:                    text, that will appear when mouse hovers over the element
        :type tooltip:                     (str)
        :param expand_x:                   If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                    (bool)
        :param expand_y:                   If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                    (bool)
        :param right_click_menu:           A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:            List[List[ List[str] | str ]]
        :param visible:                    set visibility state of the element
        :type visible:                     (bool)
        :param metadata:                   User metadata that can be set to ANYTHING
        :type metadata:                    (Any)
        """

        if values is None:
            _error_popup_with_traceback('Error in your Listbox definition:\n- The values parameter cannot be None', 'Use an empty list if you want no values in your Listbox')

        self.Values = values
        self.DefaultValues = default_values
        self.TKListbox = None
        self.ChangeSubmits = change_submits or enable_events
        self.BindReturnKey = bind_return_key
        self.Disabled = disabled
        if select_mode == LISTBOX_SELECT_MODE_BROWSE:
            self.SelectMode = SELECT_MODE_BROWSE
        elif select_mode == LISTBOX_SELECT_MODE_EXTENDED:
            self.SelectMode = SELECT_MODE_EXTENDED
        elif select_mode == LISTBOX_SELECT_MODE_MULTIPLE:
            self.SelectMode = SELECT_MODE_MULTIPLE
        elif select_mode == LISTBOX_SELECT_MODE_SINGLE:
            self.SelectMode = SELECT_MODE_SINGLE
        else:
            self.SelectMode = DEFAULT_LISTBOX_SELECT_MODE
        bg = background_color if background_color is not None else theme_input_background_color()
        fg = text_color if text_color is not None else theme_input_text_color()
        self.HighlightBackgroundColor = highlight_background_color if highlight_background_color is not None else fg
        self.HighlightTextColor = highlight_text_color if highlight_text_color is not None else bg
        self.RightClickMenu = right_click_menu
        self.vsb = None  # type: tk.Scrollbar or None
        self.hsb = None  # type: tk.Scrollbar | None
        self.TKListbox = self.Widget = None  # type: tk.Listbox
        self.element_frame = None  # type: tk.Frame
        self.NoScrollbar = no_scrollbar
        self.HorizontalScroll = horizontal_scroll
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y
        self.justification = justification
        if setting is not None:
            self.setting = setting
            self.DefaultValues = user_settings_get_entry(key, setting)


        super().__init__(ELEM_TYPE_INPUT_LISTBOX, size=sz, auto_size_text=auto_size_text, font=font,
                         background_color=bg, text_color=fg, key=key, pad=pad, tooltip=tooltip, visible=visible, metadata=metadata,
                         sbar_trough_color=sbar_trough_color, sbar_background_color=sbar_background_color, sbar_arrow_color=sbar_arrow_color, sbar_width=sbar_width,
                         sbar_arrow_width=sbar_arrow_width, sbar_frame_color=sbar_frame_color, sbar_relief=sbar_relief)


    def update(self, values=None, disabled=None, set_to_index=None, scroll_to_index=None, select_mode=None, visible=None):
        """Changes some of the settings for the Listbox Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the "layout helper"
        function pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param values:          new list of choices to be shown to user
        :type values:           List[Any]
        :param disabled:        disable or enable state of the element
        :type disabled:         (bool)
        :param set_to_index:    highlights the item(s) indicated. If parm is an int one entry will be set. If is a list, then each entry in list is highlighted
        :type set_to_index:     int | list | tuple
        :param scroll_to_index: scroll the listbox so that this index is the first shown
        :type scroll_to_index:  (int)
        :param select_mode:     changes the select mode according to tkinter's listbox widget
        :type select_mode:      (str)
        :param visible:         control visibility of element
        :type visible:          (bool)
        """

        if not self._widget_was_created():  # if widget hasn't been created yet, then don't allow
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Listbox.update:\n- The window was closed')
            return

        if disabled is True:
            self.TKListbox.configure(state='disabled')
        elif disabled is False:
            self.TKListbox.configure(state='normal')
        self.Disabled = disabled if disabled is not None else self.Disabled

        if values is not None:
            self.TKListbox.delete(0, 'end')
            for item in list(values):
                self.TKListbox.insert(tk.END, item)
            # self.TKListbox.selection_set(0, 0)
            self.Values = list(values)
        if set_to_index is not None:
            self.TKListbox.selection_clear(0, len(self.Values))  # clear all listbox selections
            if type(set_to_index) in (tuple, list):
                for i in set_to_index:
                    try:
                        self.TKListbox.selection_set(i, i)
                    except:
                        warnings.warn('* Listbox Update selection_set failed with index {}*'.format(set_to_index))
            else:
                try:
                    self.TKListbox.selection_set(set_to_index, set_to_index)
                except:
                    warnings.warn('* Listbox Update selection_set failed with index {}*'.format(set_to_index))
        if visible is False:
            self._pack_forget_save_settings(self.element_frame)
        elif visible is True:
            self._pack_restore_settings(self.element_frame)
        if scroll_to_index is not None and len(self.Values):
            self.TKListbox.yview_moveto(scroll_to_index / len(self.Values))
        if select_mode is not None:
            try:
                self.TKListbox.config(selectmode=select_mode)
            except:
                print('Listbox.update error trying to change mode to: ', select_mode)
        if visible is not None:
            self._visible = visible

    def set_value(self, values):
        """Sets highlighted choices of the listbox

        :param values: new values to choose based on previously set values
        :type values:  List[Any] | Tuple[Any]

        """
        for index, item in enumerate(self.Values):
            try:
                if item in values:
                    self.TKListbox.selection_set(index)
                else:
                    self.TKListbox.selection_clear(index)
            except:
                pass
        self.DefaultValues = values

    def get_list_values(self):
        # type: (Listbox) -> List[Any]
        """
        Returns list of Values provided by the user in the user's format

        :return: List of values. Can be any / mixed types -> []
        :rtype:  List[Any]
        """
        return self.Values

    def get_indexes(self):
        """Returns the items currently selected as a list of indexes

        :return: A list of offsets into values that is currently selected
        :rtype:  List[int]
        """
        return self.TKListbox.curselection()

    def get(self):
        """Returns the list of items currently selected in this listbox

        It should be identical to the value you would receive when performing a `window.read` call.

        :return: The list of currently selected items. The actual items are returned, not the indexes
        :rtype:  List[Any]
        """
        try:
            items = self.TKListbox.curselection()
            value = [self.Values[int(item)] for item in items]
        except:
            value = []
        return value

    def select_index(self, index, highlight_text_color=None, highlight_background_color=None):
        """Selects an index while providing capability to setting
            the selected color for the index to specific text/background color

        :param index:                      specifies which item to change. index starts at 0 and goes to length of values list minus one
        :type  index:                      (int)
        :param highlight_text_color:       color of the text when this item is selected.
        :type  highlight_text_color:        (str)
        :param highlight_background_color: color of the background when this item is selected
        :type  highlight_background_color:  (str)
        """

        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Listbox.select_item - The window was closed')
            return

        if index >= len(self.Values):
            _error_popup_with_traceback('Index {} is out of range for Listbox.select_index. Max allowed index is {}.'.format(index, len(self.Values)-1))
            return

        self.TKListbox.selection_set(index, index)

        if highlight_text_color is not None:
            self.widget.itemconfig(index, selectforeground=highlight_text_color)
        if highlight_background_color is not None:
            self.widget.itemconfig(index, selectbackground=highlight_background_color)

    def set_index_color(self, index, text_color=None, background_color=None, highlight_text_color=None, highlight_background_color=None):
        """Sets the color of a specific item without selecting it

        :param index:                      specifies which item to change. index starts at 0 and goes to length of values list minus one
        :type  index:                      (int)
        :param text_color:                 color of the text for this item
        :type  text_color:                 (str)
        :param background_color:           color of the background for this item
        :type  background_color:           (str)
        :param highlight_text_color:       color of the text when this item is selected.
        :type  highlight_text_color:       (str)
        :param highlight_background_color: color of the background when this item is selected
        :type  highlight_background_color: (str)
        """

        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Listbox.set_item_color - The window was closed')
            return

        if index >= len(self.Values):
            _error_popup_with_traceback('Index {} is out of range for Listbox.set_index_color. Max allowed index is {}.'.format(index, len(self.Values)-1))
            return

        if text_color is not None:
            self.widget.itemconfig(index, fg=text_color)
        if background_color is not None:
            self.widget.itemconfig(index, bg=background_color)
        if highlight_text_color is not None:
            self.widget.itemconfig(index, selectforeground=highlight_text_color)
        if highlight_background_color is not None:
            self.widget.itemconfig(index, selectbackground=highlight_background_color)

    GetIndexes = get_indexes
    GetListValues = get_list_values
    SetValue = set_value
    Update = update


LBox = Listbox
LB = Listbox


# ---------------------------------------------------------------------- #
#                           Radio                                        #
# ---------------------------------------------------------------------- #
class Radio(Element):
    """Radio Button Element

    Used in a group of other Radio Elements to provide user
    with ability to select only one choice in a list of choices.
    """

    def __init__(self, text, group_id, default=False, disabled=False, size=(None, None), s=(None, None), auto_size_text=None, setting=None,
                 background_color=None, text_color=None, circle_color=None, font=None, key=None, k=None, pad=None, p=None, tooltip=None,
                 change_submits=False, enable_events=False, right_click_menu=None, expand_x=False, expand_y=False, visible=True, metadata=None):
        """
        :param text:             Text to display next to button
        :type text:              (str)
        :param group_id:         Groups together multiple Radio Buttons. Any type works
        :type group_id:          (Any)
        :param default:          Set to True for the one element of the group you want initially selected
        :type default:           (bool)
        :param disabled:         set disable state
        :type disabled:          (bool)
        :param size:             (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:              (int, int)  | (None, None) | int
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param auto_size_text:   if True will size the element to match the length of the text
        :type auto_size_text:    (bool)
        :param setting:          If not None, then this element will be saved in a settings file using the key for the element
        :type setting:           (Any)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param circle_color:     color of background of the circle that has the dot selection indicator in it
        :type circle_color:      (str)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param key:              Used with window.find_element and with return values to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param change_submits:   DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:    (bool)
        :param enable_events:    Turns on the element specific events. Radio Button events happen when an item is selected
        :type enable_events:     (bool)
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """

        self.InitialState = default
        self.Text = text
        self.Widget = self.TKRadio = None  # type: tk.Radiobutton
        self.GroupID = group_id
        self.Value = None
        self.Disabled = disabled
        self.TextColor = text_color if text_color else theme_text_color()
        self.RightClickMenu = right_click_menu

        if circle_color is None:
            # ---- compute color of circle background ---
            try:  # something in here will fail if a color is not specified in Hex
                text_hsl = _hex_to_hsl(self.TextColor)
                background_hsl = _hex_to_hsl(background_color if background_color else theme_background_color())
                l_delta = abs(text_hsl[2] - background_hsl[2]) / 10
                if text_hsl[2] > background_hsl[2]:  # if the text is "lighter" than the background then make background darker
                    bg_rbg = _hsl_to_rgb(background_hsl[0], background_hsl[1], background_hsl[2] - l_delta)
                else:
                    bg_rbg = _hsl_to_rgb(background_hsl[0], background_hsl[1], background_hsl[2] + l_delta)
                self.CircleBackgroundColor = rgb(*bg_rbg)
            except:
                self.CircleBackgroundColor = background_color if background_color else theme_background_color()
        else:
            self.CircleBackgroundColor = circle_color
        self.ChangeSubmits = change_submits or enable_events
        self.EncodedRadioValue = None
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y
        if setting is not None:
            self.setting = bool(setting)
            self.InitialState = user_settings_get_entry(key, self.setting)

        super().__init__(ELEM_TYPE_INPUT_RADIO, size=sz, auto_size_text=auto_size_text, font=font,
                         background_color=background_color, text_color=self.TextColor, key=key, pad=pad,
                         tooltip=tooltip, visible=visible, metadata=metadata)

    def update(self, value=None, text=None, background_color=None, text_color=None,
            circle_color=None, disabled=None, visible=None):
        """Changes some of the settings for the Radio Button Element

        Must call `Window.read` or `Window.finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param value:            if True change to selected and set others in group to unselected
        :type value:             (bool)
        :param text:             Text to display next to radio button
        :type text:              (str)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text. Note this also changes the color of the selection dot
        :type text_color:        (str)
        :param circle_color:     color of background of the circle that has the dot selection indicator in it
        :type circle_color:      (str)
        :param disabled:         disable or enable state of the element
        :type disabled:          (bool)
        :param visible:          control visibility of element
        :type visible:           (bool)
        """

        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Radio.update- The window was closed')
            return

        if value is not None:
            try:
                if value is True:
                    self.TKIntVar.set(self.EncodedRadioValue)
                elif value is False:
                    if self.TKIntVar.get() == self.EncodedRadioValue:
                        self.TKIntVar.set(0)
            except:
                print('Error updating Radio')
            self.InitialState = value
        if text is not None:
            self.Text = str(text)
            self.TKRadio.configure(text=self.Text)
        if background_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.TKRadio.configure(background=background_color)
            self.BackgroundColor = background_color
        if text_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.TKRadio.configure(fg=text_color)
            self.TextColor = text_color

        if circle_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.CircleBackgroundColor = circle_color
            self.TKRadio.configure(selectcolor=self.CircleBackgroundColor)  # The background of the radio button
        elif text_color or background_color:
            if self.TextColor not in (None, COLOR_SYSTEM_DEFAULT) and self.BackgroundColor not in (None, COLOR_SYSTEM_DEFAULT) and self.TextColor.startswith(
                    '#') and self.BackgroundColor.startswith('#'):
                # ---- compute color of circle background ---
                text_hsl = _hex_to_hsl(self.TextColor)
                background_hsl = _hex_to_hsl(self.BackgroundColor if self.BackgroundColor else theme_background_color())
                l_delta = abs(text_hsl[2] - background_hsl[2]) / 10
                if text_hsl[2] > background_hsl[2]:  # if the text is "lighter" than the background then make background darker
                    bg_rbg = _hsl_to_rgb(background_hsl[0], background_hsl[1], background_hsl[2] - l_delta)
                else:
                    bg_rbg = _hsl_to_rgb(background_hsl[0], background_hsl[1], background_hsl[2] + l_delta)
                self.CircleBackgroundColor = rgb(*bg_rbg)
                self.TKRadio.configure(selectcolor=self.CircleBackgroundColor)  # The background of the checkbox

        if disabled is True:
            self.TKRadio['state'] = 'disabled'
        elif disabled is False:
            self.TKRadio['state'] = 'normal'
        self.Disabled = disabled if disabled is not None else self.Disabled

        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()
        if visible is not None:
            self._visible = visible

    def reset_group(self):
        """Sets all Radio Buttons in the group to not selected"""
        self.TKIntVar.set(0)

    def get(self) -> bool:
        """A snapshot of the value of Radio Button

        :return: True if this radio button is selected
        :rtype:  (bool)
        """
        return self.TKIntVar.get() == self.EncodedRadioValue

    Get = get
    ResetGroup = reset_group
    Update = update


R = Radio
Rad = Radio


# ---------------------------------------------------------------------- #
#                           Checkbox                                     #
# ---------------------------------------------------------------------- #
class Checkbox(Element):
    """Checkbox Element

    Displays a checkbox and text next to it.
    """

    def __init__(self, text, default=False, size=(None, None), s=(None, None), auto_size_text=None, setting=None, font=None, background_color=None, text_color=None, checkbox_color=None, highlight_thickness=1, change_submits=False, enable_events=False, disabled=False, key=None, k=None, pad=None, p=None, tooltip=None, right_click_menu=None, expand_x=False, expand_y=False, visible=True, metadata=None):
        """
        :param text:                Text to display next to checkbox
        :type text:                 (str)
        :param default:             Set to True if you want this checkbox initially checked
        :type default:              (bool)
        :param size:                (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                 (int, int)  | (None, None) | int
        :param s:                   Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                    (int, int)  | (None, None) | int
        :param auto_size_text:      if True will size the element to match the length of the text
        :type auto_size_text:       (bool)
        :param setting:             If not None, then this element will be saved in a settings file using the key for the element
        :type setting:              (Any)
        :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                 (str or (str, int[, str]) or None)
        :param background_color:    color of background
        :type background_color:     (str)
        :param text_color:          color of the text
        :type text_color:           (str)
        :param checkbox_color:      color of background of the box that has the check mark in it. The checkmark is the same color as the text
        :type checkbox_color:       (str)
        :param highlight_thickness: thickness of border around checkbox when gets focus
        :type highlight_thickness:  (int)
        :param change_submits:      DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:       (bool)
        :param enable_events:       Turns on the element specific events. Checkbox events happen when an item changes
        :type enable_events:        (bool)
        :param disabled:            set disable state
        :type disabled:             (bool)
        :param key:                 Used with window.find_element and with return values to uniquely identify this element
        :type key:                  str | int | tuple | object
        :param k:                   Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                    str | int | tuple | object
        :param pad:                 Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                  (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                   Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:             text, that will appear when mouse hovers over the element
        :type tooltip:              (str)
        :param right_click_menu:    A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:     List[List[ List[str] | str ]]
        :param expand_x:            If True the element will automatically expand in the X direction to fill available space
        :type expand_x:             (bool)
        :param expand_y:            If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:             (bool)
        :param visible:             set visibility state of the element
        :type visible:              (bool)
        :param metadata:            User metadata that can be set to ANYTHING
        :type metadata:             (Any)
        """

        self.Text = text
        self.InitialState = bool(default)
        self.Value = None
        self.TKCheckbutton = self.Widget = None  # type: tk.Checkbutton
        self.Disabled = disabled
        self.TextColor = text_color if text_color else theme_text_color()
        self.RightClickMenu = right_click_menu
        self.highlight_thickness = highlight_thickness

        # ---- compute color of circle background ---
        if checkbox_color is None:
            try:  # something in here will fail if a color is not specified in Hex
                text_hsl = _hex_to_hsl(self.TextColor)
                background_hsl = _hex_to_hsl(background_color if background_color else theme_background_color())
                l_delta = abs(text_hsl[2] - background_hsl[2]) / 10
                if text_hsl[2] > background_hsl[2]:  # if the text is "lighter" than the background then make background darker
                    bg_rbg = _hsl_to_rgb(background_hsl[0], background_hsl[1], background_hsl[2] - l_delta)
                else:
                    bg_rbg = _hsl_to_rgb(background_hsl[0], background_hsl[1], background_hsl[2] + l_delta)
                self.CheckboxBackgroundColor = rgb(*bg_rbg)
            except:
                self.CheckboxBackgroundColor = background_color if background_color else theme_background_color()
        else:
            self.CheckboxBackgroundColor = checkbox_color
        self.ChangeSubmits = change_submits or enable_events
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y
        if setting is not None:
            self.setting = bool(setting)
            self.InitialState = user_settings_get_entry(key, self.setting)

        super().__init__(ELEM_TYPE_INPUT_CHECKBOX, size=sz, auto_size_text=auto_size_text, font=font,
                         background_color=background_color, text_color=self.TextColor, key=key, pad=pad,
                         tooltip=tooltip, visible=visible, metadata=metadata)

    def get(self):
        # type: (Checkbox) -> bool
        """
        Return the current state of this checkbox

        :return: Current state of checkbox
        :rtype:  (bool)
        """
        return self.TKIntVar.get() != 0

    def update(self, value=None, text=None, background_color=None, text_color=None, checkbox_color=None, disabled=None, visible=None):
        """Changes some of the settings for the Checkbox Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Note that changing visibility may cause element to change locations when made visible after invisible.

        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param value:            if True checks the checkbox, False clears it
        :type value:             (bool)
        :param text:             Text to display next to checkbox
        :type text:              (str)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text. Note this also changes the color of the checkmark
        :type text_color:        (str)
        :param disabled:         disable or enable element
        :type disabled:          (bool)
        :param visible:          control visibility of element
        :type visible:           (bool)
        """

        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Checkbox.update:\n - The window was closed')
            return

        if value is not None:
            value = bool(value)
            try:
                self.TKIntVar.set(value)
                self.InitialState = value
            except:
                print('Checkbox update failed')
        if disabled is True:
            self.TKCheckbutton.configure(state='disabled')
        elif disabled is False:
            self.TKCheckbutton.configure(state='normal')
        self.Disabled = disabled if disabled is not None else self.Disabled

        if text is not None:
            self.Text = str(text)
            self.TKCheckbutton.configure(text=self.Text)
        if background_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.TKCheckbutton.configure(background=background_color)
            self.BackgroundColor = background_color
        if text_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.TKCheckbutton.configure(fg=text_color)
            self.TextColor = text_color
        # Color the checkbox itself
        if checkbox_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.CheckboxBackgroundColor = checkbox_color
            self.TKCheckbutton.configure(selectcolor=self.CheckboxBackgroundColor)  # The background of the checkbox
        elif text_color or background_color:
            if self.CheckboxBackgroundColor is not None and self.TextColor is not None and self.BackgroundColor is not None and self.TextColor.startswith(
                    '#') and self.BackgroundColor.startswith('#'):
                # ---- compute color of checkbox background ---
                text_hsl = _hex_to_hsl(self.TextColor)
                background_hsl = _hex_to_hsl(self.BackgroundColor if self.BackgroundColor else theme_background_color())
                l_delta = abs(text_hsl[2] - background_hsl[2]) / 10
                if text_hsl[2] > background_hsl[2]:  # if the text is "lighter" than the background then make background darker
                    bg_rbg = _hsl_to_rgb(background_hsl[0], background_hsl[1], background_hsl[2] - l_delta)
                else:
                    bg_rbg = _hsl_to_rgb(background_hsl[0], background_hsl[1], background_hsl[2] + l_delta)
                self.CheckboxBackgroundColor = rgb(*bg_rbg)
                self.TKCheckbutton.configure(selectcolor=self.CheckboxBackgroundColor)  # The background of the checkbox

        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()

        if visible is not None:
            self._visible = visible

    Get = get
    Update = update


# -------------------------  CHECKBOX Element lazy functions  ------------------------- #
CB = Checkbox
CBox = Checkbox
Check = Checkbox


# ---------------------------------------------------------------------- #
#                           Spin                                         #
# ---------------------------------------------------------------------- #

class Spin(Element):
    """A spinner with up/down buttons and a single line of text

    Rotates current value from their list.
    """

    def __init__(self, values, initial_value=None, disabled=False,
        change_submits=False, enable_events=False, readonly=False, setting=None,
        size=(None, None), s=(None, None), auto_size_text=None,
        bind_return_key=None, font=None, background_color=None, text_color=None,
        key=None, k=None, pad=None, p=None, wrap=None, tooltip=None,
        right_click_menu=None, expand_x=False, expand_y=False, visible=True,
        metadata=None):
        """
        :param values:           List of valid values
        :type values:            Tuple[Any] or List[Any]
        :param initial_value:    Initial item to show in window. Choose from list of values supplied
        :type initial_value:     (Any)
        :param disabled:         set disable state
        :type disabled:          (bool)
        :param change_submits:   DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:    (bool)
        :param enable_events:    Turns on the element specific events. Spin events happen when an item changes
        :type enable_events:     (bool)
        :param readonly:         If True, then users cannot type in values. Only values from the values list are allowed.
        :type readonly:          (bool)
        :param setting:          If not None, then this element will be saved in a settings file using the key for the element
        :type setting:           (Any)
        :param size:             (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:              (int, int)  | (None, None) | int
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param auto_size_text:   if True will size the element to match the length of the text
        :type auto_size_text:    (bool)
        :param bind_return_key:  If True, then the return key will cause a the element to generate an event when return key is pressed
        :type bind_return_key:   (bool)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param key:              Used with window.find_element and with return values to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param wrap:             Determines if the values should "Wrap". Default is False. If True, when reaching last value, will continue back to the first value.
        :type wrap:              (bool)
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """

        self.Values = values
        self.DefaultValue = initial_value
        self.ChangeSubmits = change_submits or enable_events
        self.TKSpinBox = self.Widget = None  # type: tk.Spinbox
        self.Disabled = disabled
        self.Readonly = readonly
        self.RightClickMenu = right_click_menu
        self.BindReturnKey = bind_return_key
        self.wrap = wrap

        bg = background_color if background_color else DEFAULT_INPUT_ELEMENTS_COLOR
        fg = text_color if text_color is not None else DEFAULT_INPUT_TEXT_COLOR
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        if setting is not None:
            self.setting = setting
            self.DefaultValue = user_settings_get_entry(key, setting)

        super().__init__(ELEM_TYPE_INPUT_SPIN, size=sz, auto_size_text=auto_size_text, font=font, background_color=bg, text_color=fg,
                         key=key, pad=pad, tooltip=tooltip, visible=visible, metadata=metadata)
        return

    def update(self, value=None, values=None, disabled=None, readonly=None, visible=None):
        """Changes some of the settings for the Spin Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Note that the state can be in 3 states only:
        `enabled`, `disabled`, `readonly` even though more combinations are available.
        The easy way to remember is that if you change the `readonly` parameter
        then you are enabling the element.

        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param value:    set the current value from list of choices
        :type value:     (Any)
        :param values:   set available choices
        :type values:    List[Any]
        :param disabled: disable. Note disabled and readonly cannot be mixed. It must be one OR the other
        :type disabled:  (bool)
        :param readonly: make element readonly.  Note disabled and readonly cannot be mixed. It must be one OR the other
        :type readonly:  (bool)
        :param visible:  control visibility of element
        :type visible:   (bool)
        """

        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Spin.update:\n - The window was closed')
            return

        if values != None:
            old_value = self.TKStringVar.get()
            self.Values = values
            self.TKSpinBox.configure(values=values)
            self.TKStringVar.set(old_value)
        if value is not None:
            try:
                self.TKStringVar.set(value)
                self.DefaultValue = value
            except:
                pass

        if readonly is True:
            self.Readonly = True
            self.TKSpinBox['state'] = 'readonly'
        elif readonly is False:
            self.Readonly = False
            self.TKSpinBox['state'] = 'normal'
        if disabled is True:
            self.TKSpinBox['state'] = 'disable'
        elif disabled is False:
            if self.Readonly:
                self.TKSpinBox['state'] = 'readonly'
            else:
                self.TKSpinBox['state'] = 'normal'
        self.Disabled = disabled if disabled is not None else self.Disabled

        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()
        if visible is not None:
            self._visible = visible

    def _SpinChangedHandler(self, event):
        """Callback function

        Used internally only. Called by tkinter when Spinbox Widget changes.
        Results in `Window.Read` call returning.

        :param event: passed in from tkinter
        :type event:
        """
        # first, get the results table built
        if self.Key is not None:
            self.ParentForm.LastButtonClicked = self.Key
        else:
            self.ParentForm.LastButtonClicked = ''
        self.ParentForm.FormRemainedOpen = True
        _exit_mainloop(self.ParentForm)

    def set_ibeam_color(self, ibeam_color=None):
        """Sets the color of the I-beam that is used to "insert" characters.

        This is oftens called a "Cursor" by many users.
        To keep from being confused with tkinter's definition of cursor
        (the mouse pointer), the term I-beam is used in this case.

        :param ibeam_color: color to set the "I-beam" used to indicate where characters will be inserted
        :type ibeam_color:  (str)
        """

        if not self._widget_was_created():
            return
        if ibeam_color is not None:
            try:
                self.Widget.config(insertbackground=ibeam_color)
            except Exception as e:
                _error_popup_with_traceback('Error setting I-beam color in set_ibeam_color',
                           'The element has a key:', self.Key,
                            'The color passed in was:', ibeam_color)

    def get(self):
        """Returns the current value showing in spinbox

        This value will be the same as what was provided as list of choices.
        If list items are `int`s, then the item returned will be an `int` (not a `str`)

        :return: The currently visible entry
        :rtype:  (Any)
        """
        value = self.TKStringVar.get()
        for v in self.Values:
            if str(v) == value:
                value = v
                break
        return value

    Get = get
    Update = update


Sp = Spin  # type: Spin


# ---------------------------------------------------------------------- #
#                           Multiline                                    #
# ---------------------------------------------------------------------- #
class Multiline(Element):
    """Multiline Element

    Displays and/or read multiple lines of text.
    This is both an input and output element.
    """

    def __init__(self, default_text='', enter_submits=False, disabled=False, autoscroll=False, autoscroll_only_at_bottom=False, border_width=None,
                 size=(None, None), s=(None, None), setting=None, auto_size_text=None, background_color=None, text_color=None, selected_text_color=None, selected_background_color=None, horizontal_scroll=False, change_submits=False, enable_events=False, do_not_clear=True, key=None, k=None, write_only=False, auto_refresh=False, reroute_stdout=False, reroute_stderr=False, reroute_cprint=False, echo_stdout_stderr=False, focus=False, font=None, pad=None, p=None, tooltip=None, justification=None, no_scrollbar=False, wrap_lines=None, sbar_trough_color=None, sbar_background_color=None, sbar_arrow_color=None, sbar_width=None, sbar_arrow_width=None, sbar_frame_color=None, sbar_relief=None, expand_x=False, expand_y=False, rstrip=True, right_click_menu=None, visible=True, metadata=None):
        """
        :param default_text:                 Initial text to show
        :type default_text:                  (Any)
        :param enter_submits:                if True, the Window.read call will return is enter key is pressed in this element
        :type enter_submits:                 (bool)
        :param disabled:                     set disable state
        :type disabled:                      (bool)
        :param autoscroll:                   If True the contents of the element will automatically scroll as more data added to the end
        :type autoscroll:                    (bool)
        :param autoscroll_only_at_bottom:    If True the contents of the element will automatically scroll only if the scrollbar is at the bottom of the multiline
        :type autoscroll_only_at_bottom:     (bool)
        :param border_width:                 width of border around element in pixels
        :type border_width:                  (int)
        :param size:                         (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                          (int, int)  | (None, None) | int | (None, int)
        :param s:                            Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                             (int, int)  | (None, None) | int | (None, int)
        :param setting:                      If not None, then this element will be saved in a settings file using the key for the element
        :type setting:                       (Any)
        :param auto_size_text:               if True will size the element to match the length of the text
        :type auto_size_text:                (bool)
        :param background_color:             color of background
        :type background_color:              (str)
        :param text_color:                   color of the text
        :type text_color:                    (str)
        :param selected_text_color:          Color of text when it is selected (using mouse or control+A, etc)
        :type selected_text_color:           (str)
        :param selected_background_color:    Color of background when it is selected (using mouse or control+A, etc)
        :type selected_background_color:     (str)
        :param horizontal_scroll:            Controls if a horizontal scrollbar should be shown.  If True a horizontal scrollbar will be shown in addition to vertical
        :type horizontal_scroll:             (bool)
        :param change_submits:               DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:                (bool)
        :param enable_events:                If True then any key press that happens when the element has focus will generate an event.
        :type enable_events:                 (bool)
        :param do_not_clear:                 if False the element will be cleared any time the Window.read call returns
        :type do_not_clear:                  (bool)
        :param key:                          Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:                           str | int | tuple | object
        :param k:                            Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                             str | int | tuple | object
        :param write_only:                   If True then no entry will be added to the values dictionary when the window is read
        :type write_only:                    bool
        :param auto_refresh:                 If True then anytime the element is updated, the window will be refreshed so that the change is immediately displayed
        :type auto_refresh:                  (bool)
        :param reroute_stdout:               If True then all output to stdout will be output to this element
        :type reroute_stdout:                (bool)
        :param reroute_stderr:               If True then all output to stderr will be output to this element
        :type reroute_stderr:                (bool)
        :param reroute_cprint:               If True your cprint calls will output to this element. It's the same as you calling cprint_set_output_destination
        :type reroute_cprint:                (bool)
        :param echo_stdout_stderr:           If True then output to stdout and stderr will be output to this element AND also to the normal console location
        :type echo_stdout_stderr:            (bool)
        :param focus:                        if True initial focus will go to this element
        :type focus:                         (bool)
        :param font:                         specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                          (str or (str, int[, str]) or None)
        :param pad:                          Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                           (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                            Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                             (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param tooltip:                      text, that will appear when mouse hovers over the element
        :type tooltip:                       (str)
        :param justification:                text justification. left, right, center. Can use single characters l, r, c.
        :type justification:                 (str)
        :param no_scrollbar:                 If False then a vertical scrollbar will be shown (the default)
        :type no_scrollbar:                  (bool)
        :param wrap_lines:                   If True, the lines will be wrapped automatically. Other parms affect this setting, but this one will override them all. Default is it does nothing and uses previous settings for wrapping.
        :type wrap_lines:                    (bool)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        :param expand_x:                     If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                      (bool)
        :param expand_y:                     If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                      (bool)
        :param rstrip:                       If True the value returned in will have whitespace stripped from the right side
        :type rstrip:                        (bool)
        :param right_click_menu:             A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:              List[List[ List[str] | str ]]
        :param visible:                      set visibility state of the element
        :type visible:                       (bool)
        :param metadata:                     User metadata that can be set to ANYTHING
        :type metadata:                      (Any)
        """

        self.DefaultText = str(default_text)
        self.EnterSubmits = enter_submits
        bg = background_color if background_color else DEFAULT_INPUT_ELEMENTS_COLOR
        self.Focus = focus
        self.do_not_clear = do_not_clear
        fg = text_color if text_color is not None else DEFAULT_INPUT_TEXT_COLOR
        fg = text_color if text_color is not None else DEFAULT_INPUT_TEXT_COLOR
        self.selected_text_color = selected_text_color
        self.selected_background_color = selected_background_color
        self.Autoscroll = autoscroll
        self.Disabled = disabled
        self.ChangeSubmits = change_submits or enable_events
        self.RightClickMenu = right_click_menu
        self.BorderWidth = border_width if border_width is not None else DEFAULT_BORDER_WIDTH
        self.TagCounter = 0
        self.TKText = self.Widget = None  # type: tk.Text
        self.element_frame = None  # type: tk.Frame
        self.HorizontalScroll = horizontal_scroll
        self.tags = set()
        self.WriteOnly = write_only
        self.AutoRefresh = auto_refresh
        key = key if key is not None else k
        self.reroute_cprint = reroute_cprint
        self.echo_stdout_stderr = echo_stdout_stderr
        self.Justification = 'left' if justification is None else justification
        self.justification_tag = self.just_center_tag = self.just_left_tag = self.just_right_tag = None
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y
        self.rstrip = rstrip
        self.wrap_lines = wrap_lines
        self.reroute_stdout = reroute_stdout
        self.reroute_stderr = reroute_stderr
        self.no_scrollbar = no_scrollbar
        self.hscrollbar = None      # The horizontal scrollbar
        self.auto_scroll_only_at_bottom = autoscroll_only_at_bottom
        sz = size if size != (None, None) else s
        if setting is not None:
            self.setting = str(setting)
            self.DefaultText = user_settings_get_entry(key, self.setting)

        super().__init__(ELEM_TYPE_INPUT_MULTILINE, size=sz, auto_size_text=auto_size_text, background_color=bg,
                         text_color=fg, key=key, pad=pad, tooltip=tooltip, font=font or DEFAULT_FONT, visible=visible, metadata=metadata,
                         sbar_trough_color=sbar_trough_color, sbar_background_color=sbar_background_color, sbar_arrow_color=sbar_arrow_color, sbar_width=sbar_width, sbar_arrow_width=sbar_arrow_width, sbar_frame_color=sbar_frame_color, sbar_relief=sbar_relief)
        return

    def update(self, value=None, disabled=None, append=False, font=None, text_color=None, background_color=None, text_color_for_value=None,
               background_color_for_value=None, visible=None, autoscroll=None, justification=None, font_for_value=None):
        """Changes some of the settings for the Multiline Element

        Must call `Window.read` or set `finalize=True` when creating window.

        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param value:                      new text to display
        :type value:                       (Any)
        :param disabled:                   disable or enable state of the element
        :type disabled:                    (bool)
        :param append:                     if True then new value will be added onto the end of the current value. if False then contents will be replaced.
        :type append:                      (bool)
        :param font:                       specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike for the entire element
        :type font:                        (str or (str, int[, str]) or None)
        :param text_color:                 color of the text
        :type text_color:                  (str)
        :param background_color:           color of background
        :type background_color:            (str)
        :param text_color_for_value:       color of the new text being added (the value paramter)
        :type text_color_for_value:        (str)
        :param background_color_for_value: color of the new background of the text being added (the value paramter)
        :type background_color_for_value:  (str)
        :param visible:                    set visibility state of the element
        :type visible:                     (bool)
        :param autoscroll:                 if True then contents of element are scrolled down when new text is added to the end
        :type autoscroll:                  (bool)
        :param justification:              text justification. left, right, center. Can use single characters l, r, c. Sets only for this value, not entire element
        :type justification:               (str)
        :param font_for_value:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike for the value being updated
        :type font_for_value:              str | (str, int)
        """

        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            return

        if autoscroll is not None:
            self.Autoscroll = autoscroll
        current_scroll_position = self.TKText.yview()[1]

        if justification is not None:
            if justification.startswith('l'):
                just_tag = 'left'
            if justification.startswith('r'):
                just_tag = 'right'
            if justification.startswith('c'):
                just_tag = 'center'
        else:
            just_tag = self.justification_tag

        starting_point = self.Widget.index(tk.INSERT)
        tag = None
        if value is not None:
            value = str(value)
            if background_color_for_value is not None or text_color_for_value is not None or font_for_value is not None:
                try:
                    tag = 'Multiline(' + str(text_color_for_value) + ',' + str(background_color_for_value) + ',' + str(font_for_value) + ')'
                    if tag not in self.tags:
                        self.tags.add(tag)
                    if background_color_for_value is not None:
                        self.TKText.tag_configure(tag, background=background_color_for_value)
                    if text_color_for_value is not None:
                        self.TKText.tag_configure(tag, foreground=text_color_for_value)
                    if font_for_value is not None:
                        self.TKText.tag_configure(tag, font=font_for_value)
                except Exception as e:
                    print('* Multiline.update:\n- bad color likely specified:', e)
            if self.Disabled:
                self.TKText.configure(state='normal')
            try:
                if not append:
                    self.TKText.delete('1.0', tk.END)
                if tag is not None or just_tag is not None:
                    self.TKText.insert(tk.END, value, (just_tag, tag))
                else:
                    self.TKText.insert(tk.END, value)

                # self.TKText.tag_add(just_tag, starting_point, starting_point)

            except Exception as e:
                print("* Error setting multiline *", e)
            if self.Disabled:
                self.TKText.configure(state='disabled')
            self.DefaultText = value

        # if self.Autoscroll:
        #     self.TKText.see(tk.END)
        if self.Autoscroll:
            if not self.auto_scroll_only_at_bottom or (
                    self.auto_scroll_only_at_bottom and current_scroll_position == 1.0):
                self.TKText.see(tk.END)
        if disabled is True:
            self.TKText.configure(state='disabled')
        elif disabled is False:
            self.TKText.configure(state='normal')
        self.Disabled = disabled if disabled is not None else self.Disabled

        if background_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.TKText.configure(background=background_color)
        if text_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.TKText.configure(fg=text_color)
        if font is not None:
            self.TKText.configure(font=font)

        if visible is False:
            self._pack_forget_save_settings(alternate_widget=self.element_frame)
            # self.element_frame.pack_forget()
        elif visible is True:
            self._pack_restore_settings(alternate_widget=self.element_frame)
            # self.element_frame.pack(padx=self.pad_used[0], pady=self.pad_used[1])

        if self.AutoRefresh and self.ParentForm:
            try:  # in case the window was destroyed
                self.ParentForm.refresh()
            except:
                pass
        if visible is not None:
            self._visible = visible

    def get(self):
        """Returns current contents of the Multiline Element

        :return: current contents of the Multiline Element (used as an input type of Multiline
        :rtype:  (str)
        """
        value = str(self.TKText.get(1.0, tk.END))
        if self.rstrip:
            return value.rstrip()
        return value

    def print(self, *args, end=None, sep=None, text_color=None, background_color=None, justification=None, font=None, colors=None, t=None, b=None, c=None,
              autoscroll=True):
        """Prints like Python normally does it, except routes the result
            to a multiline element and adds text colors if specified

        colors - (str, str) | str.  A combined text/background color definition in a single parameter

        There are also "aliases" for text_color, background_color and colors (t, b, c)
        t - An alias for color of the text (makes for shorter calls)
        b - An alias for the background_color parameter
        c - (str, str) - "shorthand" way of specifying color. (foreground, backgrouned)
        c - str - can also be a string of the format "foreground on background"  ("white on red")

        With the aliases it's possible to write the same print but in more compact ways:
        cprint('This will print white text on red background', c=('white', 'red'))
        cprint('This will print white text on red background', c='white on red')
        cprint('This will print white text on red background', text_color='white', background_color='red')
        cprint('This will print white text on red background', t='white', b='red')

        :param args:             The arguments to print
        :type args:              (Any)
        :param end:              The end char to use just like print uses
        :type end:               (str)
        :param sep:              The separation character like print uses
        :type sep:               (str)
        :param text_color:       The color of the text
        :type text_color:        (str)
        :param background_color: The background color of the line
        :type background_color:  (str)
        :param justification:    text justification. left, right, center. Can use single characters l, r, c. Sets only for this value, not entire element
        :type justification:     (str)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike for the args being printed
        :type font:              (str or (str, int[, str]) or None)
        :param colors:           Either a tuple or a string that has both the text and background colors. Or just the text color
        :type colors:            (str) or (str, str)
        :param t:                Color of the text
        :type t:                 (str)
        :param b:                The background color of the line
        :type b:                 (str)
        :param c:                Either a tuple or a string that has both the text and background colors or just tex color (same as the color parm)
        :type c:                 (str) or (str, str)
        :param autoscroll:       If True the contents of the element will automatically scroll as more data added to the end
        :type autoscroll:        (bool)
        """

        kw_text_color = text_color or t
        kw_background_color = background_color or b
        dual_color = colors or c
        try:
            if isinstance(dual_color, tuple):
                kw_text_color = dual_color[0]
                kw_background_color = dual_color[1]
            elif isinstance(dual_color, str):
                if ' on ' in dual_color:  # if has "on" in the string, then have both text and background
                    kw_text_color = dual_color.split(' on ')[0]
                    kw_background_color = dual_color.split(' on ')[1]
                else:  # if no "on" then assume the color string is just the text color
                    kw_text_color = dual_color
        except Exception as e:
            print('* multiline print warning * you messed up with color formatting', e)

        _print_to_element(self, *args, end=end, sep=sep, text_color=kw_text_color, background_color=kw_background_color, justification=justification,
                          autoscroll=autoscroll, font=font)

    def reroute_stdout_to_here(self):
        """Sends stdout (prints) to this element"""
        # if nothing on the stack, then need to save the very first stdout
        if len(Window._rerouted_stdout_stack) == 0:
            Window._original_stdout = sys.stdout
        Window._rerouted_stdout_stack.insert(0, (self.ParentForm, self))
        sys.stdout = self

    def reroute_stderr_to_here(self):
        """Sends stderr to this element"""
        if len(Window._rerouted_stderr_stack) == 0:
            Window._original_stderr = sys.stderr
        Window._rerouted_stderr_stack.insert(0, (self.ParentForm, self))
        sys.stderr = self

    def restore_stdout(self):
        """Restores a previously re-reouted stdout back to
            the original destination
        """
        Window._restore_stdout()

    def restore_stderr(self):
        """Restores a previously re-reouted stderr back to
            the original destination
        """
        Window._restore_stderr()

    def write(self, txt):
        """Called by Python when stdout or stderr wants to write

        :param txt: text of output
        :type txt:  (str)
        """
        try:
            self.update(txt, append=True)
            # if need to echo, then send the same text to the destinatoin that isn't thesame as this one
            if self.echo_stdout_stderr:
                if sys.stdout != self:
                    sys.stdout.write(txt)
                elif sys.stderr != self:
                    sys.stderr.write(txt)
        except:
            pass

    def flush(self):
        """Flush parameter was passed into a print statement

        For now doing nothing.
        Not sure what action should be taken to ensure a flush happens regardless.
        """
        # try:
        #     self.previous_stdout.flush()
        # except:
        #     pass
        return

    def set_ibeam_color(self, ibeam_color=None):
        """Sets the color of the I-beam that is used to "insert" characters

        This is oftens called a "Cursor" by many users.
        To keep from being confused with tkinter's definition of cursor
        (the mouse pointer), the term I-beam is used in this case.

        :param ibeam_color: color to set the "I-beam" used to indicate where characters will be inserted
        :type ibeam_color:  (str)
        """

        if not self._widget_was_created():
            return
        if ibeam_color is not None:
            try:
                self.Widget.config(insertbackground=ibeam_color)
            except Exception:
                _error_popup_with_traceback('Error setting I-beam color in set_ibeam_color',
                           'The element has a key:', self.Key,
                            'The color passed in was:', ibeam_color)


    def highlight_words(self, words:list|dict|str, colors:str='#ff6347') -> int:
        """Highlights words from the words list

        :param words: list of words, word or dictionary `{word: color}`
        :type words:  (list|dict|str)
        :param colors: color string (currently only str)
        :type colors:  (list|str)
        :return: current highlighted words count
        :rtype:  (int)
        """

        if not words:
            return 0
        if colors is None :
            colors = '#ff6347'

        counter = 0
        # a single tag / color for everything now
        color_tag = colors.strip('#').upper()
        self.Widget.tag_delete(f"HIGHLIGHT_{color_tag}")
        # Set the background color of the selected text
        self.Widget.tag_config(f"HIGHLIGHT_{color_tag}", background=colors)
        for word in words:
            start_index = '1.0'
            while True:
                # Find the word in the text widget
                start_index = self.Widget.search(word, start_index, stopindex=tk.END)
                if not start_index:
                    break
                counter += 1
                end_index = f"{start_index}+{len(word)}c"  # Calculate the end index
                self.Widget.tag_add(f"HIGHLIGHT_{color_tag}", start_index, end_index)  # Add a tag to the word
                start_index = end_index  # Move to the next occurrence
        return counter

    def __del__(self):
        """AT ONE TIME
        ---
        If this Widget is deleted, be sure and restore the old stdout, stderr
        Now the restore is done differently. Do not want to RELY on Python
        to call this method in order for stdout and stderr to be restored.
        Instead explicit restores are called.
        """
        return

    Get = get
    Update = update


ML = Multiline
MLine = Multiline


# ---------------------------------------------------------------------- #
#                                       Text                             #
# ---------------------------------------------------------------------- #
class Text(Element):
    """Display some text in the window

    Usually this means a single line of text.
    However, the text can also be multiple lines.
    If multi-lined there are no scroll bars.
    """

    def __init__(self, text='', size=(None, None), s=(None, None), auto_size_text=None, click_submits=False, enable_events=False, relief=None, font=None,
                 text_color=None, background_color=None, colors=(None,None), border_width=None, justification=None, pad=None, p=None, key=None, k=None, right_click_menu=None, expand_x=False,
                 expand_y=False, grab=None, tooltip=None, visible=True, metadata=None):
        """
        :param text:             The text to display. Can include /n to achieve multiple lines.  Will convert (optional) parameter into a string
        :type text:              Any
        :param size:             (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:              (int, int) |  (int, None) | (None, None) | (int, ) | int
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int) |  (int, None) | (None, None) | (int, ) | int
        :param auto_size_text:   if True size of the Text Element will be sized to fit the string provided in 'text' parm
        :type auto_size_text:    (bool)
        :param click_submits:    DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type click_submits:     (bool)
        :param enable_events:    Turns on the element specific events. Text events happen when the text is clicked
        :type enable_events:     (bool)
        :param relief:           relief style around the text. Values are same as progress meter relief values. Should be a constant that is defined at starting with RELIEF - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type relief:            (str)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param background_color: color of background
        :type background_color:  (str)
        :param colors:           Optional quick specification of both text and background colors in 1 parameter. If a single color specified, then assumed to be text_color
        :type colors:            (str) or (str, str)
        :param border_width:     number of pixels for the border (if using a relief)
        :type border_width:      (int)
        :param justification:    how string should be aligned within space provided by size. Valid choices = `left`, `right`, `center`
        :type justification:     (str)
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:              Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:               str or int or tuple or object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param grab:             If True can grab this element and move the window around. Default is False
        :type grab:              (bool)
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """

        self.DisplayText = str(text)
        tc = text_color if text_color else DEFAULT_TEXT_COLOR
        self.Justification = justification
        self.Relief = relief
        self.ClickSubmits = click_submits or enable_events
        if background_color is None:
            bg = DEFAULT_TEXT_ELEMENT_BACKGROUND_COLOR
        else:
            bg = background_color

        if colors != (None, None):
            dual_colors = _simplified_dual_color_to_tuple(colors)
            if dual_colors[0] is None and dual_colors[1] is not None: # if first entry is None, then use second as text color
                tc = dual_colors[1]
            else:
                tc = dual_colors[0]
                bg = dual_colors[1]
        self.TextColor = tc
        self.RightClickMenu = right_click_menu
        self.TKRightClickMenu = None
        self.BorderWidth = border_width
        self.Grab = grab
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        super().__init__(ELEM_TYPE_TEXT, auto_size_text=auto_size_text, size=sz, background_color=bg, font=font if font else DEFAULT_FONT,
                         text_color=self.TextColor, pad=pad, key=key, tooltip=tooltip, visible=visible, metadata=metadata)

    def update(self, value=None, background_color=None, text_color=None, font=None, visible=None):
        """Changes some of the settings for the Text Element

        Must call `Window.Read` or `Window.Finalize` prior.

        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param value:            new text to show
        :type value:             (Any)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        """

        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Text.update:\n - The window was closed')
            return

        if value is not None:
            self.DisplayText = str(value)
            self.TKStringVar.set(str(value))
        if background_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.TKText.configure(background=background_color)
        if text_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.TKText.configure(fg=text_color)
        if font is not None:
            self.TKText.configure(font=font)
        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()
        if visible is not None:
            self._visible = visible

    def get(self) -> str:
        """Gets the current value of the displayed text

        :return: The current value
        :rtype:  (str)
        """
        try:
            text = self.TKStringVar.get()
        except:
            text = ''
        return text

    @classmethod
    def fonts_installed_list(cls) -> List[str]:
        """Returns a list of strings that tkinter reports as the installed fonts

        :return:          List of the installed font names
        :rtype:           List[str]
        """
        # A window must exist before can perform this operation. Create the hidden master root if it doesn't exist
        _get_hidden_master_root()

        fonts = list(tkinter.font.families())
        fonts.sort()

        return fonts

    @classmethod
    def char_width_in_pixels(cls, font, character='W'):
        """Get the with of the character 'W' in pixels for the font being passed in or
        the character of your choosing if 'W' is not a good representative character

        Cannot be used until a window has been created.
        If an error occurs, 0 will be returned.

        :param font:      specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike, to be measured
        :type font:       (str or (str, int[, str]) or None)
        :param character: specifies a SINGLE CHARACTER character to measure
        :type character:  (str)
        :return:          Width in pixels of "A"
        :rtype:           (int)
        """
        # A window must exist before can perform this operation. Create the hidden master root if it doesn't exist
        _get_hidden_master_root()

        size = 0
        try:
            size = tkinter.font.Font(font=font).measure(character)  # single character width
        except Exception as e:
            _error_popup_with_traceback('Exception retrieving char width in pixels', e)

        return size

    @classmethod
    def char_height_in_pixels(cls, font):
        """Get the height of a string if using the supplied font in pixels

        Cannot be used until a window has been created.

        If an error occurs, 0 will be returned
        :param font: specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike, to be measured
        :type font:  (str or (str, int[, str]) or None)
        :return:     Height in pixels of "A"
        :rtype:      (int)
        """

        # A window must exist before can perform this operation. Create the hidden master root if it doesn't exist
        _get_hidden_master_root()

        size = 0
        try:
            size = tkinter.font.Font(font=font).metrics('linespace')
        except Exception as e:
            _error_popup_with_traceback('Exception retrieving char height in pixels', e)

        return size

    @classmethod
    def string_width_in_pixels(cls, font, string):
        """Gets the with of the supplied string in pixels for the font being passed in

        If an error occurs, 0 will be returned.

        :param font:   specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike, to be measured
        :type font:    (str or (str, int[, str]) or None)
        :param string: the string to measure
        :type string:  str
        :return:       Width in pixels of string
        :rtype:        (int)
        """

        # A window must exist before can perform this operation. Create the hidden master root if it doesn't exist
        _get_hidden_master_root()

        size = 0
        try:
            size = tkinter.font.Font(font=font).measure(string)  # string's  width
        except Exception as e:
            _error_popup_with_traceback('Exception retrieving string width in pixels', e)

        return size

    def _print_to_element(self, *args, end=None, sep=None, text_color=None, background_color=None, autoscroll=None, justification=None, font=None, append=None):
        """Prints like Python normally does except routes the result
            to a `MultiLine` element and  adds colors if specified

        :param multiline_element: The multiline element to be output to
        :type multiline_element:  (Multiline)
        :param args:              The arguments to print
        :type args:               List[Any]
        :param end:               The end char to use just like print uses
        :type end:                (str)
        :param sep:               The separation character like print uses
        :type sep:                (str)
        :param text_color:        color of the text
        :type text_color:         (str)
        :param background_color:  The background color of the line
        :type background_color:   (str)
        :param autoscroll:        If True (the default), the element will scroll to bottom after updating
        :type autoscroll:         (bool)
        :param font:              specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike for the value being updated
        :type font:               str | (str, int)
        """
        end_str = str(end) if end is not None else '\n'
        sep_str = str(sep) if sep is not None else ' '

        outstring = ''
        num_args = len(args)
        for i, arg in enumerate(args):
            outstring += str(arg)
            if i != num_args - 1:
                outstring += sep_str
        outstring += end_str
        if append:
            outstring = self.get() + outstring

        self.update(outstring, text_color=text_color, background_color=background_color, font=font)

        try:  # if the element is set to autorefresh, then refresh the parent window
            if self.AutoRefresh:
                self.ParentForm.refresh()
        except:
            pass

    def print(self, *args, end=None, sep=None, text_color=None,
        background_color=None, justification=None, font=None, colors=None,
        t=None, b=None, c=None, autoscroll=True, append=True):
        """Prints like Python normally does except routes the result
            to a `MultiLine` element and  adds colors if specified

        colors -(str, str) or str.  A combined text/background color definition in a single parameter

        There are also "aliases" for text_color, background_color and colors (t, b, c)
        t - An alias for color of the text (makes for shorter calls)
        b - An alias for the background_color parameter
        c - (str, str) - "shorthand" way of specifying color. (foreground, backgrouned)
        c - str - can also be a string of the format "foreground on background"  ("white on red")

        With the aliases it's possible to write the same print but in more compact ways:
        cprint('This will print white text on red background', c=('white', 'red'))
        cprint('This will print white text on red background', c='white on red')
        cprint('This will print white text on red background', text_color='white', background_color='red')
        cprint('This will print white text on red background', t='white', b='red')

        :param args:             The arguments to print
        :type args:              (Any)
        :param end:              The end char to use just like print uses
        :type end:               (str)
        :param sep:              The separation character like print uses
        :type sep:               (str)
        :param text_color:       The color of the text
        :type text_color:        (str)
        :param background_color: The background color of the line
        :type background_color:  (str)
        :param justification:    text justification. left, right, center. Can use single characters l, r, c. Sets only for this value, not entire element
        :type justification:     (str)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike for the args being printed
        :type font:              (str or (str, int[, str]) or None)
        :param colors:           Either a tuple or a string that has both the text and background colors. Or just the text color
        :type colors:            (str) or (str, str)
        :param t:                Color of the text
        :type t:                 (str)
        :param b:                The background color of the line
        :type b:                 (str)
        :param c:                Either a tuple or a string that has both the text and background colors or just tex color (same as the color parm)
        :type c:                 (str) or (str, str)
        :param autoscroll:       If True the contents of the element will automatically scroll as more data added to the end
        :type autoscroll:        (bool)
        """

        kw_text_color = text_color or t
        kw_background_color = background_color or b
        dual_color = colors or c
        try:
            if isinstance(dual_color, tuple):
                kw_text_color = dual_color[0]
                kw_background_color = dual_color[1]
            elif isinstance(dual_color, str):
                if ' on ' in dual_color:  # if has "on" in the string, then have both text and background
                    kw_text_color = dual_color.split(' on ')[0]
                    kw_background_color = dual_color.split(' on ')[1]
                else:  # if no "on" then assume the color string is just the text color
                    kw_text_color = dual_color
        except Exception as e:
            print('* multiline print warning * you messed up with color formatting', e)

        self._print_to_element(
            *args, end=end, sep=sep, text_color=kw_text_color,
            background_color=kw_background_color, justification=justification,
            autoscroll=autoscroll, font=font, append=append
        )

    Get = get
    Update = update


# -------------------------  Text Element lazy functions  ------------------------- #

Txt = Text  # type: Text
T = Text  # type: Text


# ---------------------------------------------------------------------- #
#                                       StatusBar                        #
# ---------------------------------------------------------------------- #
class StatusBar(Element):
    """A StatusBar Element

    Creates the sunken text-filled strip at the window bottom.
    Many Windows programs have this line.
    """

    def __init__(self, text, size=(None, None), s=(None, None), auto_size_text=None, click_submits=None, enable_events=False,
                 relief=RELIEF_SUNKEN, font=None, text_color=None, background_color=None, justification=None, pad=None, p=None,
                 key=None, k=None, right_click_menu=None, expand_x=False, expand_y=False, tooltip=None, visible=True, metadata=None):
        """
        :param text:             Text that is to be displayed in the widget
        :type text:              (str)
        :param size:             (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:              (int, int) |  (int, None) | int
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param auto_size_text:   True if size should fit the text length
        :type auto_size_text:    (bool)
        :param click_submits:    DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type click_submits:     (bool)
        :param enable_events:    Turns on the element specific events. StatusBar events occur when the bar is clicked
        :type enable_events:     (bool)
        :param relief:           relief style. Values are same as progress meter relief values.  Can be a constant or a string: `RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID`
        :type relief:            (enum)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param background_color: color of background
        :type background_color:  (str)
        :param justification:    how string should be aligned within space provided by size. Valid choices = `left`, `right`, `center`
        :type justification:     (str)
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:              Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """

        self.DisplayText = text
        self.TextColor = text_color if text_color else DEFAULT_TEXT_COLOR
        self.Justification = justification
        self.Relief = relief
        self.ClickSubmits = click_submits or enable_events
        if background_color is None:
            bg = DEFAULT_TEXT_ELEMENT_BACKGROUND_COLOR
        else:
            bg = background_color
        self.TKText = self.Widget = None  # type: tk.Label
        key = key if key is not None else k
        self.RightClickMenu = right_click_menu
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        super().__init__(ELEM_TYPE_STATUSBAR, size=sz, auto_size_text=auto_size_text, background_color=bg,
                         font=font or DEFAULT_FONT, text_color=self.TextColor, pad=pad, key=key, tooltip=tooltip,
                         visible=visible, metadata=metadata)
        return

    def update(self, value=None, background_color=None, text_color=None, font=None, visible=None):
        """Changes some of the settings for the Status Bar Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param value:            new text to show
        :type value:             (str)
        :param background_color: color of background
        :type background_color:  (str)
        :param text_color:       color of the text
        :type text_color:        (str)
        :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:              (str or (str, int[, str]) or None)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        """

        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in StatusBar.update:\n - The window was closed')
            return

        if value is not None:
            self.DisplayText = value
            stringvar = self.TKStringVar
            stringvar.set(value)
        if background_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.TKText.configure(background=background_color)
        if text_color not in (None, COLOR_SYSTEM_DEFAULT):
            self.TKText.configure(fg=text_color)
        if font is not None:
            self.TKText.configure(font=font)
        if visible is False:
            self._pack_forget_save_settings()
            # self.TKText.pack_forget()
        elif visible is True:
            self._pack_restore_settings()
            # self.TKText.pack(padx=self.pad_used[0], pady=self.pad_used[1])
        if visible is not None:
            self._visible = visible

    Update = update


SBar = StatusBar


# ---------------------------------------------------------------------- #
#                       TKProgressBar                                    #
#  Emulate the TK ProgressBar using canvas and rectangles
# ---------------------------------------------------------------------- #

class TKProgressBar():
    uniqueness_counter = 0

    def __init__(self, root, max, length=400, width=DEFAULT_PROGRESS_BAR_SIZE[1], ttk_theme=DEFAULT_TTK_THEME, style_name='',
                 relief=DEFAULT_PROGRESS_BAR_RELIEF, border_width=DEFAULT_PROGRESS_BAR_BORDER_WIDTH,
                 orientation='horizontal', BarColor=(None, None), key=None):
        """
        :param root:         The root window bar is to be shown in
        :type root:          tk.Tk | tk.TopLevel
        :param max:          Maximum value the bar will be measuring
        :type max:           (int)
        :param length:       length in pixels of the bar
        :type length:        (int)
        :param width:        width in pixels of the bar
        :type width:         (int)
        :param style_name:   Progress bar style to use.  Set in the packer function
        :type style_name:    (str)
        :param ttk_theme:    Progress bar style defined as one of these 'default', 'winnative', 'clam', 'alt', 'classic', 'vista', 'xpnative'
        :type ttk_theme:     (str)
        :param relief:       relief style. Values are same as progress meter relief values.  Can be a constant or a string: `RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID` (Default value = DEFAULT_PROGRESS_BAR_RELIEF)
        :type relief:        (str)
        :param border_width: The amount of pixels that go around the outside of the bar
        :type border_width:  (int)
        :param orientation:  'horizontal' or 'vertical' ('h' or 'v' work) (Default value = 'vertical')
        :type orientation:   (str)
        :param BarColor:     The 2 colors that make up a progress bar. One is the background, the other is the bar
        :type BarColor:      (str, str)
        :param key:          Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:           str | int | tuple | object
        """

        self.Length = length
        self.Width = width
        self.Max = max
        self.Orientation = orientation
        self.Count = None
        self.PriorCount = 0
        self.style_name = style_name

        TKProgressBar.uniqueness_counter += 1

        if orientation.lower().startswith('h'):
            s = ttk.Style()
            _change_ttk_theme(s, ttk_theme)

            # self.style_name = str(key) + str(TKProgressBar.uniqueness_counter) + "my.Horizontal.TProgressbar"
            if BarColor != COLOR_SYSTEM_DEFAULT and BarColor[0] != COLOR_SYSTEM_DEFAULT:
                s.configure(self.style_name, background=BarColor[0], troughcolor=BarColor[1],
                            troughrelief=relief, borderwidth=border_width, thickness=width)
            else:
                s.configure(self.style_name, troughrelief=relief, borderwidth=border_width, thickness=width)

            self.TKProgressBarForReal = ttk.Progressbar(root, maximum=self.Max, style=self.style_name, length=length, orient=tk.HORIZONTAL, mode='determinate')
        else:
            s = ttk.Style()
            _change_ttk_theme(s, ttk_theme)
            # self.style_name = str(key) + str(TKProgressBar.uniqueness_counter) + "my.Vertical.TProgressbar"
            if BarColor != COLOR_SYSTEM_DEFAULT and BarColor[0] != COLOR_SYSTEM_DEFAULT:

                s.configure(self.style_name, background=BarColor[0],
                            troughcolor=BarColor[1], troughrelief=relief, borderwidth=border_width, thickness=width)
            else:
                s.configure(self.style_name, troughrelief=relief, borderwidth=border_width, thickness=width)

            self.TKProgressBarForReal = ttk.Progressbar(root, maximum=self.Max, style=self.style_name, length=length, orient=tk.VERTICAL, mode='determinate')

    def Update(self, count=None, max=None):
        """Updates the current value of the bar and/or
            updates the maximum value the bar can reach

        :param count: current value
        :type count:  (int)
        :param max:   the maximum value
        :type max:    (int)
        """
        if max is not None:
            self.Max = max
            try:
                self.TKProgressBarForReal.config(maximum=max)
            except:
                return False
        if count is not None:
            try:
                self.TKProgressBarForReal['value'] = count
            except:
                return False
        return True


# ---------------------------------------------------------------------- #
#                           Output                                       #
#  Routes stdout, stderr to a scrolled window                            #
# ---------------------------------------------------------------------- #
class Output(Multiline):
    """A multi-lined text area to where stdout, stderr, cprint are rerouted

    The Output Element is now based on the Multiline Element.
    When you make an Output Element, you're creating a Multiline Element
    with some specific settings set:
        auto_refresh = True
        auto_scroll = True
        reroute_stdout = True
        reroute_stderr = True
        reroute_cprint = True
        write_only = True

    If you choose to use a Multiline element to replace an Output element,
    be sure an turn on the write_only paramter in the Multiline so that an item
    is not included in the values dictionary on every window.read call.
    """

    def __init__(self, size=(None, None), s=(None, None), background_color=None, text_color=None, pad=None, p=None, autoscroll_only_at_bottom=False, echo_stdout_stderr=False, font=None, tooltip=None,
                 key=None, k=None, right_click_menu=None, expand_x=False, expand_y=False, visible=True, metadata=None, wrap_lines=None, horizontal_scroll=None,
                 sbar_trough_color=None, sbar_background_color=None, sbar_arrow_color=None,  sbar_width=None, sbar_arrow_width=None, sbar_frame_color=None, sbar_relief=None):
        """
        :param size:                        (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                         (int, int)  | (None, None) | int
        :param s:                           Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                            (int, int)  | (None, None) | int
        :param background_color:            color of background
        :type background_color:             (str)
        :param text_color:                  color of the text
        :type text_color:                   (str)
        :param pad:                         Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                          (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                           Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                            (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param autoscroll_only_at_bottom:   If True the contents of the element will automatically scroll only if the scrollbar is at the bottom of the multiline
        :type autoscroll_only_at_bottom:    (bool)
        :param echo_stdout_stderr:          If True then output to stdout will be output to this element AND also to the normal console location
        :type echo_stdout_stderr:           (bool)
        :param font:                        specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                         (str or (str, int[, str]) or None)
        :param tooltip:                     text, that will appear when mouse hovers over the element
        :type tooltip:                      (str)
        :param key:                         Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:                          str | int | tuple | object
        :param k:                           Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                            str | int | tuple | object
        :param right_click_menu:            A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:             List[List[ List[str] | str ]]
        :param expand_x:                    If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                     (bool)
        :param expand_y:                    If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                     (bool)
        :param visible:                     set visibility state of the element
        :type visible:                      (bool)
        :param metadata:                    User metadata that can be set to ANYTHING
        :type metadata:                     (Any)
        :param wrap_lines:                  If True, the lines will be wrapped automatically. Other parms affect this setting, but this one will override them all. Default is it does nothing and uses previous settings for wrapping.
        :type wrap_lines:                   (bool)
        :param horizontal_scroll:           Controls if a horizontal scrollbar should be shown. If True, then line wrapping will be off by default
        :type horizontal_scroll:            (bool)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        """


        super().__init__(size=size, s=s, background_color=background_color, autoscroll_only_at_bottom=autoscroll_only_at_bottom, text_color=text_color, pad=pad, p=p, echo_stdout_stderr=echo_stdout_stderr, font=font, tooltip=tooltip, wrap_lines=wrap_lines, horizontal_scroll=horizontal_scroll, key=key, k=k, right_click_menu=right_click_menu, write_only=True, reroute_stdout=True, reroute_stderr=True, reroute_cprint=True, autoscroll=True, auto_refresh=True, expand_x=expand_x, expand_y=expand_y, visible=visible, metadata=metadata, sbar_trough_color=sbar_trough_color, sbar_background_color=sbar_background_color, sbar_arrow_color=sbar_arrow_color, sbar_width=sbar_width, sbar_arrow_width=sbar_arrow_width, sbar_frame_color=sbar_frame_color, sbar_relief=sbar_relief)



# ---------------------------------------------------------------------- #
#                           Button Class                                 #
# ---------------------------------------------------------------------- #
class Button(Element):
    """Button Element

    Defines all possible buttons.
    The shortcuts such as Submit, FileBrowse,... each create a Button
    """

    def __init__(self, button_text='', button_type=BUTTON_TYPE_READ_FORM, target=(None, None), tooltip=None,
                 file_types=FILE_TYPES_ALL_FILES, initial_folder=None, default_extension='', disabled=False, change_submits=False,
                 enable_events=False, image_filename=None, image_data=None, image_size=(None, None),
                 image_subsample=None, image_zoom=None, image_source=None, border_width=None, size=(None, None), s=(None, None), auto_size_button=None, button_color=None,
                 disabled_button_color=None,
                 highlight_colors=None, mouseover_colors=(None, None), use_ttk_buttons=None, font=None, bind_return_key=False, focus=False, pad=None, p=None, key=None,
                 k=None, right_click_menu=None, expand_x=False, expand_y=False, visible=True, metadata=None):
        """
        :param button_text:           Text to be displayed on the button
        :type button_text:            (str)
        :param button_type:           You  should NOT be setting this directly. ONLY the shortcut functions set this
        :type button_type:            (int)
        :param target:                key or (row,col) target for the button. Note that -1 for column means 1 element to the left of this one. The constant ThisRow is used to indicate the current row. The Button itself is a valid target for some types of button
        :type target:                 str | (int, int)
        :param tooltip:               text, that will appear when mouse hovers over the element
        :type tooltip:                (str)
        :param file_types:            the filetypes that will be used to match files. To indicate all files: (("ALL Files", "*.* *"),).
        :type file_types:             Tuple[(str, str), ...]
        :param initial_folder:        starting path for folders and files
        :type initial_folder:         (str)
        :param default_extension:     If no extension entered by user, add this to filename (only used in saveas dialogs)
        :type default_extension:      (str)
        :param disabled:              If True button will be created disabled. If BUTTON_DISABLED_MEANS_IGNORE then the button will be ignored rather than disabled using tkinter
        :type disabled:               (bool | str)
        :param change_submits:        DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:         (bool)
        :param enable_events:         Turns on the element specific events. If this button is a target, should it generate an event when filled in
        :type enable_events:          (bool)
        :param image_source:          Image to place on button. Use INSTEAD of the image_filename and image_data. Unifies these into 1 easier to use parm
        :type image_source:           (str | bytes)
        :param image_filename:        image filename if there is a button image. GIFs and PNGs only.
        :type image_filename:         (str)
        :param image_data:            Raw or Base64 representation of the image to put on button. Choose either filename or data
        :type image_data:             bytes | str
        :param image_size:            Size of the image in pixels (width, height)
        :type image_size:             (int, int)
        :param image_subsample:       amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type image_subsample:        (int)
        :param image_zoom:            amount to increase the size of the image. 2=twice size, 3=3 times, etc
        :type image_zoom:             (int)
        :param border_width:          width of border around button in pixels
        :type border_width:           (int)
        :param size:                  (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                   (int | None, int | None)  | (None, None) | int
        :param s:                     Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                      (int | None, int | None)  | (None, None) | int
        :param auto_size_button:      if True the button size is sized to fit the text
        :type auto_size_button:       (bool)
        :param button_color:          Color of button. default is from theme or the window. Easy to remember which is which if you say "ON" between colors. "red" on "green". Normally a tuple, but can be a simplified-button-color-string "foreground on background". Can be a single color if want to set only the background.
        :type button_color:           (str, str) | str
        :param disabled_button_color: colors to use when button is disabled (text, background). Use None for a color if don't want to change. Only ttk buttons support both text and background colors. tk buttons only support changing text color
        :type disabled_button_color:  (str, str) | str
        :param highlight_colors:      colors to use when button has focus (has focus, does not have focus). None will use colors based on theme. Only used by Linux and only for non-TTK button
        :type highlight_colors:       (str, str)
        :param mouseover_colors:      Important difference between Linux & Windows! Linux - Colors when mouse moved over button.  Windows - colors when button is pressed. The default is to switch the text and background colors (an inverse effect)
        :type mouseover_colors:       (str, str) | str
        :param use_ttk_buttons:       True = use ttk buttons. False = do not use ttk buttons.  None (Default) = use ttk buttons only if on a Mac and not with button images
        :type use_ttk_buttons:        (bool)
        :param font:                  specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                   (str or (str, int[, str]) or None)
        :param bind_return_key:       If True then pressing the return key in an Input or Multiline Element will cause this button to appear to be clicked (generates event with this button's key
        :type bind_return_key:        (bool)
        :param focus:                 if True, initial focus will be put on this button
        :type focus:                  (bool)
        :param pad:                   Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                     Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:                   Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:                    str | int | tuple | object
        :param k:                     Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                      str | int | tuple | object
        :param right_click_menu:      A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:       List[List[ List[str] | str ]]
        :param expand_x:              If True the element will automatically expand in the X direction to fill available space
        :type expand_x:               (bool)
        :param expand_y:              If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:               (bool)
        :param visible:               set visibility state of the element
        :type visible:                (bool)
        :param metadata:              User metadata that can be set to ANYTHING
        :type metadata:               (Any)
        """

        self.AutoSizeButton = auto_size_button
        self.BType = button_type
        if file_types is not None and len(file_types) == 2 and isinstance(file_types[0], str) and isinstance(file_types[1], str):
            warnings.warn('file_types parameter not correctly specified. This parameter is a LIST of TUPLES. You have passed (str,str) rather than ((str, str),). Fixing it for you this time.\nchanging {} to {}\nPlease correct your code'.format(file_types, ((file_types[0], file_types[1]),)), UserWarning)
            file_types = ((file_types[0], file_types[1]),)
        self.FileTypes = file_types
        self.Widget = self.TKButton = None  # type: tk.Button
        self.Target = target
        self.ButtonText = str(button_text)
        self.RightClickMenu = right_click_menu
        self.ButtonColor = button_color_to_tuple(button_color)

        self.DisabledButtonColor = button_color_to_tuple(disabled_button_color) if disabled_button_color is not None else (None, None)
        if image_source is not None:
            if isinstance(image_source, bytes):
                image_data = image_source
            elif isinstance(image_source, str):
                image_filename = image_source
        self.ImageFilename = image_filename
        self.ImageData = image_data
        self.ImageSize = image_size
        self.ImageSubsample = image_subsample
        self.zoom = int(image_zoom) if image_zoom is not None else None
        self.UserData = None
        self.BorderWidth = border_width if border_width is not None else DEFAULT_BORDER_WIDTH
        self.BindReturnKey = bind_return_key
        self.Focus = focus
        #self.TKCal = None
        self.calendar_default_date_M_D_Y = (None, None, None)
        self.calendar_close_when_chosen = False
        self.calendar_locale = None
        self.calendar_format = None
        self.calendar_location = (None, None)
        self.calendar_no_titlebar = True
        self.calendar_begin_at_sunday_plus = 0
        self.calendar_month_names = None
        self.calendar_day_abbreviations = None
        self.calendar_title = ''
        self.calendar_selection = ''
        self.default_button = None
        self.InitialFolder = initial_folder
        self.DefaultExtension = default_extension
        self.Disabled = disabled
        self.ChangeSubmits = change_submits or enable_events
        self.UseTtkButtons = use_ttk_buttons
        self._files_delimiter = BROWSE_FILES_DELIMITER  # used by the file browse button. used when multiple files are selected by user
        if use_ttk_buttons is None and running_mac():
            self.UseTtkButtons = True
        # if image_filename or image_data:
        #     self.UseTtkButtons = False              # if an image is to be displayed, then force the button to not be a TTK Button
        if key is None and k is None:
            _key = self.ButtonText
            if DEFAULT_USE_BUTTON_SHORTCUTS is True:
                pos = _key.find(MENU_SHORTCUT_CHARACTER)
                if pos != -1:
                    if pos < len(MENU_SHORTCUT_CHARACTER) or _key[pos - len(MENU_SHORTCUT_CHARACTER)] != "\\":
                        _key = _key[:pos] + _key[pos + len(MENU_SHORTCUT_CHARACTER):]
                    else:
                        _key = _key.replace('\\'+MENU_SHORTCUT_CHARACTER, MENU_SHORTCUT_CHARACTER)
        else:
            _key = key if key is not None else k
        if highlight_colors is not None:
            self.HighlightColors = highlight_colors
        else:
            self.HighlightColors = self._compute_highlight_colors()

        if mouseover_colors != (None, None):
            self.MouseOverColors = button_color_to_tuple(mouseover_colors)
        elif button_color != None:
            self.MouseOverColors = (self.ButtonColor[1], self.ButtonColor[0])
        else:
            self.MouseOverColors = (theme_button_color()[1], theme_button_color()[0])
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        sz = size if size != (None, None) else s
        super().__init__(ELEM_TYPE_BUTTON, size=sz, font=font, pad=pad, key=_key, tooltip=tooltip, visible=visible, metadata=metadata)
        return

    def _compute_highlight_colors(self):
        """Determines the color to use to indicate the button has focus

        This is only used by Linux.

        :return: Pair of colors. (Highlight, Highlight Background)
        :rtype:  (str, str)
        """
        highlight_color = highlight_background = COLOR_SYSTEM_DEFAULT
        if self.ButtonColor != COLOR_SYSTEM_DEFAULT and theme_background_color() != COLOR_SYSTEM_DEFAULT:
            highlight_background = theme_background_color()
        if self.ButtonColor != COLOR_SYSTEM_DEFAULT and self.ButtonColor[0] != COLOR_SYSTEM_DEFAULT:
            if self.ButtonColor[0] != theme_background_color():
                highlight_color = self.ButtonColor[0]
            else:
                highlight_color = 'red'
        return (highlight_color, highlight_background)

        # Realtime button release callback

    def ButtonReleaseCallBack(self, parm):
        """NOTE: Not a user callable function

        Called by tkinter when a 'realtime' button is released.

        :param parm: the event info from tkinter
        :type parm:
        """
        self.LastButtonClickedWasRealtime = False
        self.ParentForm.LastButtonClicked = None

    # Realtime button callback
    def ButtonPressCallBack(self, parm):
        """NOTE: Not a user callable function

        Callback called by tkinter when a 'realtime' button is pressed

        :param parm: Event info passed in by tkinter
        :type parm:
        """
        self.ParentForm.LastButtonClickedWasRealtime = True
        if self.Key is not None:
            self.ParentForm.LastButtonClicked = self.Key
        else:
            self.ParentForm.LastButtonClicked = self.ButtonText
        # if self.ParentForm.CurrentlyRunningMainloop:
        #     Window._window_that_exited = self.ParentForm
        #     self.ParentForm.TKroot.quit()  # kick out of loop if read was called
        _exit_mainloop(self.ParentForm)

    def _find_target(self):
        target = self.Target
        target_element = None

        if target[0] == ThisRow:
            target = [self.Position[0], target[1]]
            if target[1] < 0:
                target[1] = self.Position[1] + target[1]
        strvar = None
        should_submit_window = False
        if target == (None, None):
            strvar = self.TKStringVar
        else:
            # Need a try-block because if the target is not hashable, the "in" test will raise exception
            try:
                if target in self.ParentForm.AllKeysDict:
                    target_element = self.ParentForm.AllKeysDict[target]
            except:
                pass
            # if target not found or the above try got exception, then keep looking....
            if target_element is None:
                if not isinstance(target, str):
                    if target[0] < 0:
                        target = [self.Position[0] + target[0], target[1]]
                    target_element = self.ParentContainer._GetElementAtLocation(target)
                else:
                    target_element = self.ParentForm.find_element(target)
            try:
                strvar = target_element.TKStringVar
            except:
                pass
            try:
                if target_element.ChangeSubmits:
                    should_submit_window = True
            except:
                pass
        return target_element, strvar, should_submit_window

    # -------  Button Callback  ------- #
    def ButtonCallBack(self):
        """NOTE: Not user callable function

        Called by tkinter when a button is clicked.
        """
        if self.Disabled == BUTTON_DISABLED_MEANS_IGNORE:
            return
        target_element, strvar, should_submit_window = self._find_target()

        filetypes = FILE_TYPES_ALL_FILES if self.FileTypes is None else self.FileTypes

        if self.BType == BUTTON_TYPE_BROWSE_FOLDER:
            if running_mac():  # macs don't like seeing the parent window (go firgure)
                folder_name = tk.filedialog.askdirectory(initialdir=self.InitialFolder)  # show the 'get folder' dialog box
            else:
                folder_name = tk.filedialog.askdirectory(initialdir=self.InitialFolder, parent=self.ParentForm.TKroot)  # show the 'get folder' dialog box
            if folder_name:
                try:
                    strvar.set(folder_name)
                    self.TKStringVar.set(folder_name)
                except:
                    pass
            else:  # if "cancel" button clicked, don't generate an event
                should_submit_window = False
        elif self.BType == BUTTON_TYPE_BROWSE_FILE:
            if running_mac():
                # Workaround for the "*.*" issue on Mac
                is_all = [(x, y) for (x, y) in filetypes if all(ch in '* .' for ch in y)]
                if not len(set(filetypes)) > 1 and (len(is_all) != 0 or filetypes == FILE_TYPES_ALL_FILES):
                    file_name = tk.filedialog.askopenfilename(initialdir=self.InitialFolder)
                else:
                    file_name = tk.filedialog.askopenfilename(initialdir=self.InitialFolder, filetypes=filetypes)
            else:
                file_name = tk.filedialog.askopenfilename(filetypes=filetypes, initialdir=self.InitialFolder, parent=self.ParentForm.TKroot)

            if file_name:
                strvar.set(file_name)
                self.TKStringVar.set(file_name)
            else:  # if "cancel" button clicked, don't generate an event
                should_submit_window = False
        elif self.BType == BUTTON_TYPE_COLOR_CHOOSER:
            color = tk.colorchooser.askcolor( # show the 'get file' dialog box
                parent=self.ParentForm.TKroot, color=self.default_color)
            color = color[1]  # save only the #RRGGBB portion
            if color is not None:
                strvar.set(color)
                self.TKStringVar.set(color)
        elif self.BType == BUTTON_TYPE_BROWSE_FILES:
            if running_mac():
                # Workaround for the "*.*" issue on Mac
                is_all = [(x, y) for (x, y) in filetypes if all(ch in '* .' for ch in y)]
                if not len(set(filetypes)) > 1 and (len(is_all) != 0 or filetypes == FILE_TYPES_ALL_FILES):
                    file_name = tk.filedialog.askopenfilenames(initialdir=self.InitialFolder)
                else:
                    file_name = tk.filedialog.askopenfilenames(filetypes=filetypes, initialdir=self.InitialFolder)
            else:
                file_name = tk.filedialog.askopenfilenames(filetypes=filetypes, initialdir=self.InitialFolder, parent=self.ParentForm.TKroot)

            if file_name:
                file_name = self._files_delimiter.join(file_name)  # normally a ';'
                strvar.set(file_name)
                self.TKStringVar.set(file_name)
            else:  # if "cancel" button clicked, don't generate an event
                should_submit_window = False
        elif self.BType == BUTTON_TYPE_SAVEAS_FILE:

            if running_mac():
                # Workaround for the "*.*" issue on Mac
                is_all = [(x, y) for (x, y) in filetypes if all(ch in '* .' for ch in y)]
                if not len(set(filetypes)) > 1 and (len(is_all) != 0 or filetypes == FILE_TYPES_ALL_FILES):
                    file_name = tk.filedialog.asksaveasfilename(defaultextension=self.DefaultExtension, initialdir=self.InitialFolder)
                else:
                    file_name = tk.filedialog.asksaveasfilename(filetypes=filetypes, defaultextension=self.DefaultExtension, initialdir=self.InitialFolder)
            else:
                file_name = tk.filedialog.asksaveasfilename(filetypes=filetypes, defaultextension=self.DefaultExtension, initialdir=self.InitialFolder,
                                                            parent=self.ParentForm.TKroot)

            if file_name:
                strvar.set(file_name)
                self.TKStringVar.set(file_name)
            else:  # if "cancel" button clicked, don't generate an event
                should_submit_window = False
        elif self.BType == BUTTON_TYPE_CLOSES_WIN:  # this is a return type button so GET RESULTS and destroy window
            # first, get the results table built
            # modify the Results table in the parent FlexForm object
            if self.Key is not None:
                self.ParentForm.LastButtonClicked = self.Key
            else:
                self.ParentForm.LastButtonClicked = self.ButtonText
            self.ParentForm.FormRemainedOpen = False
            self.ParentForm._Close()
            _exit_mainloop(self.ParentForm)

            if self.ParentForm.NonBlocking:
                self.ParentForm.TKroot.destroy()
                Window._DecrementOpenCount()
        elif self.BType == BUTTON_TYPE_READ_FORM:  # LEAVE THE WINDOW OPEN!! DO NOT CLOSE
            # This is a PLAIN BUTTON
            # first, get the results table built
            # modify the Results table in the parent FlexForm object
            if self.Key is not None:
                self.ParentForm.LastButtonClicked = self.Key
            else:
                self.ParentForm.LastButtonClicked = self.ButtonText
            self.ParentForm.FormRemainedOpen = True
            _exit_mainloop(self.ParentForm)
        elif self.BType == BUTTON_TYPE_CLOSES_WIN_ONLY:  # special kind of button that does not exit main loop
            self.ParentForm._Close(without_event=True)
            self.ParentForm.TKroot.destroy()  # close the window with tkinter
            Window._DecrementOpenCount()
        elif self.BType == BUTTON_TYPE_CALENDAR_CHOOSER:  # this is a return type button so GET RESULTS and destroy window
            # ------------ new chooser code -------------
            self.ParentForm.LastButtonClicked = self.Key  # key should have been generated already if not set by user
            self.ParentForm.FormRemainedOpen = True
            should_submit_window = False
            _exit_mainloop(self.ParentForm)

        if should_submit_window:
            self.ParentForm.LastButtonClicked = target_element.Key
            self.ParentForm.FormRemainedOpen = True
            _exit_mainloop(self.ParentForm)

        return

    def update(self, text=None, button_color=(None, None), disabled=None, image_source=None, image_data=None, image_filename=None,
               visible=None, image_subsample=None, image_zoom=None, disabled_button_color=(None, None), image_size=None):
        """Changes some of the settings for the Button Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param text:                  sets button text
        :type text:                   (str)
        :param button_color:          Color of button. default is from theme or the window. Easy to remember which is which if you say "ON" between colors. "red" on "green". Normally a tuple, but can be a simplified-button-color-string "foreground on background". Can be a single color if want to set only the background.
        :type button_color:           (str, str) | str
        :param disabled:              True/False to enable/disable at the GUI level. Use BUTTON_DISABLED_MEANS_IGNORE to ignore clicks (won't change colors)
        :type disabled:               (bool | str)
        :param image_source:          Image to place on button. Use INSTEAD of the image_filename and image_data. Unifies these into 1 easier to use parm
        :type image_source:           (str | bytes)
        :param image_data:            Raw or Base64 representation of the image to put on button. Choose either filename or data
        :type image_data:             bytes | str
        :param image_filename:        image filename if there is a button image. GIFs and PNGs only.
        :type image_filename:         (str)
        :param disabled_button_color: colors to use when button is disabled (text, background). Use None for a color if don't want to change. Only ttk buttons support both text and background colors. tk buttons only support changing text color
        :type disabled_button_color:  (str, str)
        :param visible:               control visibility of element
        :type visible:                (bool)
        :param image_subsample:       amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type image_subsample:        (int)
        :param image_zoom:            amount to increase the size of the image. 2=twice size, 3=3 times, etc
        :type image_zoom:             (int)
        :param image_size:            Size of the image in pixels (width, height)
        :type image_size:             (int, int)
        """

        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Button.update:\n - The window was closed')
            return

        if image_source is not None:
            if isinstance(image_source, bytes):
                image_data = image_source
            elif isinstance(image_source, str):
                image_filename = image_source

        if self.UseTtkButtons:
            style_name = self.ttk_style_name  # created when made initial window (in the pack)
            # style_name = str(self.Key) + 'custombutton.TButton'
            button_style = ttk.Style()
        if text is not None:
            btext = text
            if DEFAULT_USE_BUTTON_SHORTCUTS is True:
                pos = btext.find(MENU_SHORTCUT_CHARACTER)
                if pos != -1:
                    if pos < len(MENU_SHORTCUT_CHARACTER) or btext[pos - len(MENU_SHORTCUT_CHARACTER)] != "\\":
                        btext = btext[:pos] + btext[pos + len(MENU_SHORTCUT_CHARACTER):]
                    else:
                        btext = btext.replace('\\'+MENU_SHORTCUT_CHARACTER, MENU_SHORTCUT_CHARACTER)
                        pos = -1
                if pos != -1:
                    self.TKButton.config(underline=pos)
            self.TKButton.configure(text=btext)
            self.ButtonText = text
        if button_color != (None, None) and button_color != COLOR_SYSTEM_DEFAULT:
            bc = button_color_to_tuple(button_color, self.ButtonColor)
            # if isinstance(button_color, str):
            #     try:
            #         button_color = button_color.split(' on ')
            #     except Exception as e:
            #         print('** Error in formatting your button color **', button_color, e)
            if self.UseTtkButtons:
                if bc[0] not in (None, COLOR_SYSTEM_DEFAULT):
                    button_style.configure(style_name, foreground=bc[0])
                if bc[1] not in (None, COLOR_SYSTEM_DEFAULT):
                    button_style.configure(style_name, background=bc[1])
            else:
                if bc[0] not in (None, COLOR_SYSTEM_DEFAULT):
                    self.TKButton.config(foreground=bc[0], activebackground=bc[0])
                if bc[1] not in (None, COLOR_SYSTEM_DEFAULT):
                    self.TKButton.config(background=bc[1], activeforeground=bc[1])
            self.ButtonColor = bc
        if disabled is True:
            self.TKButton['state'] = 'disabled'
        elif disabled is False:
            self.TKButton['state'] = 'normal'
        elif disabled == BUTTON_DISABLED_MEANS_IGNORE:
            self.TKButton['state'] = 'normal'
        self.Disabled = disabled if disabled is not None else self.Disabled

        if image_data is not None:
            image = tk.PhotoImage(data=image_data)
            if image_subsample:
                image = image.subsample(image_subsample)
            if image_zoom is not None:
                image = image.zoom(int(image_zoom))
            if image_size is not None:
                width, height = image_size
            else:
                width, height = image.width(), image.height()
            if self.UseTtkButtons:
                button_style.configure(style_name, image=image, width=width, height=height)
            else:
                self.TKButton.config(image=image, width=width, height=height)
            self.TKButton.image = image
        if image_filename is not None:
            image = tk.PhotoImage(file=image_filename)
            if image_subsample:
                image = image.subsample(image_subsample)
            if image_zoom is not None:
                image = image.zoom(int(image_zoom))
            if image_size is not None:
                width, height = image_size
            else:
                width, height = image.width(), image.height()
            if self.UseTtkButtons:
                button_style.configure(style_name, image=image, width=width, height=height)
            else:
                self.TKButton.config(highlightthickness=0, image=image, width=width, height=height)
            self.TKButton.image = image
        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()
        if disabled_button_color != (None, None) and disabled_button_color != COLOR_SYSTEM_DEFAULT:
            if not self.UseTtkButtons:
                self.TKButton['disabledforeground'] = disabled_button_color[0]
            else:
                if disabled_button_color[0] is not None:
                    button_style.map(style_name, foreground=[('disabled', disabled_button_color[0])])
                if disabled_button_color[1] is not None:
                    button_style.map(style_name, background=[('disabled', disabled_button_color[1])])
            self.DisabledButtonColor = (disabled_button_color[0] if disabled_button_color[0] is not None else self.DisabledButtonColor[0],
                                        disabled_button_color[1] if disabled_button_color[1] is not None else self.DisabledButtonColor[1])

        if visible is not None:
            self._visible = visible

    def get_text(self):
        """Returns the current text shown on a button

        :return: The text currently displayed on the button
        :rtype:  (str)
        """
        return self.ButtonText

    def click(self):
        """Generates a click of the button as if the user clicked the button

        Calls the tkinter invoke method for the button.
        """
        try:
            self.TKButton.invoke()
        except:
            print('Exception clicking button')

    Click = click
    GetText = get_text
    Update = update


# -------------------------  Button lazy functions  ------------------------- #
B = Button
Btn = Button


# ---------------------------------------------------------------------- #
#                           ButtonMenu Class                             #
# ---------------------------------------------------------------------- #
class ButtonMenu(Element):
    """The Button Menu Element

    Creates a button that when clicked will show a menu similar to right click menu.
    """

    def __init__(self, button_text, menu_def, tooltip=None, disabled=False, image_source=None,
                 image_filename=None, image_data=None, image_size=(None, None), image_subsample=None, image_zoom=None, border_width=None,
                 size=(None, None), s=(None, None), auto_size_button=None, button_color=None, text_color=None, background_color=None, disabled_text_color=None,
                 font=None, item_font=None, pad=None, p=None, expand_x=False, expand_y=False, key=None, k=None, tearoff=False, visible=True,
                 metadata=None):
        """
        :param button_text:               Text to be displayed on the button
        :type button_text:                (str)
        :param menu_def:                  A list of lists of Menu items to show when this element is clicked. See docs for format as they are the same for all menu types
        :type menu_def:                   List[List[str]]
        :param tooltip:                   text, that will appear when mouse hovers over the element
        :type tooltip:                    (str)
        :param disabled:                  If True button will be created disabled
        :type disabled:                   (bool)
        :param image_source:              Image to place on button. Use INSTEAD of the image_filename and image_data. Unifies these into 1 easier to use parm
        :type image_source:               (str | bytes)
        :param image_filename:            image filename if there is a button image. GIFs and PNGs only.
        :type image_filename:             (str)
        :param image_data:                Raw or Base64 representation of the image to put on button. Choose either filename or data
        :type image_data:                 bytes | str
        :param image_size:                Size of the image in pixels (width, height)
        :type image_size:                 (int, int)
        :param image_subsample:           amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type image_subsample:            (int)
        :param image_zoom:                amount to increase the size of the image. 2=twice size, 3=3 times, etc
        :type image_zoom:                 (int)
        :param border_width:              width of border around button in pixels
        :type border_width:               (int)
        :param size:                      (w, h) w=characters-wide, h=rows-high. If an int instead of a tuple is supplied, then height is auto-set to 1
        :type size:                       (int, int)  | (None, None) | int
        :param s:                         Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                          (int, int)  | (None, None) | int
        :param auto_size_button:          if True the button size is sized to fit the text
        :type auto_size_button:           (bool)
        :param button_color:              of button. Easy to remember which is which if you say "ON" between colors. "red" on "green"
        :type button_color:               (str, str) | str
        :param background_color:          color of the background
        :type background_color:           (str)
        :param text_color:                element's text color. Can be in #RRGGBB format or a color name "black"
        :type text_color:                 (str)
        :param disabled_text_color:       color to use for text when item is disabled. Can be in #RRGGBB format or a color name "black"
        :type disabled_text_color:        (str)
        :param font:                      specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                       (str or (str, int[, str]) or None)
        :param item_font:                 specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike, for the menu items
        :type item_font:                  (str or (str, int[, str]) or None)
        :param pad:                       Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                        (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                         Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                          (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param expand_x:                  If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                   (bool)
        :param expand_y:                  If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                   (bool)
        :param key:                       Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:                        str | int | tuple | object
        :param k:                         Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                          str | int | tuple | object
        :param tearoff:                   Determines if menus should allow them to be torn off
        :type tearoff:                    (bool)
        :param visible:                   set visibility state of the element
        :type visible:                    (bool)
        :param metadata:                  User metadata that can be set to ANYTHING
        :type metadata:                   (Any)
        """

        self.MenuDefinition = copy.deepcopy(menu_def)

        self.AutoSizeButton = auto_size_button
        self.ButtonText = button_text
        self.ButtonColor = button_color_to_tuple(button_color)
        # self.TextColor = self.ButtonColor[0]
        # self.BackgroundColor = self.ButtonColor[1]
        self.BackgroundColor = background_color if background_color is not None else theme_input_background_color()
        self.TextColor = text_color if text_color is not None else theme_input_text_color()
        self.DisabledTextColor = disabled_text_color if disabled_text_color is not None else COLOR_SYSTEM_DEFAULT
        self.ItemFont = item_font
        self.BorderWidth = border_width if border_width is not None else DEFAULT_BORDER_WIDTH
        if image_source is not None:
            if isinstance(image_source, str):
                image_filename = image_source
            elif isinstance(image_source, bytes):
                image_data = image_source
            else:
                warnings.warn('ButtonMenu element - image_source is not a valid type: {}'.format(type(image_source)), UserWarning)

        self.ImageFilename = image_filename
        self.ImageData = image_data
        self.ImageSize = image_size
        self.ImageSubsample = image_subsample
        self.zoom = int(image_zoom) if image_zoom is not None else None
        self.Disabled = disabled
        self.IsButtonMenu = True
        self.MenuItemChosen = None
        self.Widget = self.TKButtonMenu = None  # type: tk.Menubutton
        self.TKMenu = None  # type: tk.Menu
        self.part_of_custom_menubar = False
        self.custom_menubar_key = None
        # self.temp_size = size if size != (NONE, NONE) else
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        super().__init__(ELEM_TYPE_BUTTONMENU, size=sz, font=font, pad=pad, key=key, tooltip=tooltip,
                         text_color=self.TextColor, background_color=self.BackgroundColor, visible=visible, metadata=metadata)
        self.Tearoff = tearoff

    def _MenuItemChosenCallback(self, item_chosen):  # ButtonMenu Menu Item Chosen Callback
        """
        Not a user callable function.  Called by tkinter when an item is chosen from the menu.

        :param item_chosen: The menu item chosen.
        :type item_chosen:  (str)
        """
        # print('IN MENU ITEM CALLBACK', item_chosen)
        self.MenuItemChosen = item_chosen
        self.ParentForm.LastButtonClicked = self.Key
        self.ParentForm.FormRemainedOpen = True
        # if self.ParentForm.CurrentlyRunningMainloop:
        #     self.ParentForm.TKroot.quit()  # kick the users out of the mainloop
        _exit_mainloop(self.ParentForm)

    def update(self, menu_definition=None, visible=None, image_source=None, image_size=(None, None), image_subsample=None, image_zoom=None, button_text=None, button_color=None):
        """Changes some of the settings for the ButtonMenu Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param menu_definition: (New menu definition (in menu definition format)
        :type menu_definition:  List[List]
        :param visible:         control visibility of element
        :type visible:          (bool)
        :param image_source:    new image if image is to be changed. Can be a filename or a base64 encoded byte-string
        :type image_source:     (str | bytes)
        :param image_size:      Size of the image in pixels (width, height)
        :type image_size:       (int, int)
        :param image_subsample: amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type image_subsample:  (int)
        :param image_zoom:      amount to increase the size of the image. 2=twice size, 3=3 times, etc
        :type image_zoom:       (int)
        :param button_text:     Text to be shown on the button
        :type button_text:      (str)
        :param button_color:    Normally a tuple, but can be a simplified-button-color-string "foreground on background". Can be a single color if want to set only the background.
        :type button_color:     (str, str) | str
        """

        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in ButtonMenu.update:\n - The window was closed')
            return

        if menu_definition is not None:
            self.MenuDefinition = copy.deepcopy(menu_definition)
            top_menu = self.TKMenu = tk.Menu(self.TKButtonMenu, tearoff=self.Tearoff, font=self.ItemFont, tearoffcommand=self._tearoff_menu_callback)

            if self.BackgroundColor not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(bg=self.BackgroundColor)
            if self.TextColor not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(fg=self.TextColor)
            if self.DisabledTextColor not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(disabledforeground=self.DisabledTextColor)
            if self.ItemFont is not None:
                top_menu.config(font=self.ItemFont)
            AddMenuItem(self.TKMenu, self.MenuDefinition[1], self)
            self.TKButtonMenu.configure(menu=self.TKMenu)
        if image_source is not None:
            filename = data = None
            if image_source is not None:
                if isinstance(image_source, bytes):
                    data = image_source
                elif isinstance(image_source, str):
                    filename = image_source
                else:
                    warnings.warn('ButtonMenu element - image_source is not a valid type: {}'.format(type(image_source)), UserWarning)
            image = None
            if filename is not None:
                image = tk.PhotoImage(file=filename)
                if image_subsample is not None:
                    image = image.subsample(image_subsample)
                if image_zoom is not None:
                    image = image.zoom(int(image_zoom))
            elif data is not None:
                # if type(data) is bytes:
                try:
                    image = tk.PhotoImage(data=data)
                    if image_subsample is not None:
                        image = image.subsample(image_subsample)
                    if image_zoom is not None:
                        image = image.zoom(int(image_zoom))
                except Exception as e:
                    image = data

            if image is not None:
                if type(image) is not bytes:
                    width, height = image_size[0] if image_size[0] is not None else image.width(), image_size[1] if image_size[1] is not None else image.height()
                else:
                    width, height = image_size

                self.TKButtonMenu.config(image=image, compound=tk.CENTER, width=width, height=height)
                self.TKButtonMenu.image = image
        if button_text is not None:
            self.TKButtonMenu.configure(text=button_text)
            self.ButtonText = button_text
        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()
        if visible is not None:
            self._visible = visible
        if button_color != (None, None) and button_color != COLOR_SYSTEM_DEFAULT:
            bc = button_color_to_tuple(button_color, self.ButtonColor)
            if bc[0] not in (None, COLOR_SYSTEM_DEFAULT):
                self.TKButtonMenu.config(foreground=bc[0], activeforeground=bc[0])
            if bc[1] not in (None, COLOR_SYSTEM_DEFAULT):
                self.TKButtonMenu.config(background=bc[1], activebackground=bc[1])
            self.ButtonColor = bc

    def click(self):
        """Generates a click of the button as if the user clicked the button

        Calls the tkinter invoke method for the button
        """
        try:
            self.TKMenu.invoke(1)
        except:
            print('Exception clicking button')

    Update = update
    Click = click


BMenu = ButtonMenu
BM = ButtonMenu


# ---------------------------------------------------------------------- #
#                           ProgreessBar                                 #
# ---------------------------------------------------------------------- #
class ProgressBar(Element):
    """Progress Bar Element

    Displays a colored bar that is shaded as progress of some operation is made.
    """

    def __init__(self, max_value, orientation=None, size=(None, None), s=(None, None), size_px=(None, None), auto_size_text=None, bar_color=None, style=None, border_width=None,
                 relief=None, key=None, k=None, pad=None, p=None, right_click_menu=None, expand_x=False, expand_y=False, visible=True, metadata=None):
        """
        :param max_value:        max value of progressbar
        :type max_value:         (int)
        :param orientation:      'horizontal' or 'vertical'
        :type orientation:       (str)
        :param size:             Size of the bar.  If horizontal (chars long, pixels wide), vert (chars high, pixels wide). Vert height measured using horizontal chars units.
        :type size:              (int, int) |  (int, None)
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None)
        :param size_px:          Size in pixels (length, width). Will be used in place of size parm if specified
        :type size_px:           (int, int) | (None, None)
        :param auto_size_text:   Not sure why this is here
        :type auto_size_text:    (bool)
        :param bar_color:        The 2 colors that make up a progress bar. Either a tuple of 2 strings or a string. Tuple - (bar, background). A string with 1 color changes the background of the bar only. A string with 2 colors separated by "on" like "red on blue" specifies a red bar on a blue background.
        :type bar_color:         (str, str) or str
        :param style:            Progress bar style defined as one of these 'default', 'winnative', 'clam', 'alt', 'classic', 'vista', 'xpnative'
        :type style:             (str)
        :param border_width:     The amount of pixels that go around the outside of the bar
        :type border_width:      (int)
        :param relief:           relief style. Values are same as progress meter relief values.  Can be a constant or a string: `RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID` (Default value = DEFAULT_PROGRESS_BAR_RELIEF)
        :type relief:            (str)
        :param key:              Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """

        self.MaxValue = max_value
        self.TKProgressBar = None  # type: TKProgressBar
        self.Cancelled = False
        self.NotRunning = True
        self.Orientation = orientation if orientation else DEFAULT_METER_ORIENTATION
        self.RightClickMenu = right_click_menu
        # Progress Bar colors can be a tuple (text, background) or a string with format "bar on background" - examples "red on white" or ("red", "white")
        if bar_color is None:
            bar_color = DEFAULT_PROGRESS_BAR_COLOR
        else:
            bar_color = _simplified_dual_color_to_tuple(bar_color, default=DEFAULT_PROGRESS_BAR_COLOR)

        self.BarColor = bar_color  # should be a tuple at this point
        self.BarStyle = style if style else DEFAULT_TTK_THEME
        self.BorderWidth = border_width if border_width else DEFAULT_PROGRESS_BAR_BORDER_WIDTH
        self.Relief = relief if relief else DEFAULT_PROGRESS_BAR_RELIEF
        self.BarExpired = False
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y
        self.size_px = size_px

        super().__init__(ELEM_TYPE_PROGRESS_BAR, size=sz, auto_size_text=auto_size_text, key=key, pad=pad,
                         visible=visible, metadata=metadata)

    # returns False if update failed
    def update_bar(self, current_count, max=None):
        """
        NOTE: DEPRECATED BUT STILL USABLE.
        Has been combined with the normal `ProgressBar.update` method.
        Change what the bar shows by changing the current count and optionally the max count.

        :param current_count: sets the current value
        :type current_count:  (int)
        :param max:           changes the max value
        :type max:            (int)
        """

        if self.ParentForm.TKrootDestroyed:
            return False
        self.TKProgressBar.Update(current_count, max=max)
        try:
            self.ParentForm.TKroot.update()
        except:
            Window._DecrementOpenCount()
            # _my_windows.Decrement()
            return False
        return True

    def update(self, current_count=None, max=None, bar_color=None, visible=None):
        """Changes some of the settings for the ProgressBar Element.

        Must call `Window.Read` or `Window.Finalize` prior.
        Now has the ability to modify the count so that the `update_bar` method is not longer needed separately

        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param current_count: sets the current value
        :type current_count:  (int)
        :param max:           changes the max value
        :type max:            (int)
        :param bar_color:     The 2 colors that make up a progress bar. Easy to remember which is which if you say "ON" between colors. "red" on "green".
        :type bar_color:      (str, str) | str
        :param visible:       control visibility of element
        :type visible:        (bool)
        :return:              Returns True if update was OK.  False means something wrong with window or it was closed
        :rtype:               (bool)
        """
        if not self._widget_was_created():
            return False

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in ProgressBar.update:\n - The window was closed')
            return

        if self.ParentForm.TKrootDestroyed:
            return False

        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()

        if visible is not None:
            self._visible = visible
        if bar_color is not None:
            bar_color = _simplified_dual_color_to_tuple(bar_color, default=DEFAULT_PROGRESS_BAR_COLOR)
            self.BarColor = bar_color
            style = ttk.Style()
            style.configure(self.ttk_style_name, background=bar_color[0], troughcolor=bar_color[1])
        if current_count is not None:
            self.TKProgressBar.Update(current_count, max=max)

        try:
            self.ParentForm.TKroot.update()
        except:
            # Window._DecrementOpenCount()
            # _my_windows.Decrement()
            return False
        return True

    Update = update
    UpdateBar = update_bar


PBar = ProgressBar
Prog = ProgressBar
Progress = ProgressBar


# ---------------------------------------------------------------------- #
#                           Image                                        #
# ---------------------------------------------------------------------- #
class Image(Element):
    """Image Element

    Shows an image in the window.
    Should be a GIF or a PNG only.
    """
    def __init__(self, source=None, filename=None, data=None, background_color=None, size=(None, None), s=(None, None), pad=None, p=None, key=None, k=None, tooltip=None,
                 subsample=None, zoom=None, right_click_menu=None, expand_x=False, expand_y=False, visible=True, enable_events=False, metadata=None):
        """
        :param source:           A filename or a base64 bytes. Will automatically detect the type and fill in filename or data for you.
        :type source:            str | bytes | None
        :param filename:         image filename if there is a button image. GIFs and PNGs only.
        :type filename:          str | None
        :param data:             Raw or Base64 representation of the image to put on button. Choose either filename or data
        :type data:              bytes | str | None
        :param background_color: color of background
        :type background_color:
        :param size:             (width, height) size of image in pixels
        :type size:              (int, int)
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:              Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param subsample:        amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type subsample:         (int)
        :param zoom:             amount to increase the size of the image.
        :type zoom:              (int)
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param enable_events:    Turns on the element specific events. For an Image element, the event is "image clicked"
        :type enable_events:     (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """

        if source is not None:
            if isinstance(source, bytes):
                data = source
            elif isinstance(source, str):
                filename = source
            else:
                warnings.warn('Image element - source is not a valid type: {}'.format(type(source)), UserWarning)

        self.Filename = filename
        self.Data = data
        self.Widget = self.tktext_label = None  # type: tk.Label
        self.BackgroundColor = background_color
        if data is None and filename is None:
            self.Filename = ''
        self.EnableEvents = enable_events
        self.RightClickMenu = right_click_menu
        self.AnimatedFrames = None
        self.CurrentFrameNumber = 0
        self.TotalAnimatedFrames = 0
        self.LastFrameTime = 0
        self.ImageSubsample = subsample
        self.zoom = int(zoom) if zoom is not None else None
        self.frame_num = 0
        self.Source = filename if filename is not None else data
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        super().__init__(ELEM_TYPE_IMAGE, size=sz, background_color=background_color, pad=pad, key=key,
                         tooltip=tooltip, visible=visible, metadata=metadata)
        return

    def update(self, source=None, filename=None, data=None, size=(None, None), subsample=None, zoom=None, visible=None):
        """Changes some of the settings for the Image Element

        Must call `Window.Read` or `Window.Finalize` prior.
        To clear an image that's been displayed, call with NONE of the options set.  A blank update call will
        delete the previously shown image.

        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param source:   A filename or a base64 bytes. Will automatically detect the type and fill in filename or data for you.
        :type source:    str | bytes | None
        :param filename: filename to the new image to display.
        :type filename:  (str)
        :param data:     Base64 encoded string OR a tk.PhotoImage object
        :type data:      str | tkPhotoImage
        :param size:     (width, height) size of image in pixels
        :type size:      Tuple[int,int]
        :param subsample: amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type subsample: (int)
        :param zoom:     amount to increase the size of the image
        :type zoom:      (int)
        :param visible:  control visibility of element
        :type visible:   (bool)
        """

        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Image.update:\n- The window was closed')
            return

        if source is not None:
            if isinstance(source, bytes):
                data = source
            elif isinstance(source, str):
                filename = source
            else:
                warnings.warn('Image element - source is not a valid type: {}'.format(type(source)), UserWarning)

        image = None
        if filename is not None:
            try:
                image = tk.PhotoImage(file=filename)
                if subsample is not None:
                    image = image.subsample(subsample)
                if zoom is not None:
                    image = image.zoom(int(zoom))
            except Exception as e:
                _error_popup_with_traceback('Exception updating Image element', e)

        elif data is not None:
            # if type(data) is bytes:
            try:
                image = tk.PhotoImage(data=data)
                if subsample is not None:
                    image = image.subsample(subsample)
                if zoom is not None:
                    image = image.zoom(int(zoom))
            except Exception as e:
                image = data
                # return  # an error likely means the window has closed so exit

        if image is not None:
            self.tktext_label.configure(image='')  # clear previous image
            if self.tktext_label.image is not None:
                del self.tktext_label.image
            if type(image) is not bytes:
                width, height = size[0] if size[0] is not None else image.width(), size[1] if size[1] is not None else image.height()
            else:
                width, height = size
            try:  # sometimes crashes if user closed with X
                self.tktext_label.configure(image=image, width=width, height=height)
            except Exception as e:
                _error_popup_with_traceback('Exception updating Image element', e)
            self.tktext_label.image = image
        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()

        # if everything is set to None, then delete the image
        if filename is None and image is None and visible is None and size == (None, None):
            # Using a try because the image may have been previously deleted and don't want an error if that's happened
            try:
                self.tktext_label.configure(image='', width=1, height=1, bd=0)
                self.tktext_label.image = None
            except:
                pass

        if visible is not None:
            self._visible = visible

    def update_animation(self, source, time_between_frames=0):
        """Shows ans Animated GIF

        Call the function as often as you like.
        The function will determine when to show the next frame and will
        automatically advance to the next frame at the right time.

        NOTE: does NOT perform a sleep call to delay.

        :param source:              Filename or Base64 encoded string containing Animated GIF
        :type source:               str | bytes | None
        :param time_between_frames: Number of milliseconds to wait between showing frames
        :type time_between_frames:  (int)
        :return:                    True if worked OK, False if out of frames, None is window was closed
        :rtype:                     True | False | None
        """

        if self.Source != source:
            self.AnimatedFrames = None
            self.Source = source

        done = False
        if self.AnimatedFrames is None:
            self.TotalAnimatedFrames = 0
            self.AnimatedFrames = []
            # Load up to 1000 frames of animation.  stops when a bad frame is returns by tkinter
            for i in range(1000):
                if type(source) is not bytes:
                    try:
                        self.AnimatedFrames.append(tk.PhotoImage(file=source, format='gif -index %i' % (i)))
                    except Exception as e:
                        break
                else:
                    try:
                        self.AnimatedFrames.append(tk.PhotoImage(data=source, format='gif -index %i' % (i)))
                    except Exception as e:
                        break
            self.TotalAnimatedFrames = len(self.AnimatedFrames)
            self.LastFrameTime = time.time()
            self.CurrentFrameNumber = -1  # start at -1 because it is incremented before every frame is shown
        # show the frame

        now = time.time()

        if time_between_frames:
            if self.CurrentFrameNumber+1 == self.TotalAnimatedFrames:
                done = True
            if (now - self.LastFrameTime) * 1000 > time_between_frames:
                self.LastFrameTime = now
                self.CurrentFrameNumber = (self.CurrentFrameNumber + 1) % self.TotalAnimatedFrames
            else:  # don't reshow the frame again if not time for new frame
                return True
        else:
            self.CurrentFrameNumber = (self.CurrentFrameNumber + 1) % self.TotalAnimatedFrames
        image = self.AnimatedFrames[self.CurrentFrameNumber]
        try:  # needed in case the window was closed with an "X"
            self.tktext_label.configure(image=image, width=image.width(), heigh=image.height())
        except Exception as e:
            print('Exception in update_animation', e)
            done = None
        return not done

    def update_animation_no_buffering(self, source, time_between_frames=0):
        """Shows an Animated GIF

        Call the function as often as you like.
        The function will determine when to show the next frame and will
        automatically advance to the next frame at the right time.

        NOTE: does NOT perform a `sleep` call to delay

        :param source:              Filename or Base64 encoded string containing Animated GIF
        :type source:               str | bytes
        :param time_between_frames: Number of milliseconds to wait between showing frames
        :type time_between_frames:  (int)
        :return:                    True if worked OK, False if out of frames, None is window was closed
        :rtype:                     True | False | None
        """

        if self.Source != source:
            self.AnimatedFrames = None
            self.Source = source
            self.frame_num = 0

        now = time.time()

        if time_between_frames:
            if (now - self.LastFrameTime) * 1000 > time_between_frames:
                self.LastFrameTime = now
            else:  # don't reshow the frame again if not time for new frame
                return True

        # read a frame
        done = False
        while True:
            if type(source) is not bytes:
                try:
                    self.image = tk.PhotoImage(file=source, format='gif -index %i' % (self.frame_num))
                    self.frame_num += 1
                except Exception as e:
                    self.frame_num = 0
                    done = True
            else:
                try:
                    self.image = tk.PhotoImage(data=source, format='gif -index %i' % (self.frame_num))
                    self.frame_num += 1
                except:
                    self.frame_num = 0
                    done = True

            if self.frame_num:
                break

        try:  # needed in case the window was closed with an "X"
            self.tktext_label.configure(image=self.image, width=self.image.width(), heigh=self.image.height())
        except:
            done = None
        return not done

    Update = update
    UpdateAnimation = update_animation


Im = Image


# ---------------------------------------------------------------------- #
#                           Canvas                                       #
# ---------------------------------------------------------------------- #
class Canvas(Element):
    """Canvas drawing element"""
    def __init__(self, canvas=None, background_color=None, size=(None, None), s=(None, None), pad=None, p=None, key=None, k=None, tooltip=None,
                 right_click_menu=None, expand_x=False, expand_y=False, visible=True, border_width=0, metadata=None):
        """
        :param canvas:           Your own tk.Canvas if you already created it. Leave blank to create a Canvas
        :type canvas:            (tk.Canvas)
        :param background_color: color of background
        :type background_color:  (str)
        :param size:             (width in char, height in rows) size in pixels to make canvas
        :type size:              (int,int) | (None, None)
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None) | int
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:              Used with window.find_element and with return values to uniquely identify this element
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param tooltip:          text, that will appear when mouse hovers over the element
        :type tooltip:           (str)
        :param right_click_menu: A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:  List[List[ List[str] | str ]]
        :param expand_x:         If True the element will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param border_width:     width of border around element in pixels. Not normally used with Canvas element
        :type border_width:      (int)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """

        self.BackgroundColor = background_color if background_color is not None else DEFAULT_BACKGROUND_COLOR
        self._TKCanvas = self.Widget = canvas
        self.RightClickMenu = right_click_menu
        self.BorderWidth = border_width
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        super().__init__(ELEM_TYPE_CANVAS, background_color=background_color, size=sz, pad=pad, key=key,
                         tooltip=tooltip, visible=visible, metadata=metadata)
        return

    def update(self, background_color=None, visible=None):
        """
        :param background_color: color of background
        :type background_color:  (str)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        """
        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Canvas.update:\n- The window was closed')
            return

        if background_color not in (None, COLOR_SYSTEM_DEFAULT):
            self._TKCanvas.configure(background=background_color)
        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()
        if visible is not None:
            self._visible = visible

    @property
    def tk_canvas(self):
        """Returns the underlying tkiner Canvas widget

        :return: The tkinter canvas widget
        :rtype:  (tk.Canvas)
        """
        if self._TKCanvas is None:
            print('*** Did you forget to call Finalize()? Your code should look something like: ***')
            print('*** window = sg.Window("My Form", layout, finalize=True) ***')
        return self._TKCanvas

    TKCanvas = tk_canvas


# ---------------------------------------------------------------------- #
#                           Graph                                        #
# ---------------------------------------------------------------------- #
class Graph(Element):
    """Creates an area for you to draw on

    The __magical__ property this Element has is that you interact with it
    using your own coordinate system.
    **You** define where the location for (0,0) is.
    Want (0,0) to be in the middle of the graph like a math 4-quadrant graph?
    No problem!
    Set your lower left corner to be (-100,-100) and your upper right to be (100,100)
    and you've got yourself a graph with(0,0) at the center.

    You can also use float values. To do so, be sure and set the `float_values` parameter.
    Mouse click and drag events are possible and return the (x,y) coordinates of the mouse.
    Drawing primitives return an 'id' that is referenced when you want to operation on that item (e.g. to erase it).
    """
    def __init__(self, canvas_size, graph_bottom_left, graph_top_right, background_color=None, pad=None, p=None,
                 change_submits=False, drag_submits=False, enable_events=False, motion_events=False, key=None, k=None, tooltip=None,
                 right_click_menu=None, expand_x=False, expand_y=False, visible=True, float_values=False, border_width=0, metadata=None):
        """
        :param canvas_size:       size of the canvas area in pixels
        :type canvas_size:        (int, int)
        :param graph_bottom_left: (x,y) The bottoms left corner of your coordinate system
        :type graph_bottom_left:  (int, int)
        :param graph_top_right:   (x,y) The top right corner of  your coordinate system
        :type graph_top_right:    (int, int)
        :param background_color:  background color of the drawing area
        :type background_color:   (str)
        :param pad:               Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                 Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                  (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param change_submits:    * DEPRICATED DO NOT USE. Use `enable_events` instead
        :type change_submits:     (bool)
        :param drag_submits:      if True and Events are enabled for the Graph, will report Events any time the mouse moves while button down.  When the mouse button is released, you'll get an event = graph key + '+UP' (if key is a string.. if not a string, it'll be made into a tuple)
        :type drag_submits:       (bool)
        :param enable_events:     If True then clicks on the Graph are immediately reported as an event. Use this instead of change_submits
        :type enable_events:      (bool)
        :param motion_events:     If True then if no button is down and the mouse is moved, an event is generated with key = graph key + '+MOVE' (if key is a string, it not a string then a tuple is returned)
        :type motion_events:      (bool)
        :param key:               Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                str | int | tuple | object
        :param k:                 Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                  str | int | tuple | object
        :param tooltip:           text, that will appear when mouse hovers over the element
        :type tooltip:            (str)
        :param right_click_menu:  A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:   List[List[ List[str] | str ]]
        :param expand_x:          If True the element will automatically expand in the X direction to fill available space
        :type expand_x:           (bool)
        :param expand_y:          If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:           (bool)
        :param visible:           set visibility state of the element (Default = True)
        :type visible:            (bool)
        :param float_values:      If True x,y coordinates are returned as floats, not ints
        :type float_values:       (bool)
        :param border_width:      width of border around element in pixels. Not normally used for Graph Elements
        :type border_width:       (int)
        :param metadata:          User metadata that can be set to ANYTHING
        :type metadata:           (Any)
        """

        self.CanvasSize = canvas_size
        self.BottomLeft = graph_bottom_left
        self.TopRight = graph_top_right
        # self._TKCanvas = None               # type: tk.Canvas
        self._TKCanvas2 = self.Widget = None  # type: tk.Canvas
        self.ChangeSubmits = change_submits or enable_events
        self.DragSubmits = drag_submits
        self.ClickPosition = (None, None)
        self.MouseButtonDown = False
        self.Images = {}
        self.RightClickMenu = right_click_menu
        self.FloatValues = float_values
        self.BorderWidth = border_width
        key = key if key is not None else k
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y
        self.motion_events = motion_events

        super().__init__(ELEM_TYPE_GRAPH, background_color=background_color, size=canvas_size, pad=pad, key=key,
                         tooltip=tooltip, visible=visible, metadata=metadata)
        return

    def _convert_xy_to_canvas_xy(self, x_in, y_in):
        """NOTE: Not user callable function

        Used to convert user's coordinates into the ones used by tkinter
        :param x_in: The x coordinate to convert
        :type x_in:  int | float
        :param y_in: The y coordinate to convert
        :type y_in:  int | float
        :return:     (int, int) The converted canvas coordinates
        :rtype:      (int, int)
        """
        if None in (x_in, y_in):
            return None, None
        try:
            scale_x = (self.CanvasSize[0] - 0) / (self.TopRight[0] - self.BottomLeft[0])
            scale_y = (0 - self.CanvasSize[1]) / (self.TopRight[1] - self.BottomLeft[1])
        except:
            scale_x = scale_y = 0

        new_x = 0 + scale_x * (x_in - self.BottomLeft[0])
        new_y = self.CanvasSize[1] + scale_y * (y_in - self.BottomLeft[1])
        return new_x, new_y

    def _convert_canvas_xy_to_xy(self, x_in, y_in):
        """NOTE: Not user callable function

        Used to convert tkinter Canvas coords into user's coordinates

        :param x_in: The x coordinate in canvas coordinates
        :type x_in:  (int)
        :param y_in: (int) The y coordinate in canvas coordinates
        :type y_in:
        :return:     The converted USER coordinates
        :rtype:      (int, int) | Tuple[float, float]
        """
        if None in (x_in, y_in):
            return None, None
        scale_x = (self.CanvasSize[0] - 0) / (self.TopRight[0] - self.BottomLeft[0])
        scale_y = (0 - self.CanvasSize[1]) / (self.TopRight[1] - self.BottomLeft[1])

        new_x = x_in / scale_x + self.BottomLeft[0]
        new_y = (y_in - self.CanvasSize[1]) / scale_y + self.BottomLeft[1]
        if self.FloatValues:
            return new_x, new_y
        else:
            return floor(new_x), floor(new_y)

    def draw_line(self, point_from, point_to, color='black', width=1):
        """Draws a line from one point to another point using **user's** coordinates

        Can set the color and width of line.

        :param point_from: Starting point for line
        :type point_from:  (int, int) | Tuple[float, float]
        :param point_to:   Ending point for line
        :type point_to:    (int, int) | Tuple[float, float]
        :param color:      Color of the line
        :type color:       (str)
        :param width:      width of line in pixels
        :type width:       (int)
        :return:           id returned from tktiner or None if user closed the window. id is used when you
        :rtype:            int | None
        """
        if point_from == (None, None):
            return
        converted_point_from = self._convert_xy_to_canvas_xy(point_from[0], point_from[1])
        converted_point_to = self._convert_xy_to_canvas_xy(point_to[0], point_to[1])
        if self._TKCanvas2 is None:
            print('*** WARNING - The Graph element has not been finalized and cannot be drawn upon ***')
            print('Call Window.Finalize() prior to this operation')
            return None
        try:  # in case window was closed with an X
            id = self._TKCanvas2.create_line(converted_point_from, converted_point_to, width=width, fill=color)
        except:
            id = None
        return id

    def draw_lines(self, points, color='black', width=1):
        """Draws a series of lines given list of points

        :param points: list of points that define the polygon
        :type points:  List[(int, int) | Tuple[float, float]]
        :param color:  Color of the line
        :type color:   (str)
        :param width:  width of line in pixels
        :type width:   (int)
        :return:       id returned from tktiner or None if user closed the window. id is used when you
        :rtype:        int | None
        """
        converted_points = [self._convert_xy_to_canvas_xy(point[0], point[1]) for point in points]

        try:  # in case window was closed with an X
            id = self._TKCanvas2.create_line(*converted_points, width=width, fill=color)
        except:
            if self._TKCanvas2 is None:
                print('*** WARNING - The Graph element has not been finalized and cannot be drawn upon ***')
                print('Call Window.Finalize() prior to this operation')
            id = None
        return id

    def draw_point(self, point, size=2, color='black'):
        """Draws a 'dot' at the point you specify using the **user's** coordinate system

        :param point: Center location using USER'S coordinate system
        :type point:  (int, int) | Tuple[float, float]
        :param size:  Radius? (Or is it the diameter?) in user's coordinate values.
        :type size:   int | float
        :param color: color of the point to draw
        :type color:  (str)
        :return:      id returned from tkinter that you'll need if you want to manipulate the point
        :rtype:       int | None
        """
        if point == (None, None):
            return
        converted_point = self._convert_xy_to_canvas_xy(point[0], point[1])
        size_converted = self._convert_xy_to_canvas_xy(point[0] + size, point[1])
        size = size_converted[0] - converted_point[0]
        if self._TKCanvas2 is None:
            print('*** WARNING - The Graph element has not been finalized and cannot be drawn upon ***')
            print('Call Window.Finalize() prior to this operation')
            return None
        try:  # needed in case window was closed with an X
            point1 = converted_point[0] - size // 2, converted_point[1] - size // 2
            point2 = converted_point[0] + size // 2, converted_point[1] + size // 2
            id = self._TKCanvas2.create_oval(point1[0], point1[1],
                                             point2[0], point2[1],
                                             width=0,
                                             fill=color,
                                             outline=color)
        except:
            id = None
        return id

    def draw_circle(self, center_location, radius, fill_color=None, line_color='black', line_width=1):
        """Draws a circle, centered at the location provided

        Can set the fill and outline colors.

        :param center_location: Center location using **user's** coordinate system
        :type center_location:  (int, int) | Tuple[float, float]
        :param radius:          Radius in user's coordinate values.
        :type radius:           int | float
        :param fill_color:      color of the point to draw
        :type fill_color:       (str)
        :param line_color:      color of the outer line that goes around the circle (sorry, can't set thickness)
        :type line_color:       (str)
        :param line_width:      width of the line around the circle, the outline, in pixels
        :type line_width:       (int)
        :return:                id returned from tkinter that you'll need if you want to manipulate the circle
        :rtype:                 int | None
        """
        if center_location == (None, None):
            return
        converted_point = self._convert_xy_to_canvas_xy(center_location[0], center_location[1])
        radius_converted = self._convert_xy_to_canvas_xy(center_location[0] + radius, center_location[1])
        radius = radius_converted[0] - converted_point[0]
        # radius = radius_converted[1]-5
        if self._TKCanvas2 is None:
            print('*** WARNING - The Graph element has not been finalized and cannot be drawn upon ***')
            print('Call Window.Finalize() prior to this operation')
            return None
        # print('Oval parms', int(converted_point[0]) - int(radius), int(converted_point[1]) - int(radius),
        #                                      int(converted_point[0]) + int(radius), int(converted_point[1]) + int(radius))
        try:  # needed in case the window was closed with an X
            id = self._TKCanvas2.create_oval(int(converted_point[0]) - int(radius), int(converted_point[1]) - int(radius),
                                             int(converted_point[0]) + int(radius), int(converted_point[1]) + int(radius), fill=fill_color,
                                             outline=line_color, width=line_width)
        except:
            id = None
        return id

    def draw_oval(self, top_left, bottom_right, fill_color=None, line_color=None, line_width=1):
        """Draws an oval based on coordinates in user coordinate system

        Provide the location of a 'bounding rectangle'.

        :param top_left:     the top left point of bounding rectangle
        :type top_left:      (int, int) | Tuple[float, float]
        :param bottom_right: the bottom right point of bounding rectangle
        :type bottom_right:  (int, int) | Tuple[float, float]
        :param fill_color:   color of the interrior
        :type fill_color:    (str)
        :param line_color:   color of outline of oval
        :type line_color:    (str)
        :param line_width:   width of the line around the oval, the outline, in pixels
        :type line_width:    (int)
        :return:             id returned from tkinter that you'll need if you want to manipulate the oval
        :rtype:              int | None
        """
        converted_top_left = self._convert_xy_to_canvas_xy(top_left[0], top_left[1])
        converted_bottom_right = self._convert_xy_to_canvas_xy(bottom_right[0], bottom_right[1])
        if self._TKCanvas2 is None:
            print('*** WARNING - The Graph element has not been finalized and cannot be drawn upon ***')
            print('Call Window.Finalize() prior to this operation')
            return None
        try:  # in case windows close with X
            id = self._TKCanvas2.create_oval(converted_top_left[0], converted_top_left[1], converted_bottom_right[0],
                                             converted_bottom_right[1], fill=fill_color, outline=line_color, width=line_width)
        except:
            id = None

        return id

    def draw_arc(self, top_left, bottom_right, extent, start_angle, style=None, arc_color='black', line_width=1, fill_color=None):
        """Draws different types of arcs.

        Uses a 'bounding rectangle' to define location
        :param top_left:     the top left point of bounding rectangle
        :type top_left:      (int, int) | Tuple[float, float]
        :param bottom_right: the bottom right point of bounding rectangle
        :type bottom_right:  (int, int) | Tuple[float, float]
        :param extent:       Andle to end drawing. Used in conjunction with start_angle
        :type extent:        (float)
        :param start_angle:  Angle to begin drawing. Used in conjunction with extent
        :type start_angle:   (float)
        :param style:        Valid choices are One of these Style strings- 'pieslice', 'chord', 'arc', 'first', 'last', 'butt', 'projecting', 'round', 'bevel', 'miter'
        :type style:         (str)
        :param arc_color:    color to draw arc with
        :type arc_color:     (str)
        :param fill_color:   color to fill the area
        :type fill_color:    (str)
        :return:             id returned from tkinter that you'll need if you want to manipulate the arc
        :rtype:              int | None
        """
        converted_top_left = self._convert_xy_to_canvas_xy(top_left[0], top_left[1])
        converted_bottom_right = self._convert_xy_to_canvas_xy(bottom_right[0], bottom_right[1])
        tkstyle = tk.PIESLICE if style is None else style
        if self._TKCanvas2 is None:
            print('*** WARNING - The Graph element has not been finalized and cannot be drawn upon ***')
            print('Call Window.Finalize() prior to this operation')
            return None
        try:  # in case closed with X
            id = self._TKCanvas2.create_arc(converted_top_left[0], converted_top_left[1], converted_bottom_right[0],
                                            converted_bottom_right[1], extent=extent, start=start_angle, style=tkstyle,
                                            outline=arc_color, width=line_width, fill=fill_color)
        except Exception as e:
            print('Error encountered drawing arc.', e)
            id = None
        return id

    def draw_rectangle(self, top_left, bottom_right, fill_color=None, line_color=None, line_width=None):
        """Draws a rectangle given 2 points

        Can control the line and fill colors.

        :param top_left:     the top left point of rectangle
        :type top_left:      (int, int) | Tuple[float, float]
        :param bottom_right: the bottom right point of rectangle
        :type bottom_right:  (int, int) | Tuple[float, float]
        :param fill_color:   color of the interior
        :type fill_color:    (str)
        :param line_color:   color of outline
        :type line_color:    (str)
        :param line_width:   width of the line in pixels
        :type line_width:    (int)
        :return:             int | None id returned from tkinter that you'll need if you want to manipulate the rectangle
        :rtype:              int | None
        """

        converted_top_left = self._convert_xy_to_canvas_xy(top_left[0], top_left[1])
        converted_bottom_right = self._convert_xy_to_canvas_xy(bottom_right[0], bottom_right[1])
        if self._TKCanvas2 is None:
            print('*** WARNING - The Graph element has not been finalized and cannot be drawn upon ***')
            print('Call Window.Finalize() prior to this operation')
            return None
        if line_width is None:
            line_width = 1
        try:  # in case closed with X
            id = self._TKCanvas2.create_rectangle(converted_top_left[0], converted_top_left[1],
                                                  converted_bottom_right[0],
                                                  converted_bottom_right[1], fill=fill_color, outline=line_color, width=line_width)
        except:
            id = None
        return id

    def draw_polygon(self, points, fill_color=None, line_color=None, line_width=None):
        """Draws a polygon given list of its points

        :param points:     list of points that define the polygon
        :type points:      List[(int, int) | Tuple[float, float]]
        :param fill_color: color of the interior
        :type fill_color:  (str)
        :param line_color: color of outline
        :type line_color:  (str)
        :param line_width: width of the line in pixels
        :type line_width:  (int)
        :return:           id returned from tkinter that you'll need if you want to manipulate the rectangle
        :rtype:            int | None
        """

        converted_points = [self._convert_xy_to_canvas_xy(point[0], point[1]) for point in points]
        if self._TKCanvas2 is None:
            print('*** WARNING - The Graph element has not been finalized and cannot be drawn upon ***')
            print('Call Window.Finalize() prior to this operation')
            return None
        try:  # in case closed with X
            id = self._TKCanvas2.create_polygon(converted_points, fill=fill_color, outline=line_color, width=line_width)
        except:
            id = None
        return id

    def draw_text(self, text, location, color='black', font=None, angle=0, text_location=TEXT_LOCATION_CENTER):
        """Draws some text on your graph

        This is how you label graph number lines for example.

        :param text:          text to display
        :type text:           (Any)
        :param location:      location to place first letter
        :type location:       (int, int) | Tuple[float, float]
        :param color:         text color
        :type color:          (str)
        :param font:          specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:           (str or (str, int[, str]) or None)
        :param angle:         Angle 0 to 360 to draw the text.  Zero represents horizontal text
        :type angle:          (float)
        :param text_location: "anchor" location for the text. Values start with TEXT_LOCATION_
        :type text_location:  (enum)
        :return:              id returned from tkinter that you'll need if you want to manipulate the text
        :rtype:               int | None
        """
        text = str(text)
        if location == (None, None):
            return
        converted_point = self._convert_xy_to_canvas_xy(location[0], location[1])
        if self._TKCanvas2 is None:
            print('*** WARNING - The Graph element has not been finalized and cannot be drawn upon ***')
            print('Call Window.Finalize() prior to this operation')
            return None
        try:  # in case closed with X
            id = self._TKCanvas2.create_text(converted_point[0], converted_point[1], text=text, font=font, fill=color, angle=angle, anchor=text_location)
        except:
            id = None
        return id

    def draw_image(self, filename=None, data=None, location=(None, None)):
        """Places an image onto your canvas

        :param filename: if image is in a file, path and filename for the image. (GIF or PNG only!)
        :type filename:  (str)
        :param data:     if image is in Base64 format or raw? format then use instead of filename
        :type data:      str | bytes
        :param location: the (x,y) location to place image's top left corner
        :type location:  (int, int) | Tuple[float, float]
        :return:         id returned from tkinter that you'll need if you want to manipulate the image
        :rtype:          int | None
        """
        if location == (None, None):
            return
        if filename is not None:
            image = tk.PhotoImage(file=filename)
        elif data is not None:
            # if type(data) is bytes:
            try:
                image = tk.PhotoImage(data=data)
            except:
                return None  # an error likely means the window has closed so exit
        converted_point = self._convert_xy_to_canvas_xy(location[0], location[1])
        if self._TKCanvas2 is None:
            print('*** WARNING - The Graph element has not been finalized and cannot be drawn upon ***')
            print('Call Window.Finalize() prior to this operation')
            return None
        try:  # in case closed with X
            id = self._TKCanvas2.create_image(converted_point, image=image, anchor=tk.NW)
            self.Images[id] = image
        except:
            id = None
        return id

    def erase(self):
        """Erases the graph

        Removes all figures previously drawn using the `Graph` methods (e.g. `DrawText`).
        """
        if self._TKCanvas2 is None:
            print('*** WARNING - The Graph element has not been finalized and cannot be drawn upon ***')
            print('Call Window.Finalize() prior to this operation')
            return None
        self.Images = {}
        try:  # in case window was closed with X
            self._TKCanvas2.delete('all')
        except:
            pass

    def delete_figure(self, id):
        """Removes from the `Graph` the figure represented by id

        The 'id' is given to you anytime you call a drawing primitive.

        :param id: the id returned to you when calling one of the drawing methods
        :type id:  (int)
        """
        try:
            self._TKCanvas2.delete(id)
        except:
            print('DeleteFigure - bad ID {}'.format(id))
        try:
            del self.Images[id]  # in case was an image. If wasn't an image, then will get exception
        except:
            pass

    def update(self, background_color=None, visible=None):
        """Changes some of the settings for the Graph Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param background_color: color of background
        :type background_color:  ???
        :param visible:          control visibility of element
        :type visible:           (bool)
        """
        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Graph.update:\n- The window was closed')
            return

        if background_color is not None and background_color != COLOR_SYSTEM_DEFAULT:
            self._TKCanvas2.configure(background=background_color)

        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()

        if visible is not None:
            self._visible = visible

    def move(self, x_direction, y_direction):
        """Moves the entire drawing area (the canvas) by some delta from the current position

        Units are indicated in your coordinate system indicate number of ticks in it.

        :param x_direction: how far to move in the "X" direction in your coordinates
        :type x_direction:  int | float
        :param y_direction: how far to move in the "Y" direction in your coordinates
        :type y_direction:  int | float
        """
        zero_converted = self._convert_xy_to_canvas_xy(0, 0)
        shift_converted = self._convert_xy_to_canvas_xy(x_direction, y_direction)
        shift_amount = (shift_converted[0] - zero_converted[0], shift_converted[1] - zero_converted[1])
        if self._TKCanvas2 is None:
            print('*** WARNING - The Graph element has not been finalized and cannot be drawn upon ***')
            print('Call Window.Finalize() prior to this operation')
            return None
        self._TKCanvas2.move('all', shift_amount[0], shift_amount[1])

    def move_figure(self, figure, x_direction, y_direction):
        """Moves a previously drawn figure using a `delta` from current position

        :param figure:      Previously obtained figure-id. These are returned from all Draw methods
        :type figure:       (id)
        :param x_direction: delta to apply to position in the X direction
        :type x_direction:  int | float
        :param y_direction: delta to apply to position in the Y direction
        :type y_direction:  int | float
        """
        zero_converted = self._convert_xy_to_canvas_xy(0, 0)
        shift_converted = self._convert_xy_to_canvas_xy(x_direction, y_direction)
        shift_amount = (shift_converted[0] - zero_converted[0], shift_converted[1] - zero_converted[1])
        if figure is None:
            print('* move_figure warning - your figure is None *')
            return None
        self._TKCanvas2.move(figure, shift_amount[0], shift_amount[1])

    def relocate_figure(self, figure, x, y):
        """Moves a previously made figure to an arbitrary (x,y) location

        This differs from the `Move` methods because it uses absolute coordinates versus relative for that method.

        :param figure: Previously obtained figure-id. These are returned from all Draw methods
        :type figure:  (id)
        :param x:      location on X axis (in user coords) to move the upper left corner of the figure
        :type x:       int | float
        :param y:      location on Y axis (in user coords) to move the upper left corner of the figure
        :type y:       int | float
        """

        zero_converted = self._convert_xy_to_canvas_xy(0, 0)
        shift_converted = self._convert_xy_to_canvas_xy(x, y)
        shift_amount = (shift_converted[0] - zero_converted[0], shift_converted[1] - zero_converted[1])
        if figure is None:
            print('*** WARNING - Your figure is None. It most likely means your did not Finalize your Window ***')
            print('Call Window.Finalize() prior to all graph operations')
            return None
        xy = self._TKCanvas2.coords(figure)
        self._TKCanvas2.move(figure, shift_converted[0] - xy[0], shift_converted[1] - xy[1])

    def send_figure_to_back(self, figure):
        """Changes Z-order of figures on the Graph

        Sends the indicated figure to the back of all other drawn figures.

        :param figure: value returned by tkinter when creating the figure / drawing
        :type figure:  (int)
        """
        self.TKCanvas.tag_lower(figure)  # move figure to the "bottom" of all other figure

    def bring_figure_to_front(self, figure):
        """Changes Z-order of figures on the Graph

        Brings the indicated figure to the front of all other drawn figures.

        :param figure: value returned by tkinter when creating the figure / drawing
        :type figure:  (int)
        """
        self.TKCanvas.tag_raise(figure)  # move figure to the "top" of all other figures

    def get_figures_at_location(self, location):
        """Returns a list of figures located at a particular x,y location within the `Graph`

        :param location: point to check
        :type location:  (int, int) | Tuple[float, float]
        :return:         a list of previously drawn "Figures" (returned from the drawing primitives)
        :rtype:          List[int]
        """
        x, y = self._convert_xy_to_canvas_xy(location[0], location[1])
        ids = self.TKCanvas.find_overlapping(x, y, x, y)
        return ids

    def get_bounding_box(self, figure):
        """Given a figure, returns the upper left and lower right bounding box coordinates

        :param figure: a previously drawing figure
        :type figure:  object
        :return:       upper left x, upper left y, lower right x, lower right y
        :rtype:        Tuple[int, int, int, int] | Tuple[float, float, float, float]
        """
        box = self.TKCanvas.bbox(figure)
        top_left = self._convert_canvas_xy_to_xy(box[0], box[1])
        bottom_right = self._convert_canvas_xy_to_xy(box[2], box[3])
        return top_left, bottom_right

    def change_coordinates(self, graph_bottom_left, graph_top_right):
        """Changes the corrdinate system to a new one

        The same 2 points in space are used to define the coordinate
        system - the bottom left and the top right values of your graph.

        :param graph_bottom_left: The bottoms left corner of your coordinate system
        :type graph_bottom_left:  (int, int) (x,y)
        :param graph_top_right:   The top right corner of  your coordinate system
        :type graph_top_right:    (int, int)  (x,y)
        """
        self.BottomLeft = graph_bottom_left
        self.TopRight = graph_top_right

    @property
    def tk_canvas(self):
        """Returns the underlying tkiner Canvas widget

        :return: The tkinter canvas widget
        :rtype:  (tk.Canvas)
        """
        if self._TKCanvas2 is None:
            print('*** Did you forget to call Finalize()? Your code should look something like: ***')
            print('*** form = sg.Window("My Form").Layout(layout).Finalize() ***')
        return self._TKCanvas2

    # button release callback
    def button_release_call_back(self, event):
        """NOTE: Not a user callable method

        Used to get Graph click events.
        Called by tkinter when button is released.

        :param event: (event) event info from tkinter. Note not used in this method
        :type event:
        """
        if not self.DragSubmits:
            return  # only report mouse up for drag operations
        self.ClickPosition = self._convert_canvas_xy_to_xy(event.x, event.y)
        self.ParentForm.LastButtonClickedWasRealtime = False
        if self.Key is not None:
            self.ParentForm.LastButtonClicked = self.Key
        else:
            self.ParentForm.LastButtonClicked = '__GRAPH__'  # need to put something rather than None
        _exit_mainloop(self.ParentForm)
        if isinstance(self.ParentForm.LastButtonClicked, str):
            self.ParentForm.LastButtonClicked = self.ParentForm.LastButtonClicked + '+UP'
        else:
            self.ParentForm.LastButtonClicked = (self.ParentForm.LastButtonClicked, '+UP')
        self.MouseButtonDown = False

    # button callback
    def button_press_call_back(self, event):
        """NOTE: Not a user callable method

        Used to get Graph click events.
        Called by tkinter when button is released

        :param event: (event) event info from tkinter. Contains the x and y coordinates of a click
        :type event:
        """

        self.ClickPosition = self._convert_canvas_xy_to_xy(event.x, event.y)
        self.ParentForm.LastButtonClickedWasRealtime = self.DragSubmits
        if self.Key is not None:
            self.ParentForm.LastButtonClicked = self.Key
        else:
            self.ParentForm.LastButtonClicked = '__GRAPH__'  # need to put something rather than None
        # if self.ParentForm.CurrentlyRunningMainloop:
        #     self.ParentForm.TKroot.quit()  # kick out of loop if read was called
        _exit_mainloop(self.ParentForm)
        self.MouseButtonDown = True

    def _update_position_for_returned_values(self, event):
        """NOTE: Not called by the user

        Updates the variable that's used when the values dictionary is returned from a window read.
        It's called from another method/function that tkinter called back.

        :param event: (event) event info from tkinter. Contains the x and y coordinates of a click
        :type event:
        """
        """
        Updates the variable that's used when the values dictionary is returned from a window read.

        Not called by the user.  It's called from another method/function that tkinter calledback

        :param event: (event) event info from tkinter. Contains the x and y coordinates of a click
        :type event:
        """

        self.ClickPosition = self._convert_canvas_xy_to_xy(event.x, event.y)

    # button callback
    def motion_call_back(self, event):
        """NOTE: Not a user callable method

        Used to get Graph mouse motion events.
        Called by tkinter when mouse moved.

        :param event: (event) event info from tkinter. Contains the x and y coordinates of a mouse
        :type event:
        """

        if not self.MouseButtonDown and not self.motion_events:
            return
        self.ClickPosition = self._convert_canvas_xy_to_xy(event.x, event.y)
        self.ParentForm.LastButtonClickedWasRealtime = self.DragSubmits
        if self.Key is not None:
            self.ParentForm.LastButtonClicked = self.Key
        else:
            self.ParentForm.LastButtonClicked = '__GRAPH__'  # need to put something rather than None
        # if self.ParentForm.CurrentlyRunningMainloop:
        #     self.ParentForm.TKroot.quit()  # kick out of loop if read was called
        if self.motion_events and not self.MouseButtonDown:
            if isinstance(self.ParentForm.LastButtonClicked, str):
                self.ParentForm.LastButtonClicked = self.ParentForm.LastButtonClicked + '+MOVE'
            else:
                self.ParentForm.LastButtonClicked = (self.ParentForm.LastButtonClicked, '+MOVE')
        _exit_mainloop(self.ParentForm)

    BringFigureToFront = bring_figure_to_front
    ButtonPressCallBack = button_press_call_back
    ButtonReleaseCallBack = button_release_call_back
    DeleteFigure = delete_figure
    DrawArc = draw_arc
    DrawCircle = draw_circle
    DrawImage = draw_image
    DrawLine = draw_line
    DrawOval = draw_oval
    DrawPoint = draw_point
    DrawPolygon = draw_polygon
    DrawLines = draw_lines
    DrawRectangle = draw_rectangle
    DrawText = draw_text
    GetFiguresAtLocation = get_figures_at_location
    GetBoundingBox = get_bounding_box
    Erase = erase
    MotionCallBack = motion_call_back
    Move = move
    MoveFigure = move_figure
    RelocateFigure = relocate_figure
    SendFigureToBack = send_figure_to_back
    TKCanvas = tk_canvas
    Update = update


G = Graph


# ---------------------------------------------------------------------- #
#                           Frame                                        #
# ---------------------------------------------------------------------- #
class Frame(Element):
    """A Frame Element that contains other Elements

    Encloses with a line around elements and a text label.
    """
    def __init__(self, title, layout, title_color=None, background_color=None, title_location=None,
                 relief=DEFAULT_FRAME_RELIEF, size=(None, None), s=(None, None), font=None, pad=None, p=None, border_width=None, key=None, k=None,
                 tooltip=None, right_click_menu=None, expand_x=False, expand_y=False, grab=None, visible=True, element_justification='left', vertical_alignment=None,
                 metadata=None):
        """
        :param title:                 text that is displayed as the Frame's "label" or title
        :type title:                  (str)
        :param layout:                The layout to put inside the Frame
        :type layout:                 List[List[Elements]]
        :param title_color:           color of the title text
        :type title_color:            (str)
        :param background_color:      background color of the Frame
        :type background_color:       (str)
        :param title_location:        location to place the text title.  Choices include: TITLE_LOCATION_TOP TITLE_LOCATION_BOTTOM TITLE_LOCATION_LEFT TITLE_LOCATION_RIGHT TITLE_LOCATION_TOP_LEFT TITLE_LOCATION_TOP_RIGHT TITLE_LOCATION_BOTTOM_LEFT TITLE_LOCATION_BOTTOM_RIGHT
        :type title_location:         (enum)
        :param relief:                relief style. Values are same as other elements with reliefs. Choices include RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID
        :type relief:                 (enum)
        :param size:                  (width, height) Sets an initial hard-coded size for the Frame. This used to be a problem, but was fixed in 4.53.0 and works better than Columns when using the size paramter
        :type size:                   (int, int)
        :param s:                     Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                      (int, int)  | (None, None) | int
        :param font:                  specifies the  font family, size, etc. for the TITLE. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                   (str or (str, int[, str]) or None)
        :param pad:                   Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                     Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param border_width:          width of border around element in pixels
        :type border_width:           (int)
        :param key:                   Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                    str | int | tuple | object
        :param k:                     Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                      str | int | tuple | object
        :param tooltip:               text, that will appear when mouse hovers over the element
        :type tooltip:                (str)
        :param right_click_menu:      A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:       List[List[ List[str] | str ]]
        :param expand_x:              If True the element will automatically expand in the X direction to fill available space
        :type expand_x:               (bool)
        :param expand_y:              If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:               (bool)
        :param grab:                  If True can grab this element and move the window around. Default is False
        :type grab:                   (bool)
        :param visible:               set visibility state of the element
        :type visible:                (bool)
        :param element_justification: All elements inside the Frame will have this justification 'left', 'right', 'center' are valid values
        :type element_justification:  (str)
        :param vertical_alignment:    Place the Frame at the 'top', 'center', 'bottom' of the row (can also use t,c,r). Defaults to no setting (tkinter decides)
        :type vertical_alignment:     (str)
        :param metadata:              User metadata that can be set to ANYTHING
        :type metadata:               (Any)
        """

        self.UseDictionary = False
        self.ReturnValues = None
        self.ReturnValuesList = []
        self.ReturnValuesDictionary = {}
        self.DictionaryKeyCounter = 0
        self.ParentWindow = None
        self.Rows = []
        # self.ParentForm = None
        self.TKFrame = None
        self.Title = title
        self.Relief = relief
        self.TitleLocation = title_location
        self.BorderWidth = border_width
        self.BackgroundColor = background_color if background_color is not None else DEFAULT_BACKGROUND_COLOR
        self.RightClickMenu = right_click_menu
        self.ContainerElemementNumber = Window._GetAContainerNumber()
        self.ElementJustification = element_justification
        self.VerticalAlignment = vertical_alignment
        self.Widget = None  # type: tk.LabelFrame
        self.Grab = grab
        self.Layout(layout)
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        super().__init__(ELEM_TYPE_FRAME, background_color=background_color, text_color=title_color, size=sz,
                         font=font, pad=pad, key=key, tooltip=tooltip, visible=visible, metadata=metadata)
        return

    def add_row(self, *args):
        """NOTE: Not recommended user call

        Used to add rows of Elements to the Frame Element.

        :param *args: The list of elements for this row
        :type *args:  List[Element]
        """
        NumRows = len(self.Rows)  # number of existing rows is our row number
        CurrentRowNumber = NumRows  # this row's number
        CurrentRow = []  # start with a blank row and build up
        # -------------------------  Add the elements to a row  ------------------------- #
        for i, element in enumerate(args):  # Loop through list of elements and add them to the row
            if isinstance(element, tuple) or isinstance(element, list):
                self.add_row(*element)
                continue

            if type(element) == list:
                PopupError('Error creating Frame layout',
                           'Layout has a LIST instead of an ELEMENT',
                           'This sometimes means you have a badly placed ]',
                           'The offensive list is:',
                           element,
                           'This list will be stripped from your layout',
                           keep_on_top=True
                           )
                continue
            elif callable(element) and not isinstance(element, Element):
                PopupError('Error creating Frame layout',
                           'Layout has a FUNCTION instead of an ELEMENT',
                           'This likely means you are missing () from your layout',
                           'The offensive list is:',
                           element,
                           'This item will be stripped from your layout',
                           keep_on_top=True)
                continue
            if element.ParentContainer is not None:
                warnings.warn(
                    '*** YOU ARE ATTEMPTING TO REUSE AN ELEMENT IN YOUR LAYOUT!\n    Once placed in a layout, an element cannot be used in another. ***',
                    UserWarning)
                _error_popup_with_traceback('Error creating Frame layout',
                                            'The layout specified has already been used',
                                            'You MUST start witha "clean", unused layout every time you create a window',
                                            'The erroneous Element = ',
                                            element,
                                            'and has a key = ', element.Key,
                                            'This item will be stripped from your layout',
                                            'Hint - try printing your layout and matching the IDs "print(layout)"',
                                            )
                continue
            element.Position = (CurrentRowNumber, i)
            element.ParentContainer = self
            CurrentRow.append(element)
            if element.Key is not None:
                self.UseDictionary = True
        # -------------------------  Append the row to list of Rows  ------------------------- #
        self.Rows.append(CurrentRow)

    def layout(self, rows):
        """Can use like the `Window.Layout` method

        But it's better to use the layout parameter when creating.

        :param rows: The rows of Elements
        :type rows:  List[List[Element]]
        :return:     Used for chaining
        :rtype:      (Frame)
        """

        for row in rows:
            try:
                iter(row)
            except TypeError:
                PopupError('Error creating Frame layout',
                           'Your row is not an iterable (e.g. a list)',
                           'Instead of a list, the type found was {}'.format(type(row)),
                           'The erroneous row = ',
                           row,
                           'This item will be stripped from your layout', keep_on_top=True, image=_random_error_emoji())
                continue
            self.AddRow(*row)
        return self

    def _GetElementAtLocation(self, location):
        """NOTE: Not user callable method

        Used to find the Element at a row, col position within the layout.

        :param location: (row, column) position of the element to find in layout
        :type location:  (int, int)
        :return:         (Element) The element found at the location
        :rtype:          (Element)
        """

        (row_num, col_num) = location
        row = self.Rows[row_num]
        element = row[col_num]
        return element

    def update(self, value=None, visible=None):
        """Changes some of the settings for the Frame Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param value:   New text value (Title) to show on frame
        :type value:    (Any)
        :param visible: control visibility of element
        :type visible:  (bool)
        """
        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Frame.update:\n- The window was closed')
            return

        if visible is False:
            self._pack_forget_save_settings()
            # self.TKFrame.pack_forget()
        elif visible is True:
            self._pack_restore_settings()
            # self.TKFrame.pack(padx=self.pad_used[0], pady=self.pad_used[1])
        if value is not None:
            self.TKFrame.config(text=str(value))
        if visible is not None:
            self._visible = visible

    AddRow = add_row
    Layout = layout
    Update = update


Fr = Frame


# ---------------------------------------------------------------------- #
#                           Vertical Separator                           #
# ---------------------------------------------------------------------- #
class VerticalSeparator(Element):
    """Vertical Separator Element

    Draws a vertical line at the given location. It will span 1 row.
    Usually paired with Column Element if extra height is needed.
    """
    def __init__(self, color=None, pad=None, p=None, key=None, k=None):
        """
        :param color: Color of the line. Defaults to theme's text color. Can be name or #RRGGBB format
        :type color:  (str)
        :param pad:   Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:     Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:   Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:    str | int | tuple | object
        :param k:     Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:      str | int | tuple | object
        """
        key = key if key is not None else k
        pad = pad if pad is not None else p
        self.expand_x = None
        self.expand_y = None
        self.Orientation = 'vertical'  # for now only vertical works
        self.color = color if color is not None else theme_text_color()
        super().__init__(ELEM_TYPE_SEPARATOR, pad=pad, key=key)


VSeperator = VerticalSeparator
VSeparator = VerticalSeparator
VSep = VerticalSeparator


# ---------------------------------------------------------------------- #
#                           Horizontal Separator                           #
# ---------------------------------------------------------------------- #
class HorizontalSeparator(Element):
    """Horizontal Separator Element

    Draws a Horizontal line at the given location.
    """
    def __init__(self, color=None, pad=None, p=None, key=None, k=None):
        """
        :param color: Color of the line. Defaults to theme's text color. Can be name or #RRGGBB format
        :type color:  (str)
        :param pad:   Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:     Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:   Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:    str | int | tuple | object
        :param k:     Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:      str | int | tuple | object
        """

        self.Orientation = 'horizontal'  # for now only vertical works
        self.color = color if color is not None else theme_text_color()
        self.expand_x = True
        self.expand_y = None
        key = key if key is not None else k
        pad = pad if pad is not None else p

        super().__init__(ELEM_TYPE_SEPARATOR, pad=pad, key=key)


HSeparator = HorizontalSeparator
HSep = HorizontalSeparator


# ---------------------------------------------------------------------- #
#                           Sizegrip                                     #
# ---------------------------------------------------------------------- #
class Sizegrip(Element):
    """Sizegrip element will be added to the bottom right corner of your window

        It should be placed on the last row of your window along with any other elements on that row.
        The color will match the theme's background color.
    """
    def __init__(self, background_color=None, pad=None, p=(0, 0), key=None, k=None):
        """
        Sizegrip Element
        :param background_color: color to use for the background of the grip
        :type background_color:  str
        :param pad:   Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:     Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:   Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:    str | int | tuple | object
        :param k:     Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:      str | int | tuple | object
        """

        bg = background_color if background_color is not None else theme_background_color()
        pad = pad if pad is not None else p
        key = key if key is not None else k

        super().__init__(ELEM_TYPE_SIZEGRIP, background_color=bg, key=key, pad=pad)


SGrip = Sizegrip


# ---------------------------------------------------------------------- #
#                           Tab                                          #
# ---------------------------------------------------------------------- #
class Tab(Element):
    """Tab Element is another container element that holds a layout and displays a tab with text

    Used with TabGroup only.
    Tabs are never placed directly into a layout, they are always'Contained' in a TabGroup layout.
    """
    def __init__(self, title, layout, title_color=None, background_color=None, font=None, pad=None, p=None, disabled=False,
                 border_width=None, key=None, k=None, tooltip=None, right_click_menu=None, expand_x=False, expand_y=False, visible=True, element_justification='left',
                 image_source=None, image_subsample=None, image_zoom=None, metadata=None):
        """
        :param title:                 text to show on the tab
        :type title:                  (str)
        :param layout:                The element layout that will be shown in the tab
        :type layout:                 List[List[Element]]
        :param title_color:           color of the tab text (note not currently working on tkinter)
        :type title_color:            (str)
        :param background_color:      color of background of the entire layout
        :type background_color:       (str)
        :param font:                  NOT USED in the tkinter port
        :type font:                   (str or (str, int[, str]) or None)
        :param pad:                   Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                    (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                     Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param disabled:              If True button will be created disabled
        :type disabled:               (bool)
        :param border_width:          NOT USED in tkinter port
        :type border_width:           (int)
        :param key:                   Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                    str | int | tuple | object
        :param k:                     Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                      str | int | tuple | object
        :param tooltip:               text, that will appear when mouse hovers over the element
        :type tooltip:                (str)
        :param right_click_menu:      A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:       List[List[ List[str] | str ]]
        :param expand_x:              If True the element will automatically expand in the X direction to fill available space
        :type expand_x:               (bool)
        :param expand_y:              If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:               (bool)
        :param visible:               set visibility state of the element
        :type visible:                (bool)
        :param element_justification: All elements inside the Tab will have this justification 'left', 'right', 'center' are valid values
        :type element_justification:  (str)
        :param image_source:          A filename or a base64 bytes of an image to place on the Tab
        :type image_source:            str | bytes | None
        :param image_subsample:       amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
        :type image_subsample:        (int)
        :param image_zoom:            amount to increase the size of the image. 2=twice size, 3=3 times, etc
        :type image_zoom:             (int)
        :param metadata:              User metadata that can be set to ANYTHING
        :type metadata:               (Any)
        """

        filename = data = None
        if image_source is not None:
            if isinstance(image_source, bytes):
                data = image_source
            elif isinstance(image_source, str):
                filename = image_source
            else:
                warnings.warn('Image element - source is not a valid type: {}'.format(type(image_source)), UserWarning)

        self.Filename = filename
        self.Data = data
        self.ImageSubsample = image_subsample
        self.zoom = int(image_zoom) if image_zoom is not None else None
        self.UseDictionary = False
        self.ReturnValues = None
        self.ReturnValuesList = []
        self.ReturnValuesDictionary = {}
        self.DictionaryKeyCounter = 0
        self.ParentWindow = None
        self.Rows = []
        self.TKFrame = None
        self.Widget = None  # type: tk.Frame
        self.Title = title
        self.BorderWidth = border_width
        self.Disabled = disabled
        self.ParentNotebook = None
        self.TabID = None
        self.BackgroundColor = background_color if background_color is not None else DEFAULT_BACKGROUND_COLOR
        self.RightClickMenu = right_click_menu
        self.ContainerElemementNumber = Window._GetAContainerNumber()
        self.ElementJustification = element_justification
        key = key if key is not None else k
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        self.Layout(layout)

        super().__init__(ELEM_TYPE_TAB, background_color=background_color, text_color=title_color, font=font, pad=pad, key=key, tooltip=tooltip,
                         visible=visible, metadata=metadata)
        return

    def add_row(self, *args):
        """NOTE: Not recommended user call

        Used to add rows of Elements to the Frame Element.

        :param *args: The list of elements for this row
        :type *args:  List[Element]
        """
        NumRows = len(self.Rows)  # number of existing rows is our row number
        CurrentRowNumber = NumRows  # this row's number
        CurrentRow = []  # start with a blank row and build up
        # -------------------------  Add the elements to a row  ------------------------- #
        for i, element in enumerate(args):  # Loop through list of elements and add them to the row
            if type(element) == list:
                popup_error_with_traceback('Error creating Tab layout',
                           'Layout has a LIST instead of an ELEMENT',
                           'This sometimes means you have a badly placed ]',
                           'The erroneous list is:',
                           element,
                           'This list will be stripped from your layout')
                continue
            elif callable(element) and not isinstance(element, Element):
                popup_error_with_traceback('Error creating Tab layout',
                           'Layout has a FUNCTION instead of an ELEMENT',
                           'This likely means you are missing () from your layout',
                           'The erroneous list is:',
                           element,
                           'This item will be stripped from your layout')
                continue
            if element.ParentContainer is not None:
                warnings.warn(
                    '*** YOU ARE ATTEMPTING TO REUSE AN ELEMENT IN YOUR LAYOUT! Once placed in a layout, an element cannot be used in another layout. ***',
                    UserWarning)
                popup_error_with_traceback('Error creating Tab layout',
                           'The layout specified has already been used',
                           'You MUST start witha "clean", unused layout every time you create a window',
                           'The erroneous Element = ',
                           element,
                           'and has a key = ', element.Key,
                           'This item will be stripped from your layout',
                           'Hint - try printing your layout and matching the IDs "print(layout)"')
                continue
            element.Position = (CurrentRowNumber, i)
            element.ParentContainer = self
            CurrentRow.append(element)
            if element.Key is not None:
                self.UseDictionary = True
        # -------------------------  Append the row to list of Rows  ------------------------- #
        self.Rows.append(CurrentRow)

    def layout(self, rows):
        """NOTE: Not user callable method use layout parameter instead

        Creates the layout using the supplied rows of Elements.

        :param rows: List[List[Element]] The list of rows
        :type rows:  List[List[Element]]
        :return:     (Tab) used for chaining
        :rtype:
        """
        for row in rows:
            try:
                iter(row)
            except TypeError:
                PopupError('Error creating Tab layout',
                           'Your row is not an iterable (e.g. a list)',
                           'Instead of a list, the type found was {}'.format(type(row)),
                           'The erroneous row = ',
                           row,
                           'This item will be stripped from your layout', keep_on_top=True, image=_random_error_emoji())
                continue
            self.AddRow(*row)
        return self

    def update(self, title=None, disabled=None, visible=None):
        """Changes some of the settings for the Tab Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param title:    tab title
        :type title:     (str)
        :param disabled: disable or enable state of the element
        :type disabled:  (bool)
        :param visible:  control visibility of element
        :type visible:   (bool)
        """
        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Tab.update:\n- The window was closed')
            return

        state = 'normal'
        if disabled is not None:
            self.Disabled = disabled
            if disabled:
                state = 'disabled'
        if visible is False:
            state = 'hidden'
        if visible is not None:
            self._visible = visible

        self.ParentNotebook.tab(self.TabID, state=state)

        if title is not None:
            self.Title = str(title)
            self.ParentNotebook.tab(self.TabID, text=self.Title)
        return self

    def _GetElementAtLocation(self, location):
        """NOTE: Not user callable method

        Used to find the Element at a row, col position within the layout.
        :param location: (row, column) position of the element to find in layout
        :type location:  (int, int)
        :return:         The element found at the location
        :rtype:          (Element)
        """

        (row_num, col_num) = location
        row = self.Rows[row_num]
        element = row[col_num]
        return element

    def select(self):
        """Creates a tkinter event that mimics user clicking on a tab

        Must have called `window.Finalize` / `window.Read` first!
        """
        # Use a try in case the window has been destoyed
        try:
            self.ParentNotebook.select(self.TabID)
        except Exception as e:
            print('Exception Selecting Tab {}'.format(e))

    AddRow = add_row
    Layout = layout
    Select = select
    Update = update


# ---------------------------------------------------------------------- #
#                           TabGroup                                     #
# ---------------------------------------------------------------------- #
class TabGroup(Element):
    """TabGroup Element

    Groups together your tabs into the group of tabs you see displayed in your window.
    """
    def __init__(self, layout, tab_location=None, title_color=None, tab_background_color=None, selected_title_color=None, selected_background_color=None,
                 background_color=None, focus_color=None, font=None, change_submits=False, enable_events=False, pad=None, p=None, border_width=None, tab_border_width=None,
                 theme=None, key=None, k=None,
                 size=(None, None), s=(None, None), tooltip=None, right_click_menu=None, expand_x=False, expand_y=False, visible=True, metadata=None):
        """
        :param layout:                    Layout of Tabs. Different than normal layouts. ALL Tabs should be on first row
        :type layout:                     List[List[Tab]]
        :param tab_location:              location that tabs will be displayed. Choices are left, right, top, bottom, lefttop, leftbottom, righttop, rightbottom, bottomleft, bottomright, topleft, topright
        :type tab_location:               (str)
        :param title_color:               color of text on tabs
        :type title_color:                (str)
        :param tab_background_color:      color of all tabs that are not selected
        :type tab_background_color:       (str)
        :param selected_title_color:      color of tab text when it is selected
        :type selected_title_color:       (str)
        :param selected_background_color: color of tab when it is selected
        :type selected_background_color:  (str)
        :param background_color:          color of background area that tabs are located on
        :type background_color:           (str)
        :param focus_color:               color of focus indicator on the tabs
        :type focus_color:                (str)
        :param font:                      specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                       (str or (str, int[, str]) or None)
        :param change_submits:            * DEPRICATED DO NOT USE. Use `enable_events` instead
        :type change_submits:             (bool)
        :param enable_events:             If True then switching tabs will generate an Event
        :type enable_events:              (bool)
        :param pad:                       Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                        (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                         Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                          (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param border_width:              width of border around element in pixels
        :type border_width:               (int)
        :param tab_border_width:          width of border around the tabs
        :type tab_border_width:           (int)
        :param theme:                     DEPRICATED - You can only specify themes using set options or when window is created. It's not possible to do it on an element basis
        :type theme:                      (enum)
        :param key:                       Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                        str | int | tuple | object
        :param k:                         Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                          str | int | tuple | object
        :param size:                      (width, height) w=pixels-wide, h=pixels-high. Either item in tuple can be None to indicate use the computed value and set only 1 direction
        :type size:                       (int|None, int|None)
        :param s:                         Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                          (int|None, int|None)
        :param tooltip:                   text, that will appear when mouse hovers over the element
        :type tooltip:                    (str)
        :param right_click_menu:          A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:           List[List[ List[str] | str ]]
        :param expand_x:                  If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                   (bool)
        :param expand_y:                  If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                   (bool)
        :param visible:                   DEPRECATED  - Should you need to control visiblity for the TabGroup as a whole, place it into a Column element
        :type visible:                    (bool)
        :param metadata:                  User metadata that can be set to ANYTHING
        :type metadata:                   (Any)
        """

        self.UseDictionary = False
        self.ReturnValues = None
        self.ReturnValuesList = []
        self.ReturnValuesDictionary = {}
        self.DictionaryKeyCounter = 0
        self.ParentWindow = None
        self.SelectedTitleColor = selected_title_color if selected_title_color is not None else LOOK_AND_FEEL_TABLE[CURRENT_LOOK_AND_FEEL]['TEXT']
        self.SelectedBackgroundColor = selected_background_color if selected_background_color is not None else LOOK_AND_FEEL_TABLE[CURRENT_LOOK_AND_FEEL][
            'BACKGROUND']
        title_color = title_color if title_color is not None else LOOK_AND_FEEL_TABLE[CURRENT_LOOK_AND_FEEL]['TEXT_INPUT']
        self.TabBackgroundColor = tab_background_color if tab_background_color is not None else LOOK_AND_FEEL_TABLE[CURRENT_LOOK_AND_FEEL]['INPUT']
        self.Rows = []
        self.TKNotebook = None  # type: ttk.Notebook
        self.Widget = None  # type: ttk.Notebook
        self.tab_index_to_key = {}      # has a list of the tabs in the notebook and their associated key
        self.TabCount = 0
        self.BorderWidth = border_width
        self.BackgroundColor = background_color if background_color is not None else DEFAULT_BACKGROUND_COLOR
        self.ChangeSubmits = change_submits or enable_events
        self.TabLocation = tab_location
        self.ElementJustification = 'left'
        self.RightClickMenu = right_click_menu
        self.TabBorderWidth = tab_border_width
        self.FocusColor = focus_color

        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        self.Layout(layout)

        super().__init__(ELEM_TYPE_TAB_GROUP, size=sz, background_color=background_color, text_color=title_color, font=font,
                         pad=pad, key=key, tooltip=tooltip, visible=visible, metadata=metadata)
        return

    def add_row(self, *args):
        """NOTE: Not recommended user call

        Used to add rows of Elements to the Frame Element.

        :param *args:     The list of elements for this row
        :type *args:      List[Element]
        """

        NumRows = len(self.Rows)  # number of existing rows is our row number
        CurrentRowNumber = NumRows  # this row's number
        CurrentRow = []  # start with a blank row and build up
        # -------------------------  Add the elements to a row  ------------------------- #
        for i, element in enumerate(args):  # Loop through list of elements and add them to the row
            if type(element) == list:
                PopupError('Error creating Tab layout',
                           'Layout has a LIST instead of an ELEMENT',
                           'This sometimes means you have a badly placed ]',
                           'The erroneous list is:',
                           element,
                           'This list will be stripped from your layout', keep_on_top=True, image=_random_error_emoji()
                           )
                continue
            elif callable(element) and not isinstance(element, Element):
                PopupError('Error creating Tab layout',
                           'Layout has a FUNCTION instead of an ELEMENT',
                           'This likely means you are missing () from your layout',
                           'The erroneous list is:',
                           element,
                           'This item will be stripped from your layout', keep_on_top=True, image=_random_error_emoji())
                continue
            if element.ParentContainer is not None:
                warnings.warn(
                    '*** YOU ARE ATTEMPTING TO REUSE AN ELEMENT IN YOUR LAYOUT! Once placed in a layout, an element cannot be used in another layout. ***',
                    UserWarning)
                PopupError('Error creating Tab layout',
                           'The layout specified has already been used',
                           'You MUST start witha "clean", unused layout every time you create a window',
                           'The erroneous Element = ',
                           element,
                           'and has a key = ', element.Key,
                           'This item will be stripped from your layout',
                           'Hint - try printing your layout and matching the IDs "print(layout)"', keep_on_top=True, image=_random_error_emoji())
                continue
            element.Position = (CurrentRowNumber, i)
            element.ParentContainer = self
            CurrentRow.append(element)
            if element.Key is not None:
                self.UseDictionary = True
        # -------------------------  Append the row to list of Rows  ------------------------- #
        self.Rows.append(CurrentRow)

    def layout(self, rows):
        """Can use like the `Window.Layout` method

        But it's better to use the layout parameter when creating.

        :param rows: The rows of Elements
        :type rows:  List[List[Element]]
        :return:     Used for chaining
        :rtype:      (Frame)
        """
        for row in rows:
            try:
                iter(row)
            except TypeError:
                PopupError('Error creating Tab layout',
                           'Your row is not an iterable (e.g. a list)',
                           'Instead of a list, the type found was {}'.format(type(row)),
                           'The erroneous row = ',
                           row,
                           'This item will be stripped from your layout', keep_on_top=True, image=_random_error_emoji())
                continue
            self.AddRow(*row)
        return self

    def _GetElementAtLocation(self, location):
        """NOTE: Not user callable

        Used to find the Element at a row, col position within the layout.

        :param location: (row, column) position of the element to find in layout
        :type location:  (int, int)
        :return:         The element found at the location
        :rtype:          (Element)
        """

        (row_num, col_num) = location
        row = self.Rows[row_num]
        element = row[col_num]
        return element

    def find_key_from_tab_name(self, tab_name):
        """Searches through the layout to find the key that matches the text on the tab

        NOTE: Implies names should be unique.

        :param tab_name: name of a tab
        :type tab_name:  str
        :return:         Returns the key or None if no key found
        :rtype:          key | None
        """
        for row in self.Rows:
            for element in row:
                if element.Title == tab_name:
                    return element.Key
        return None

    def find_currently_active_tab_key(self):
        """Returns the key for the currently active tab in this TabGroup

        :return:    Returns the key or None of no key found
        :rtype:     key | None
        """
        try:
            current_index = self.TKNotebook.index('current')
            key = self.tab_index_to_key.get(current_index, None)
        except:
            key = None
        return key

    def get(self):
        """Returns the current value for the Tab Group

        Which will be the currently selected tab's KEY or the text on the tab
        if no key is defined.  Returns None if an error occurs.
        Note that this is exactly the same data that would be returned from
        a call to `Window.read`.

        :return: The key of the currently selected tab or None if there is an error
        :rtype:  Any | None
        """
        try:
            current_index = self.TKNotebook.index('current')
            key = self.tab_index_to_key.get(current_index, None)
        except:
            key = None
        return key

    def add_tab(self, tab_element):
        """Adds a new tab to an existing TabGroup

        This call was written so that tabs can be added at runtime as your user performs operations.
        Your Window should already be created and finalized.

        :param tab_element: A Tab Element that has a layout in it
        :type tab_element:  Tab
        """

        self.add_row(tab_element)
        tab_element.TKFrame = tab_element.Widget = tk.Frame(self.TKNotebook)
        form = self.ParentForm
        form._BuildKeyDictForWindow(form, tab_element, form.AllKeysDict)
        form.AllKeysDict[tab_element.Key] = tab_element
        # Pack the tab's layout into the tab
        # NOTE: This does NOT pack the Tab itself... for that see below
        PackFormIntoFrame(tab_element, tab_element.TKFrame, self.ParentForm)

        # - This is below -    Perform the same operation that is performed when a Tab is packed into the window.
        # If there's an image in the tab, then do the imagey-stuff
        # ------------------- start of imagey-stuff -------------------
        try:
            if tab_element.Filename is not None:
                photo = tk.PhotoImage(file=tab_element.Filename)
            elif tab_element.Data is not None:
                photo = tk.PhotoImage(data=tab_element.Data)
            else:
                photo = None

            if tab_element.ImageSubsample and photo is not None:
                photo = photo.subsample(tab_element.ImageSubsample)
                # print('*ERROR laying out form.... Image Element has no image specified*')
        except Exception as e:
            photo = None
            _error_popup_with_traceback('Your Window has an Tab Element with an IMAGE problem',
                                        'The traceback will show you the Window with the problem layout',
                                        'Look in this Window\'s layout for an Image tab_element that has a key of {}'.format(tab_element.Key),
                                        'The error occuring is:', e)

        tab_element.photo = photo
        # add the label
        if photo is not None:
            width, height = photo.width(), photo.height()
            tab_element.tktext_label = tk.Label(tab_element.ParentRowFrame, image=photo, width=width, height=height, bd=0)
        else:
            tab_element.tktext_label = tk.Label(tab_element.ParentRowFrame, bd=0)
        # ------------------- end of imagey-stuff -------------------

        state = 'normal'
        if tab_element.Disabled:
            state = 'disabled'
        if tab_element.visible is False:
            state = 'hidden'
        if photo is not None:
            self.TKNotebook.add(tab_element.TKFrame, text=tab_element.Title, compound=tk.LEFT, state=state, image=photo)
        else:
            self.TKNotebook.add(tab_element.TKFrame, text=tab_element.Title, state=state)
        tab_element.ParentNotebook = self.TKNotebook
        tab_element.TabID = self.TabCount
        tab_element.ParentForm = self.ParentForm
        self.TabCount += 1
        if tab_element.BackgroundColor != COLOR_SYSTEM_DEFAULT and tab_element.BackgroundColor is not None:
            tab_element.TKFrame.configure(background=tab_element.BackgroundColor, highlightbackground=tab_element.BackgroundColor,
                                          highlightcolor=tab_element.BackgroundColor)
        if tab_element.BorderWidth is not None:
            tab_element.TKFrame.configure(borderwidth=tab_element.BorderWidth)
        if tab_element.Tooltip is not None:
            tab_element.TooltipObject = ToolTip(tab_element.TKFrame, text=tab_element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)
        _add_right_click_menu(tab_element, form)

    def update(self, visible=None):
        """Enables changing the visibility

        :param visible:  control visibility of element
        :type visible:   (bool)
        """
        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in TabGroup.update:\n- The window was closed')
            return

        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()

        if visible is not None:
            self._visible = visible

    AddRow = add_row
    FindKeyFromTabName = find_key_from_tab_name
    Get = get
    Layout = layout


# ---------------------------------------------------------------------- #
#                           Slider                                       #
# ---------------------------------------------------------------------- #
class Slider(Element):
    """A slider, horizontal or vertical"""

    def __init__(self, range=(None, None), default_value=None, resolution=None, tick_interval=None, orientation=None,
                 disable_number_display=False, setting=None, border_width=None, relief=None, change_submits=False,
                 enable_events=False, disabled=False, size=(None, None), s=(None, None), font=None, background_color=None,
                 text_color=None, trough_color=None, key=None, k=None, pad=None, p=None, expand_x=False, expand_y=False, tooltip=None, visible=True, metadata=None):
        """
        :param range:                  slider's range (min value, max value)
        :type range:                   (int, int) | Tuple[float, float]
        :param default_value:          starting value for the slider
        :type default_value:           int | float
        :param resolution:             the smallest amount the slider can be moved
        :type resolution:              int | float
        :param tick_interval:          how often a visible tick should be shown next to slider
        :type tick_interval:           int | float
        :param orientation:            'horizontal' or 'vertical' ('h' or 'v' also work)
        :type orientation:             (str)
        :param disable_number_display: if True no number will be displayed by the Slider Element
        :type disable_number_display:  (bool)
        :param setting:                If not None, then this element will be saved in a settings file using the key for the element
        :type setting:                 (Any)
        :param border_width:           width of border around element in pixels
        :type border_width:            (int)
        :param relief:                 relief style. Use constants - RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID
        :type relief:                  str | None
        :param change_submits:         * DEPRICATED DO NOT USE. Use `enable_events` instead
        :type change_submits:          (bool)
        :param enable_events:          If True then moving the slider will generate an Event
        :type enable_events:           (bool)
        :param disabled:               set disable state for element
        :type disabled:                (bool)
        :param size:                   (l=length chars/rows, w=width pixels)
        :type size:                    (int, int)
        :param s:                      Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                       (int, int)  | (None, None)
        :param font:                   specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                    (str or (str, int[, str]) or None)
        :param background_color:       color of slider's background
        :type background_color:        (str)
        :param text_color:             color of the slider's text
        :type text_color:              (str)
        :param trough_color:           color of the slider's trough
        :type trough_color:            (str)
        :param key:                    Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                     str | int | tuple | object
        :param k:                      Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                       str | int | tuple | object
        :param pad:                    Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                     (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                      Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                       (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param expand_x:               If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                (bool)
        :param expand_y:               If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                (bool)
        :param tooltip:                text, that will appear when mouse hovers over the element
        :type tooltip:                 (str)
        :param visible:                set visibility state of the element
        :type visible:                 (bool)
        :param metadata:               User metadata that can be set to ANYTHING
        :type metadata:                (Any)
        """

        self.TKScale = self.Widget = None  # type: tk.Scale
        self.Range = (1, 10) if range == (None, None) else range
        self.DefaultValue = self.Range[0] if default_value is None else default_value
        self.Orientation = orientation if orientation else DEFAULT_SLIDER_ORIENTATION
        self.BorderWidth = border_width if border_width else DEFAULT_SLIDER_BORDER_WIDTH
        self.Relief = relief if relief else DEFAULT_SLIDER_RELIEF
        self.Resolution = 1 if resolution is None else resolution
        self.ChangeSubmits = change_submits or enable_events
        self.Disabled = disabled
        self.TickInterval = tick_interval
        self.DisableNumericDisplay = disable_number_display
        self.TroughColor = trough_color or DEFAULT_SCROLLBAR_COLOR
        sz = size if size != (None, None) else s
        temp_size = sz
        if temp_size == (None, None):
            temp_size = (20, 20) if self.Orientation.startswith('h') else (8, 20)
        key = key if key is not None else k
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y
        if setting is not None:
            self.setting = setting
            self.DefaultValue = user_settings_get_entry(key, setting)

        super().__init__(ELEM_TYPE_INPUT_SLIDER, size=temp_size, font=font, background_color=background_color,
                         text_color=text_color, key=key, pad=pad, tooltip=tooltip, visible=visible, metadata=metadata)
        return

    def update(self, value=None, range=(None, None), disabled=None, visible=None):
        """Changes some of the settings for the Slider Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param value:    sets current slider value
        :type value:     int | float
        :param range:    Sets a new range for slider
        :type range:     (int, int) | Tuple[float, float
        :param disabled: disable or enable state of the element
        :type disabled:  (bool)
        :param visible:  control visibility of element
        :type visible:   (bool)
        """
        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Slider.update:\n- The window was closed')
            return

        if range != (None, None):
            self.TKScale.config(from_=range[0], to_=range[1])
        if value is not None:
            try:
                self.TKIntVar.set(value)
            except:
                pass
            self.DefaultValue = value
        if disabled is True:
            self.TKScale['state'] = 'disabled'
        elif disabled is False:
            self.TKScale['state'] = 'normal'
        self.Disabled = disabled if disabled is not None else self.Disabled

        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()

        if visible is not None:
            self._visible = visible

    def _SliderChangedHandler(self, event):
        """NOTE: Not user callable

        Callback function for when slider is moved.

        :param event: (event) the event data provided by tkinter. Unknown format. Not used.
        :type event:
        """

        if self.Key is not None:
            self.ParentForm.LastButtonClicked = self.Key
        else:
            self.ParentForm.LastButtonClicked = ''
        self.ParentForm.FormRemainedOpen = True
        # if self.ParentForm.CurrentlyRunningMainloop:
        #     self.ParentForm.TKroot.quit()  # kick the users out of the mainloop
        _exit_mainloop(self.ParentForm)

    Update = update


Sl = Slider


# ---------------------------------------------------------------------- #
#                          TkFixedFrame (Used by Column)                 #
# ---------------------------------------------------------------------- #
class TkFixedFrame(tk.Frame):
    """A tkinter frame that is used with Column Elements that do not have a scrollbar"""

    def __init__(self, master, **kwargs):
        """
        :param master:   The parent widget
        :type master:    (tk.Widget)
        :param **kwargs: The keyword args
        :type **kwargs:
        """
        tk.Frame.__init__(self, master, **kwargs)

        self.canvas = tk.Canvas(self)
        self.canvas.pack(side="left", fill="both", expand=True)

        # reset the view
        self.canvas.xview_moveto(0)
        self.canvas.yview_moveto(0)

        # create a frame inside the canvas which will be scrolled with it
        self.TKFrame = tk.Frame(self.canvas, **kwargs)
        self.frame_id = self.canvas.create_window(0, 0, window=self.TKFrame, anchor="nw")
        self.canvas.config(borderwidth=0, highlightthickness=0)
        self.TKFrame.config(borderwidth=0, highlightthickness=0)
        self.config(borderwidth=0, highlightthickness=0)


# ---------------------------------------------------------------------- #
#                          TkScrollableFrame (Used by Column)            #
# ---------------------------------------------------------------------- #
class TkScrollableFrame(tk.Frame):
    """A frame with one or two scrollbars.  Used to make Columns with scrollbars"""

    def __init__(self, master, vertical_only, element, window, **kwargs):
        """
        :param master:        The parent widget
        :type master:         (tk.Widget)
        :param vertical_only: if True the only a vertical scrollbar will be shown
        :type vertical_only:  (bool)
        :param element:       The element containing this object
        :type element:        (Column)
        """
        tk.Frame.__init__(self, master, **kwargs)
        # create a canvas object and a vertical scrollbar for scrolling it

        self.canvas = tk.Canvas(self)
        element.Widget = self.canvas
        # Okay, we're gonna make a list. Containing the y-min, x-min, y-max, and x-max of the frame
        element.element_frame = self
        _make_ttk_scrollbar(element, 'v', window)
        # element.vsb = tk.Scrollbar(self, orient=tk.VERTICAL)
        element.vsb.pack(side='right', fill="y", expand="false")

        if not vertical_only:
            _make_ttk_scrollbar(element, 'h', window)
            # self.hscrollbar = tk.Scrollbar(self, orient=tk.HORIZONTAL)
            element.hsb.pack(side='bottom', fill="x", expand="false")
            self.canvas.config(xscrollcommand=element.hsb.set)
            # self.canvas = tk.Canvas(self, )
        # else:
        #     self.canvas = tk.Canvas(self)

        self.canvas.config(yscrollcommand=element.vsb.set)
        self.canvas.pack(side="left", fill="both", expand=True)
        element.vsb.config(command=self.canvas.yview)
        if not vertical_only:
            element.hsb.config(command=self.canvas.xview)

        # reset the view
        self.canvas.xview_moveto(0)
        self.canvas.yview_moveto(0)

        # create a frame inside the canvas which will be scrolled with it
        self.TKFrame = tk.Frame(self.canvas, **kwargs)
        self.frame_id = self.canvas.create_window(0, 0, window=self.TKFrame, anchor="nw")
        self.canvas.config(borderwidth=0, highlightthickness=0)
        self.TKFrame.config(borderwidth=0, highlightthickness=0)
        self.config(borderwidth=0, highlightthickness=0)

        # Canvas can be: master, canvas, TKFrame
        self.unhookMouseWheel(None)
        self.canvas.bind("<Enter>", self.hookMouseWheel)
        self.canvas.bind("<Leave>", self.unhookMouseWheel)
        self.bind('<Configure>', self.set_scrollregion)

    def hookMouseWheel(self, e):
        # print("enter")
        VarHolder.canvas_holder = self.canvas
        self.canvas.bind_all('<4>', self.yscroll, add='+')
        self.canvas.bind_all('<5>', self.yscroll, add='+')
        self.canvas.bind_all("<MouseWheel>", self.yscroll, add='+')
        self.canvas.bind_all("<Shift-MouseWheel>", self.xscroll, add='+')

    def unhookMouseWheel(self, e):
        # print("leave")
        VarHolder.canvas_holder = None
        self.canvas.unbind_all('<4>')
        self.canvas.unbind_all('<5>')
        self.canvas.unbind_all("<MouseWheel>")
        self.canvas.unbind_all("<Shift-MouseWheel>")

    def resize_frame(self, e):
        self.canvas.itemconfig(self.frame_id, height=e.height, width=e.width)

    def yscroll(self, event):
        if self.canvas.yview() == (0.0, 1.0):
            return
        if event.num == 5 or event.delta < 0:
            self.canvas.yview_scroll(1, "unit")
        elif event.num == 4 or event.delta > 0:
            self.canvas.yview_scroll(-1, "unit")

    def xscroll(self, event):
        if event.num == 5 or event.delta < 0:
            self.canvas.xview_scroll(1, "unit")
        elif event.num == 4 or event.delta > 0:
            self.canvas.xview_scroll(-1, "unit")

    def bind_mouse_scroll(self, parent, mode):
        # ~~ Windows only
        parent.bind("<MouseWheel>", mode)
        # ~~ Unix only
        parent.bind("<Button-4>", mode)
        parent.bind("<Button-5>", mode)

    def set_scrollregion(self, event=None):
        """ Set the scroll region on the canvas """
        self.canvas.configure(scrollregion=self.canvas.bbox('all'))


# ---------------------------------------------------------------------- #
#                           Column                                       #
# ---------------------------------------------------------------------- #
class Column(Element):
    """A container element that is used to create a layout within your window's layout"""

    def __init__(self, layout, background_color=None, size=(None, None), s=(None, None), size_subsample_width=1, size_subsample_height=2, pad=None, p=None, scrollable=False,
                 vertical_scroll_only=False, right_click_menu=None, key=None, k=None, visible=True, justification=None, element_justification=None,
                 vertical_alignment=None, grab=None, expand_x=None, expand_y=None, metadata=None,
                 sbar_trough_color=None, sbar_background_color=None, sbar_arrow_color=None, sbar_width=None, sbar_arrow_width=None,
                 sbar_frame_color=None, sbar_relief=None):
        """
        :param layout:                      Layout that will be shown in the Column container
        :type layout:                       List[List[Element]]
        :param background_color:            color of background of entire Column
        :type background_color:             (str)
        :param size:                        (width, height) size in pixels (doesn't work quite right, sometimes only 1 dimension is set by tkinter. Use a Sizer Element to help set sizes
        :type size:                         (int | None, int | None)
        :param s:                           Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                            (int | None, int | None)
        :param size_subsample_width:        Determines the size of a scrollable column width based on 1/size_subsample * required size. 1 = match the contents exactly, 2 = 1/2 contents size, 3 = 1/3. Can be a fraction to make larger than required.
        :type size_subsample_width:         (float)
        :param size_subsample_height:       Determines the size of a scrollable height based on 1/size_subsample * required size. 1 = match the contents exactly, 2 = 1/2 contents size, 3 = 1/3. Can be a fraction to make larger than required..
        :type size_subsample_height:        (float)
        :param pad:                         Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                          (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                           Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                            (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param scrollable:                  if True then scrollbars will be added to the column. If you update the contents of a scrollable column, be sure and call Column.contents_changed also
        :type scrollable:                   (bool)
        :param vertical_scroll_only:        if True then no horizontal scrollbar will be shown if a scrollable column
        :type vertical_scroll_only:         (bool)
        :param right_click_menu:            A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:             List[List[ List[str] | str ]]
        :param key:                         Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                          str | int | tuple | object
        :param k:                           Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                            str | int | tuple | object
        :param visible:                     set visibility state of the element
        :type visible:                      (bool)
        :param justification:               set justification for the Column itself. Note entire row containing the Column will be affected
        :type justification:                (str)
        :param element_justification:       All elements inside the Column will have this justification 'left', 'right', 'center' are valid values
        :type element_justification:        (str)
        :param vertical_alignment:          Place the column at the 'top', 'center', 'bottom' of the row (can also use t,c,r). Defaults to no setting (tkinter decides)
        :type vertical_alignment:           (str)
        :param grab:                        If True can grab this element and move the window around. Default is False
        :type grab:                         (bool)
        :param expand_x:                    If True the column will automatically expand in the X direction to fill available space
        :type expand_x:                     (bool)
        :param expand_y:                    If True the column will automatically expand in the Y direction to fill available space
        :type expand_y:                     (bool)
        :param metadata:                    User metadata that can be set to ANYTHING
        :type metadata:                     (Any)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        """

        self.UseDictionary = False
        self.ReturnValues = None
        self.ReturnValuesList = []
        self.ReturnValuesDictionary = {}
        self.DictionaryKeyCounter = 0
        self.ParentWindow = None
        self.ParentPanedWindow = None
        self.Rows = []
        self.TKFrame = None
        self.TKColFrame = None  # type: tk.Frame
        self.Scrollable = scrollable
        self.VerticalScrollOnly = vertical_scroll_only

        self.RightClickMenu = right_click_menu
        bg = background_color if background_color is not None else DEFAULT_BACKGROUND_COLOR
        self.ContainerElemementNumber = Window._GetAContainerNumber()
        self.ElementJustification = element_justification
        self.Justification = justification
        self.VerticalAlignment = vertical_alignment
        key = key if key is not None else k
        self.Grab = grab
        self.expand_x = expand_x
        self.expand_y = expand_y
        self.Layout(layout)
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.size_subsample_width = size_subsample_width
        self.size_subsample_height = size_subsample_height

        super().__init__(ELEM_TYPE_COLUMN, background_color=bg, size=sz, pad=pad, key=key, visible=visible, metadata=metadata,
                         sbar_trough_color=sbar_trough_color, sbar_background_color=sbar_background_color, sbar_arrow_color=sbar_arrow_color, sbar_width=sbar_width,
                         sbar_arrow_width=sbar_arrow_width, sbar_frame_color=sbar_frame_color, sbar_relief=sbar_relief)
        return

    def add_row(self, *args):
        """NOTE: Not recommended user call

        Used to add rows of Elements to the Column Element.

        :param *args: The list of elements for this row
        :type *args:  List[Element]
        """

        NumRows = len(self.Rows)  # number of existing rows is our row number
        CurrentRowNumber = NumRows  # this row's number
        CurrentRow = []  # start with a blank row and build up
        # -------------------------  Add the elements to a row  ------------------------- #
        for i, element in enumerate(args):  # Loop through list of elements and add them to the row
            if type(element) == list:
                PopupError('Error creating Column layout',
                           'Layout has a LIST instead of an ELEMENT',
                           'This sometimes means you have a badly placed ]',
                           'The erroneous list is:',
                           element,
                           'This list will be stripped from your layout', keep_on_top=True, image=_random_error_emoji()
                           )
                continue
            elif callable(element) and not isinstance(element, Element):
                PopupError('Error creating Column layout',
                           'Layout has a FUNCTION instead of an ELEMENT',
                           'This likely means you are missing () from your layout',
                           'The erroneous list is:',
                           element,
                           'This item will be stripped from your layout', keep_on_top=True, image=_random_error_emoji())
                continue
            if element.ParentContainer is not None:
                warnings.warn(
                    '*** YOU ARE ATTEMPTING TO REUSE AN ELEMENT IN YOUR LAYOUT! Once placed in a layout, an element cannot be used in another layout. ***',
                    UserWarning)
                PopupError('Error creating Column layout',
                           'The layout specified has already been used',
                           'You MUST start witha "clean", unused layout every time you create a window',
                           'The erroneous Element = ',
                           element,
                           'and has a key = ', element.Key,
                           'This item will be stripped from your layout',
                           'Hint - try printing your layout and matching the IDs "print(layout)"', keep_on_top=True, image=_random_error_emoji())
                continue
            element.Position = (CurrentRowNumber, i)
            element.ParentContainer = self
            CurrentRow.append(element)
            if element.Key is not None:
                self.UseDictionary = True
        # -------------------------  Append the row to list of Rows  ------------------------- #
        self.Rows.append(CurrentRow)

    def layout(self, rows):
        """Can use like the Window.Layout method

        But it's better to use the layout parameter when creating.

        :param rows: The rows of Elements
        :type rows:  List[List[Element]]
        :return:     Used for chaining
        :rtype:      (Column)
        """

        for row in rows:
            try:
                iter(row)
            except TypeError:
                PopupError('Error creating Column layout',
                           'Your row is not an iterable (e.g. a list)',
                           'Instead of a list, the type found was {}'.format(type(row)),
                           'The erroneous row = ',
                           row,
                           'This item will be stripped from your layout', keep_on_top=True, image=_random_error_emoji())
                continue
            self.AddRow(*row)
        return self

    def _GetElementAtLocation(self, location):
        """NOTE: Not user callable method

        Used to find the Element at a row, col position within the layout

        :param location:     (row, column) position of the element to find in layout
        :type  location:     (int, int)
        :return:             The element found at the location
        :rtype:              (Element)
        """

        (row_num, col_num) = location
        row = self.Rows[row_num]
        element = row[col_num]
        return element

    def update(self, visible=None):
        """Changes some of the settings for the Column Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param visible: control visibility of element
        :type visible:  (bool)
        """
        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Column.update:\n- The window was closed')
            return

        if self.expand_x and self.expand_y:
            expand = tk.BOTH
        elif self.expand_x:
            expand = tk.X
        elif self.expand_y:
            expand = tk.Y
        else:
            expand = None

        if visible is False:
            if self.TKColFrame:
                self._pack_forget_save_settings()
                # self.TKColFrame.pack_forget()
            if self.ParentPanedWindow:
                self.ParentPanedWindow.remove(self.TKColFrame)
        elif visible is True:
            if self.TKColFrame:
                self._pack_restore_settings()
                # self.TKColFrame.pack(padx=self.pad_used[0], pady=self.pad_used[1], fill=expand)
            if self.ParentPanedWindow:
                self.ParentPanedWindow.add(self.TKColFrame)
        if visible is not None:
            self._visible = visible

    def contents_changed(self):
        """
        When a scrollable column has part of its layout changed by making elements visible or invisible or the
        layout is extended for the `Column`, then this method needs to be called so that the new scroll area
        is computed to match the new contents.
        """
        self.TKColFrame.canvas.config(scrollregion=self.TKColFrame.canvas.bbox('all'))

    AddRow = add_row
    Layout = layout
    Update = update


Col = Column


# ---------------------------------------------------------------------- #
#                           Pane                                         #
# ---------------------------------------------------------------------- #
class Pane(Element):
    """A sliding Pane that is unique to tkinter

    Uses Columns to create individual panes.
    """
    def __init__(self, pane_list, background_color=None, size=(None, None), s=(None, None), pad=None, p=None, orientation='vertical',
                 show_handle=True, relief=RELIEF_RAISED, handle_size=None, border_width=None, key=None, k=None, expand_x=None, expand_y=None, visible=True, metadata=None):
        """
        :param pane_list:        Must be a list of Column Elements. Each Column supplied becomes one pane that's shown
        :type pane_list:         List[Column] | Tuple[Column]
        :param background_color: color of background
        :type background_color:  (str)
        :param size:             (width, height) w=characters-wide, h=rows-high How much room to reserve for the Pane
        :type size:              (int, int)
        :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                 (int, int)  | (None, None)
        :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param orientation:      'horizontal' or 'vertical' or ('h' or 'v'). Direction the Pane should slide
        :type orientation:       (str)
        :param show_handle:      if True, the handle is drawn that makes it easier to grab and slide
        :type show_handle:       (bool)
        :param relief:           relief style. Values are same as other elements that use relief values. RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID
        :type relief:            (enum)
        :param handle_size:      Size of the handle in pixels
        :type handle_size:       (int)
        :param border_width:     width of border around element in pixels
        :type border_width:      (int)
        :param key:              Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:               str | int | tuple | object
        :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                 str | int | tuple | object
        :param expand_x:         If True the column will automatically expand in the X direction to fill available space
        :type expand_x:          (bool)
        :param expand_y:         If True the column will automatically expand in the Y direction to fill available space
        :type expand_y:          (bool)
        :param visible:          set visibility state of the element
        :type visible:           (bool)
        :param metadata:         User metadata that can be set to ANYTHING
        :type metadata:          (Any)
        """

        self.UseDictionary = False
        self.ReturnValues = None
        self.ReturnValuesList = []
        self.ReturnValuesDictionary = {}
        self.DictionaryKeyCounter = 0
        self.ParentWindow = None
        self.Rows = []
        self.TKFrame = None
        self.PanedWindow = None
        self.Orientation = orientation
        self.PaneList = pane_list
        self.ShowHandle = show_handle
        self.Relief = relief
        self.HandleSize = handle_size or 8
        self.BorderDepth = border_width
        bg = background_color if background_color is not None else DEFAULT_BACKGROUND_COLOR

        self.Rows = [pane_list]
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        super().__init__(ELEM_TYPE_PANE, background_color=bg, size=sz, pad=pad, key=key, visible=visible, metadata=metadata)
        return

    def update(self, visible=None):
        """Changes some of the settings for the Pane Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param visible: control visibility of element
        :type visible:  (bool)
        """
        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Pane.update:\n- The window was closed')
            return

        if visible is False:
            self._pack_forget_save_settings()
        elif visible is True:
            self._pack_restore_settings()

        if visible is not None:
            self._visible = visible

    Update = update


# ---------------------------------------------------------------------- #
#                           Menu                                         #
# ---------------------------------------------------------------------- #
class Menu(Element):
    """Menu Element is the Element that provides a Menu Bar

    It goes across the top of the window, just below titlebar.
    Here is an example layout:
    The "&" are shortcut keys ALT+key.
    Is a List of -  "Item String" + List where Item String is what will be displayed on the Menubar itself.
        The List that follows the item represents the items that are shown then Menu item is clicked.
        Notice how an "entry" in a mennu can be a list which means it branches out
        and shows another menu, etc. (recursive)
    ```
    menu_def = [['&File', ['!&Open', '&Save::savekey', '---', '&Properties', 'E&xit']],
                ['!&Edit', ['!&Paste', ['Special', 'Normal', ], 'Undo'], ],
                ['&Debugger', ['Popout', 'Launch Debugger']],
                ['&Toolbar', ['Command &1', 'Command &2', 'Command &3', 'Command &4']],
                ['&Help', '&About...'], ]
    ```

    Important NOTE:  The colors, font, look of the Menubar itself
    cannot be changed, only the menus shown **after** clicking the menubar
    can be changed.  If you want to change the style/colors the `Menubar`,
    then you will have to use the `MenubarCustom` element.

    Finally, 'keys' can be added to entries so make them unique.
    The 'Save' entry has a key associated with it.
    You can see it has a "::" which signifies the beginning of a key.
    The user will not see the key portion when the menu is shown.
    The key portion is returned as part of the event.
    """
    def __init__(self, menu_definition, background_color=None, text_color=None, disabled_text_color=None, size=(None, None), s=(None, None), tearoff=False,
                 font=None, pad=None, p=None, key=None, k=None, visible=True, metadata=None):
        """
        :param menu_definition:           The Menu definition specified using lists (docs explain the format)
        :type menu_definition:            List[List[Tuple[str, List[str]]]
        :param background_color:          color of the background of menus, NOT the Menubar
        :type background_color:           (str)
        :param text_color:                text color for menus, NOT the Menubar. Can be in #RRGGBB format or a color name "black".
        :type text_color:                 (str)
        :param disabled_text_color:       color to use for text when item in submenu, not the menubar itself, is disabled. Can be in #RRGGBB format or a color name "black"
        :type disabled_text_color:        (str)
        :param size:                      Not used in the tkinter port
        :type size:                       (int, int)
        :param s:                         Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
        :type s:                          (int, int)  | (None, None)
        :param tearoff:                   if True, then can tear the menu off from the window ans use as a floating window. Very cool effect
        :type tearoff:                    (bool)
        :param pad:                       Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                        (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                         Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                          (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param font:                      specifies the  font family, size, etc. of submenus. Does NOT apply to the Menubar itself. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                       (str or (str, int[, str]) or None)
        :param key:                       Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
        :type key:                        str | int | tuple | object
        :param k:                         Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                          str | int | tuple | object
        :param visible:                   set visibility state of the element
        :type visible:                    (bool)
        :param metadata:                  User metadata that can be set to ANYTHING
        :type metadata:                   (Any)
        """

        self.BackgroundColor = background_color if background_color is not None else theme_input_background_color()
        self.TextColor = text_color if text_color is not None else theme_input_text_color()

        self.DisabledTextColor = disabled_text_color if disabled_text_color is not None else COLOR_SYSTEM_DEFAULT
        self.MenuDefinition = copy.deepcopy(menu_definition)
        self.Widget = self.TKMenu = None  # type: tk.Menu
        self.MenuItemChosen = None
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p

        super().__init__(ELEM_TYPE_MENUBAR, background_color=self.BackgroundColor, text_color=self.TextColor, size=sz, pad=pad, key=key, visible=visible,
                         font=font, metadata=metadata)
        self.Tearoff = tearoff

        return

    def _MenuItemChosenCallback(self, item_chosen):  # Menu Menu Item Chosen Callback
        """
        Not user callable.  Called when some end-point on the menu (an item) has been clicked.  Send the information back to the application as an event.  Before event can be sent

        :param item_chosen: the text that was clicked on / chosen from the menu
        :type item_chosen:  (str)
        """
        # print('IN MENU ITEM CALLBACK', item_chosen)
        self.MenuItemChosen = item_chosen
        self.ParentForm.LastButtonClicked = item_chosen
        self.ParentForm.FormRemainedOpen = True
        # if self.ParentForm.CurrentlyRunningMainloop:
        #     self.ParentForm.TKroot.quit()  # kick the users out of the mainloop
        _exit_mainloop(self.ParentForm)

    def update(self, menu_definition=None, visible=None):
        """Updates a menubar

        Can change the menu definition and visibility.
        The entire menu has to be specified.

        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param menu_definition: The menu definition list
        :type menu_definition:  List[List[Tuple[str, List[str]]]
        :param visible:         control visibility of element
        :type visible:          (bool)
        """
        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Menu.update:\n- The window was closed')
            return

        if menu_definition is not None:
            self.MenuDefinition = copy.deepcopy(menu_definition)
            if self.TKMenu is None:  # if no menu exists, make one
                self.TKMenu = tk.Menu(self.ParentForm.TKroot, tearoff=self.Tearoff, tearoffcommand=self._tearoff_menu_callback)  # create the menubar
            menubar = self.TKMenu
            # Delete all the menu items (10000 should be a enough to cover them all)
            menubar.delete(0, 10000)
            self.Widget = self.TKMenu  # same the new menu so user can access to extend FreeSimpleGUI
            for menu_entry in self.MenuDefinition:
                baritem = tk.Menu(menubar, tearoff=self.Tearoff, tearoffcommand=self._tearoff_menu_callback)

                if self.BackgroundColor not in (COLOR_SYSTEM_DEFAULT, None):
                    baritem.config(bg=self.BackgroundColor)
                if self.TextColor not in (COLOR_SYSTEM_DEFAULT, None):
                    baritem.config(fg=self.TextColor)
                if self.DisabledTextColor not in (COLOR_SYSTEM_DEFAULT, None):
                    baritem.config(disabledforeground=self.DisabledTextColor)
                if self.Font is not None:
                    baritem.config(font=self.Font)

                if self.Font is not None:
                    baritem.config(font=self.Font)
                pos = menu_entry[0].find(MENU_SHORTCUT_CHARACTER)
                # print(pos)
                if pos != -1:
                    if pos == 0 or menu_entry[0][pos - len(MENU_SHORTCUT_CHARACTER)] != "\\":
                        menu_entry[0] = menu_entry[0][:pos] + menu_entry[0][pos + len(MENU_SHORTCUT_CHARACTER):]
                if menu_entry[0][0] == MENU_DISABLED_CHARACTER:
                    menubar.add_cascade(label=menu_entry[0][len(MENU_DISABLED_CHARACTER):], menu=baritem, underline=pos)
                    menubar.entryconfig(menu_entry[0][len(MENU_DISABLED_CHARACTER):], state='disabled')
                else:
                    menubar.add_cascade(label=menu_entry[0], menu=baritem, underline=pos)

                if len(menu_entry) > 1:
                    AddMenuItem(baritem, menu_entry[1], self)

        if visible is False:
            self.ParentForm.TKroot.configure(menu=[])  # this will cause the menubar to disappear
        elif self.TKMenu is not None:
            self.ParentForm.TKroot.configure(menu=self.TKMenu)
        if visible is not None:
            self._visible = visible

    Update = update


MenuBar = Menu  # another name for Menu to make it clear it's the Menu Bar
Menubar = Menu  # another name for Menu to make it clear it's the Menu Bar


# ---------------------------------------------------------------------- #
#                           Table                                        #
# ---------------------------------------------------------------------- #
class Table(Element):

    def __init__(self, values, headings=None, visible_column_map=None, col_widths=None, cols_justification=None, def_col_width=10,
                 auto_size_columns=True, max_col_width=20, select_mode=None, display_row_numbers=False, starting_row_number=0, num_rows=None,
                 row_height=None, font=None, justification='right', text_color=None, background_color=None,
                 alternating_row_color=None, selected_row_colors=(None, None), header_text_color=None, header_background_color=None, header_font=None, header_border_width=None,
                 header_relief=None,
                 row_colors=None, vertical_scroll_only=True, hide_vertical_scroll=False, border_width=None,
                 sbar_trough_color=None, sbar_background_color=None, sbar_arrow_color=None, sbar_width=None, sbar_arrow_width=None, sbar_frame_color=None, sbar_relief=None,
                 size=(None, None), s=(None, None), change_submits=False, enable_events=False, enable_click_events=False, right_click_selects=False, bind_return_key=False,
                 pad=None, p=None,
                 key=None, k=None, tooltip=None, right_click_menu=None, expand_x=False, expand_y=False, visible=True, metadata=None):
        """
        :param values:                  Your table data represented as a 2-dimensions table... a list of rows, with each row representing a row in your table.
        :type values:                   List[List[str | int | float]]
        :param headings:                The headings to show on the top line
        :type headings:                 List[str]
        :param visible_column_map:      One entry for each column. False indicates the column is not shown
        :type visible_column_map:       List[bool]
        :param col_widths:              Number of characters that each column will occupy
        :type col_widths:               List[int]
        :param cols_justification:      Justification for EACH column. Is a list of strings with the value 'l', 'r', 'c' that indicates how the column will be justified. Either no columns should be set, or have to have one for every colun
        :type cols_justification:       List[str] or Tuple[str] or None
        :param def_col_width:           Default column width in characters
        :type def_col_width:            (int)
        :param auto_size_columns:       if True columns will be sized automatically
        :type auto_size_columns:        (bool)
        :param max_col_width:           Maximum width for all columns in characters
        :type max_col_width:            (int)
        :param select_mode:             Select Mode. Valid values start with "TABLE_SELECT_MODE_".  Valid values are: TABLE_SELECT_MODE_NONE TABLE_SELECT_MODE_BROWSE TABLE_SELECT_MODE_EXTENDED
        :type select_mode:              (enum)
        :param display_row_numbers:     if True, the first column of the table will be the row #
        :type display_row_numbers:      (bool)
        :param starting_row_number:     The row number to use for the first row. All following rows will be based on this starting value. Default is 0.
        :type starting_row_number:      (int)
        :param num_rows:                The number of rows of the table to display at a time
        :type num_rows:                 (int)
        :param row_height:              height of a single row in pixels
        :type row_height:               (int)
        :param font:                    specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                     (str or (str, int[, str]) or None)
        :param justification:           'left', 'right', 'center' are valid choices
        :type justification:            (str)
        :param text_color:              color of the text
        :type text_color:               (str)
        :param background_color:        color of background
        :type background_color:         (str)
        :param alternating_row_color:   if set then every other row will have this color in the background.
        :type alternating_row_color:    (str)
        :param selected_row_colors:     Sets the text color and background color for a selected row. Same format as button colors - tuple ('red', 'yellow') or string 'red on yellow'. Defaults to theme's button color
        :type selected_row_colors:      str or (str, str)
        :param header_text_color:       sets the text color for the header
        :type header_text_color:        (str)
        :param header_background_color: sets the background color for the header
        :type header_background_color:  (str)
        :param header_font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type header_font:              (str or (str, int[, str]) or None)
        :param header_border_width:     Border width for the header portion
        :type header_border_width:      (int | None)
        :param header_relief:           Relief style for the header. Values are same as other elements that use relief. RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID
        :type header_relief:            (str | None)
        :param row_colors:              list of tuples of (row, background color) OR (row, foreground color, background color). Sets the colors of listed rows to the color(s) provided (note the optional foreground color)
        :type row_colors:               List[Tuple[int, str] | Tuple[Int, str, str]]
        :param vertical_scroll_only:    if True only the vertical scrollbar will be visible
        :type vertical_scroll_only:     (bool)
        :param hide_vertical_scroll:    if True vertical scrollbar will be hidden
        :type hide_vertical_scroll:     (bool)
        :param border_width:            Border width/depth in pixels
        :type border_width:             (int)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        :param size:                    DO NOT USE! Use num_rows instead
        :type size:                     (int, int)
        :param change_submits:          DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:           (bool)
        :param enable_events:           Turns on the element specific events. Table events happen when row is clicked
        :type enable_events:            (bool)
        :param enable_click_events:     Turns on the element click events that will give you (row, col) click data when the table is clicked
        :type enable_click_events:      (bool)
        :param right_click_selects:     If True, then right clicking a row will select that row if multiple rows are not currently selected
        :type right_click_selects:      (bool)
        :param bind_return_key:         if True, pressing return key will cause event coming from Table, ALSO a left button double click will generate an event if this parameter is True
        :type bind_return_key:          (bool)
        :param pad:                     Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                       Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                        (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:                     Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:                      str | int | tuple | object
        :param k:                       Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                        str | int | tuple | object
        :param tooltip:                 text, that will appear when mouse hovers over the element
        :type tooltip:                  (str)
        :param right_click_menu:        A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:         List[List[ List[str] | str ]]
        :param expand_x:                If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                 (bool)
        :param expand_y:                If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                 (bool)
        :param visible:                 set visibility state of the element
        :type visible:                  (bool)
        :param metadata:                User metadata that can be set to ANYTHING
        :type metadata:                 (Any)
        """

        self.Values = values
        self.ColumnHeadings = headings
        self.ColumnsToDisplay = visible_column_map
        self.ColumnWidths = col_widths
        self.cols_justification = cols_justification
        self.MaxColumnWidth = max_col_width
        self.DefaultColumnWidth = def_col_width
        self.AutoSizeColumns = auto_size_columns
        self.BackgroundColor = background_color if background_color is not None else DEFAULT_BACKGROUND_COLOR
        self.TextColor = text_color
        self.HeaderTextColor = header_text_color if header_text_color is not None else LOOK_AND_FEEL_TABLE[CURRENT_LOOK_AND_FEEL]['TEXT_INPUT']
        self.HeaderBackgroundColor = header_background_color if header_background_color is not None else LOOK_AND_FEEL_TABLE[CURRENT_LOOK_AND_FEEL]['INPUT']
        self.HeaderFont = header_font
        self.Justification = justification
        self.InitialState = None
        self.SelectMode = select_mode
        self.DisplayRowNumbers = display_row_numbers
        self.NumRows = num_rows if num_rows is not None else size[1]
        self.RowHeight = row_height
        self.Widget = self.TKTreeview = None  # type: ttk.Treeview
        self.AlternatingRowColor = alternating_row_color
        self.VerticalScrollOnly = vertical_scroll_only
        self.HideVerticalScroll = hide_vertical_scroll
        self.SelectedRows = []
        self.ChangeSubmits = change_submits or enable_events
        self.BindReturnKey = bind_return_key
        self.StartingRowNumber = starting_row_number  # When displaying row numbers, where to start
        self.RowHeaderText = 'Row'
        self.enable_click_events = enable_click_events
        self.right_click_selects = right_click_selects
        self.last_clicked_position = (None, None)
        self.HeaderBorderWidth = header_border_width
        self.BorderWidth = border_width
        self.HeaderRelief = header_relief
        self.table_ttk_style_name = None  # the ttk style name for the Table itself
        if selected_row_colors == (None, None):
            # selected_row_colors = DEFAULT_TABLE_AND_TREE_SELECTED_ROW_COLORS
            selected_row_colors = theme_button_color()
        else:
            try:
                if isinstance(selected_row_colors, str):
                    selected_row_colors = selected_row_colors.split(' on ')
            except Exception as e:
                print('* Table Element Warning * you messed up with color formatting of Selected Row Color', e)
        self.SelectedRowColors = selected_row_colors

        self.RightClickMenu = right_click_menu
        self.RowColors = row_colors
        self.tree_ids = []  # ids returned when inserting items into table - will use to delete colors
        key = key if key is not None else k
        sz = size if size != (None, None) else s
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        super().__init__(ELEM_TYPE_TABLE, text_color=text_color, background_color=background_color, font=font,
                         size=sz, pad=pad, key=key, tooltip=tooltip, visible=visible, metadata=metadata,
                         sbar_trough_color=sbar_trough_color, sbar_background_color=sbar_background_color, sbar_arrow_color=sbar_arrow_color, sbar_width=sbar_width,
                         sbar_arrow_width=sbar_arrow_width, sbar_frame_color=sbar_frame_color, sbar_relief=sbar_relief)
        return

    def update(self, values=None, num_rows=None, visible=None, select_rows=None, alternating_row_color=None, row_colors=None):
        """Changes some of the settings for the Table Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param values:                A new 2-dimensional table to show
        :type values:                 List[List[str | int | float]]
        :param num_rows:              How many rows to display at a time
        :type num_rows:               (int)
        :param visible:               if True then will be visible
        :type visible:                (bool)
        :param select_rows:           List of rows to select as if user did
        :type select_rows:            List[int]
        :param alternating_row_color: the color to make every other row
        :type alternating_row_color:  (str)
        :param row_colors:            list of tuples of (row, background color) OR (row, foreground color, background color). Changes the colors of listed rows to the color(s) provided (note the optional foreground color)
        :type row_colors:             List[Tuple[int, str] | Tuple[Int, str, str]]
        """
        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Table.update:\n- The window was closed')
            return

        if values is not None:
            for id in self.tree_ids:
                self.TKTreeview.item(id, tags=())
                if self.BackgroundColor is not None and self.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    self.TKTreeview.tag_configure(id, background=self.BackgroundColor)
                else:
                    self.TKTreeview.tag_configure(id, background='#FFFFFF', foreground='#000000')
                if self.TextColor is not None and self.TextColor != COLOR_SYSTEM_DEFAULT:
                    self.TKTreeview.tag_configure(id, foreground=self.TextColor)
                else:
                    self.TKTreeview.tag_configure(id, foreground='#000000')

            children = self.TKTreeview.get_children()
            for i in children:
                self.TKTreeview.detach(i)
                self.TKTreeview.delete(i)
            children = self.TKTreeview.get_children()

            self.tree_ids = []
            for i, value in enumerate(values):
                if self.DisplayRowNumbers:
                    value = [i + self.StartingRowNumber] + value
                id = self.TKTreeview.insert('', 'end', text=value, iid=i + 1, values=value, tag=i)
                if self.BackgroundColor is not None and self.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    self.TKTreeview.tag_configure(id, background=self.BackgroundColor)
                else:
                    self.TKTreeview.tag_configure(id, background='#FFFFFF')
                self.tree_ids.append(id)
            self.Values = values
            self.SelectedRows = []
        if visible is False:
            self._pack_forget_save_settings(self.element_frame)
        elif visible is True:
            self._pack_restore_settings(self.element_frame)

        if num_rows is not None:
            self.TKTreeview.config(height=num_rows)
        if select_rows is not None:
            rows_to_select = [i + 1 for i in select_rows]
            self.TKTreeview.selection_set(rows_to_select)

        if alternating_row_color is not None:  # alternating colors
            self.AlternatingRowColor = alternating_row_color

        if self.AlternatingRowColor is not None:
            for row in range(0, len(self.Values), 2):
                self.TKTreeview.tag_configure(row, background=self.AlternatingRowColor)
        if row_colors is not None:  # individual row colors
            self.RowColors = row_colors
            for row_def in self.RowColors:
                if len(row_def) == 2:  # only background is specified
                    self.TKTreeview.tag_configure(row_def[0], background=row_def[1])
                else:
                    self.TKTreeview.tag_configure(row_def[0], background=row_def[2], foreground=row_def[1])
        if visible is not None:
            self._visible = visible

    def _treeview_selected(self, event):
        """NOTE: Not user callable method.

        Callback function that is called when something is selected from `Table`.
        Stores the selected rows in Element as they are being selected. If events enabled, then returns from `Read`.

        :param event: event information from tkinter
        :type event:  (unknown)
        """
        # print('**-- in treeview selected --**')
        selections = self.TKTreeview.selection()
        self.SelectedRows = [int(x) - 1 for x in selections]
        if self.ChangeSubmits:
            if self.Key is not None:
                self.ParentForm.LastButtonClicked = self.Key
            else:
                self.ParentForm.LastButtonClicked = ''
            self.ParentForm.FormRemainedOpen = True
            # if self.ParentForm.CurrentlyRunningMainloop:
            #     self.ParentForm.TKroot.quit()
            _exit_mainloop(self.ParentForm)

    def _treeview_double_click(self, event):
        """NOTE: Not user callable method

        Callback function that is called when something is selected from `Table`.
        Stores the selected rows in Element as they are being selected. If events enabled, then returns from `Read`.

        :param event: event information from tkinter
        :type event:  (unknown)
        """
        selections = self.TKTreeview.selection()
        self.SelectedRows = [int(x) - 1 for x in selections]
        if self.BindReturnKey:  # Signifies BOTH a return key AND a double click
            if self.Key is not None:
                self.ParentForm.LastButtonClicked = self.Key
            else:
                self.ParentForm.LastButtonClicked = ''
            self.ParentForm.FormRemainedOpen = True
            # if self.ParentForm.CurrentlyRunningMainloop:
            #     self.ParentForm.TKroot.quit()
            _exit_mainloop(self.ParentForm)

    def _table_clicked(self, event):
        """NOTE: Not user callable method

        Callback function that is called when click happens on a `Table`.
        Stores the selected rows in Element as they are being selected. If events enabled, then returns from Read

        :param event: event information from tkinter
        :type event:  (unknown)
        """
        if not self._widget_was_created():
            return
        # popup(obj_to_string_single_obj(event))
        try:
            region = self.Widget.identify('region', event.x, event.y)
            if region == 'heading':
                row = -1
            elif region == 'cell':
                row = int(self.Widget.identify_row(event.y))-1
            elif region == 'separator':
                row = None
            else:
                row = None
            col_identified = self.Widget.identify_column(event.x)
            if col_identified:      # Sometimes tkinter returns a value of '' which would cause an error if cast to an int
                column = int(self.Widget.identify_column(event.x)[1:])-1-int(self.DisplayRowNumbers is True)
            else:
                column = None
        except Exception as e:
            warnings.warn('Error getting table click data for table with key= {}\nError: {}'.format(self.Key, e), UserWarning)
            if not SUPPRESS_ERROR_POPUPS:
                _error_popup_with_traceback('Unable to complete operation getting the clicked event for table with key {}'.format(self.Key), _create_error_message(), e, 'Event data:', obj_to_string_single_obj(event))
            row = column = None

        self.last_clicked_position = (row, column)

        # update the rows being selected if appropriate
        self.ParentForm.TKroot.update()
        # self.TKTreeview.()
        selections = self.TKTreeview.selection()
        if self.right_click_selects and len(selections) <= 1:
            if (event.num == 3 and not running_mac()) or (event.num == 2 and running_mac()):
                if row != -1 and row is not None:
                    selections = [row+1]
                    self.TKTreeview.selection_set(selections)
        # print(selections)
        self.SelectedRows = [int(x) - 1 for x in selections]
        # print('The new selected rows = ', self.SelectedRows)
        if self.enable_click_events is True:
            if self.Key is not None:
                self.ParentForm.LastButtonClicked = (self.Key, TABLE_CLICKED_INDICATOR, (row, column))
            else:
                self.ParentForm.LastButtonClicked = ''
            self.ParentForm.FormRemainedOpen = True
            _exit_mainloop(self.ParentForm)

    def get(self):
        """Get the selected rows using tktiner's selection method

        Returns a list of the selected rows.

        :return: a list of the index of the selected rows (a list of ints)
        :rtype:  List[int]
        """

        selections = self.TKTreeview.selection()
        selected_rows = [int(x) - 1 for x in selections]
        return selected_rows

    def get_last_clicked_position(self):
        """Returns a tuple with the row and column of the cell
            that was last clicked.

        Headers will have a row == -1 and the Row Number Column (if present)
        will have a column == -1

        :return: The (row,col) position of the last cell clicked in the table
        :rtype:  (int | None, int | None)
        """
        return self.last_clicked_position

    Update = update
    Get = get


# ---------------------------------------------------------------------- #
#                           Tree                                         #
# ---------------------------------------------------------------------- #
class Tree(Element):
    """Tree Element

    Presents data in a tree-like manner, much like a file/folder browser.
    Uses the `TreeData` class to hold the user's data and pass to the element for display.
    """
    def __init__(self, data=None, headings=None, visible_column_map=None, col_widths=None, col0_width=10, col0_heading='',
                 def_col_width=10, auto_size_columns=True, max_col_width=20, select_mode=None, show_expanded=False,
                 change_submits=False, enable_events=False, click_toggles_select=None, font=None, justification='right', text_color=None, border_width=None,
                 background_color=None, selected_row_colors=(None, None), header_text_color=None, header_background_color=None, header_font=None, header_border_width=None,
                 header_relief=None, num_rows=None,
                 sbar_trough_color=None, sbar_background_color=None, sbar_arrow_color=None, sbar_width=None, sbar_arrow_width=None, sbar_frame_color=None, sbar_relief=None,
                 row_height=None, vertical_scroll_only=True, hide_vertical_scroll=False, pad=None, p=None, key=None, k=None, tooltip=None,
                 right_click_menu=None, expand_x=False, expand_y=False, visible=True, metadata=None):
        """
        :param data:                    The data represented using a FreeSimpleGUI provided TreeData class
        :type data:                     (TreeData)
        :param headings:                List of individual headings for each column
        :type headings:                 List[str]
        :param visible_column_map:      Determines if a column should be visible. If left empty, all columns will be shown
        :type visible_column_map:       List[bool]
        :param col_widths:              List of column widths so that individual column widths can be controlled
        :type col_widths:               List[int]
        :param col0_width:              Size of Column 0 which is where the row numbers will be optionally shown
        :type col0_width:               (int)
        :param col0_heading:            Text to be shown in the header for the left-most column
        :type col0_heading:             (str)
        :param def_col_width:           default column width
        :type def_col_width:            (int)
        :param auto_size_columns:       if True, the size of a column is determined  using the contents of the column
        :type auto_size_columns:        (bool)
        :param max_col_width:           the maximum size a column can be
        :type max_col_width:            (int)
        :param select_mode:             Use same values as found on Table Element.  Valid values include: TABLE_SELECT_MODE_NONE TABLE_SELECT_MODE_BROWSE TABLE_SELECT_MODE_EXTENDED
        :type select_mode:              (enum)
        :param show_expanded:           if True then the tree will be initially shown with all nodes completely expanded
        :type show_expanded:            (bool)
        :param change_submits:          DO NOT USE. Only listed for backwards compat - Use enable_events instead
        :type change_submits:           (bool)
        :param enable_events:           Turns on the element specific events. Tree events happen when row is clicked
        :type enable_events:            (bool)
        :param click_toggles_select:    If True then clicking a row will cause the selection for that row to toggle between selected and deselected
        :type click_toggles_select:     (bool)
        :param font:                    specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                     (str or (str, int[, str]) or None)
        :param justification:           'left', 'right', 'center' are valid choices
        :type justification:            (str)
        :param text_color:              color of the text
        :type text_color:               (str)
        :param border_width:            Border width/depth in pixels
        :type border_width:             (int)
        :param background_color:        color of background
        :type background_color:         (str)
        :param selected_row_colors:     Sets the text color and background color for a selected row. Same format as button colors - tuple ('red', 'yellow') or string 'red on yellow'. Defaults to theme's button color
        :type selected_row_colors:      str or (str, str)
        :param header_text_color:       sets the text color for the header
        :type header_text_color:        (str)
        :param header_background_color: sets the background color for the header
        :type header_background_color:  (str)
        :param header_font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type header_font:              (str or (str, int[, str]) or None)
        :param header_border_width:     Border width for the header portion
        :type header_border_width:      (int | None)
        :param header_relief:           Relief style for the header. Values are same as other elements that use relief. RELIEF_RAISED RELIEF_SUNKEN RELIEF_FLAT RELIEF_RIDGE RELIEF_GROOVE RELIEF_SOLID
        :type header_relief:            (str | None)
        :param num_rows:                The number of rows of the table to display at a time
        :type num_rows:                 (int)
        :param row_height:              height of a single row in pixels
        :type row_height:               (int)
        :param vertical_scroll_only:    if True only the vertical scrollbar will be visible
        :type vertical_scroll_only:     (bool)
        :param hide_vertical_scroll:    if True vertical scrollbar will be hidden
        :type hide_vertical_scroll:     (bool)
        :param sbar_trough_color:           Scrollbar color of the trough
        :type sbar_trough_color:            (str)
        :param sbar_background_color:       Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:        (str)
        :param sbar_arrow_color:            Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:             (str)
        :param sbar_width:                  Scrollbar width in pixels
        :type sbar_width:                   (int)
        :param sbar_arrow_width:            Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:             (int)
        :param sbar_frame_color:            Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:             (str)
        :param sbar_relief:                 Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                  (str)
        :param pad:                     Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
        :type pad:                      (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param p:                       Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
        :type p:                        (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
        :param key:                     Used with window.find_element and with return values to uniquely identify this element to uniquely identify this element
        :type key:                      str | int | tuple | object
        :param k:                       Same as the Key. You can use either k or key. Which ever is set will be used.
        :type k:                        str | int | tuple | object
        :param tooltip:                 text, that will appear when mouse hovers over the element
        :type tooltip:                  (str)
        :param right_click_menu:        A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:         List[List[str] | str]]
        :param expand_x:                If True the element will automatically expand in the X direction to fill available space
        :type expand_x:                 (bool)
        :param expand_y:                If True the element will automatically expand in the Y direction to fill available space
        :type expand_y:                 (bool)
        :param visible:                 set visibility state of the element
        :type visible:                  (bool)
        :param metadata:                User metadata that can be set to ANYTHING
        :type metadata:                 (Any)
        """

        self.image_dict = {}

        self.TreeData = data
        self.ColumnHeadings = headings
        self.ColumnsToDisplay = visible_column_map
        self.ColumnWidths = col_widths
        self.MaxColumnWidth = max_col_width
        self.DefaultColumnWidth = def_col_width
        self.AutoSizeColumns = auto_size_columns
        self.BackgroundColor = background_color if background_color is not None else DEFAULT_BACKGROUND_COLOR
        self.TextColor = text_color
        self.HeaderTextColor = header_text_color if header_text_color is not None else LOOK_AND_FEEL_TABLE[CURRENT_LOOK_AND_FEEL]['TEXT_INPUT']
        self.HeaderBackgroundColor = header_background_color if header_background_color is not None else LOOK_AND_FEEL_TABLE[CURRENT_LOOK_AND_FEEL]['INPUT']
        self.HeaderBorderWidth = header_border_width
        self.BorderWidth = border_width
        self.HeaderRelief = header_relief
        self.click_toggles_select = click_toggles_select
        if selected_row_colors == (None, None):
            # selected_row_colors = DEFAULT_TABLE_AND_TREE_SELECTED_ROW_COLORS
            selected_row_colors = theme_button_color()
        else:
            try:
                if isinstance(selected_row_colors, str):
                    selected_row_colors = selected_row_colors.split(' on ')
            except Exception as e:
                print('* Table Element Warning * you messed up with color formatting of Selected Row Color', e)
        self.SelectedRowColors = selected_row_colors

        self.HeaderFont = header_font
        self.Justification = justification
        self.InitialState = None
        self.SelectMode = select_mode
        self.ShowExpanded = show_expanded
        self.NumRows = num_rows
        self.Col0Width = col0_width
        self.col0_heading = col0_heading
        self.TKTreeview = None  # type: ttk.Treeview
        self.element_frame = None  # type: tk.Frame
        self.VerticalScrollOnly = vertical_scroll_only
        self.HideVerticalScroll = hide_vertical_scroll
        self.SelectedRows = []
        self.ChangeSubmits = change_submits or enable_events
        self.RightClickMenu = right_click_menu
        self.RowHeight = row_height
        self.IconList = {}
        self.IdToKey = {'': ''}
        self.KeyToID = {'': ''}
        key = key if key is not None else k
        pad = pad if pad is not None else p
        self.expand_x = expand_x
        self.expand_y = expand_y

        super().__init__(ELEM_TYPE_TREE, text_color=text_color, background_color=background_color, font=font, pad=pad, key=key, tooltip=tooltip,
                         visible=visible, metadata=metadata,
                         sbar_trough_color=sbar_trough_color, sbar_background_color=sbar_background_color, sbar_arrow_color=sbar_arrow_color, sbar_width=sbar_width,
                         sbar_arrow_width=sbar_arrow_width, sbar_frame_color=sbar_frame_color, sbar_relief=sbar_relief)
        return

    def _treeview_selected(self, event):
        """NOTE: Not a user callable method

        Callback function that happens when an item is selected from the tree.
        In this method, it saves away the reported selections so they can be properly returned.

        :param event: An event parameter passed in by tkinter.  Not used
        :type event:  (Any)
        """

        selections = self.TKTreeview.selection()
        selected_rows = [self.IdToKey[x] for x in selections]
        if self.click_toggles_select:
            if set(self.SelectedRows) == set(selected_rows):
                for item in selections:
                    self.TKTreeview.selection_remove(item)
                selections = []
        self.SelectedRows = [self.IdToKey[x] for x in selections]

        if self.ChangeSubmits:
            MyForm = self.ParentForm
            if self.Key is not None:
                self.ParentForm.LastButtonClicked = self.Key
            else:
                self.ParentForm.LastButtonClicked = ''
            self.ParentForm.FormRemainedOpen = True
            # if self.ParentForm.CurrentlyRunningMainloop:
            #     self.ParentForm.TKroot.quit()
            _exit_mainloop(self.ParentForm)

    def add_treeview_data(self, node):
        """NOTE: Not a user callable method

        Recursive method that inserts tree data into the tkinter `TreeView` widget.

        :param node: The node to insert.  Will insert all nodes from starting point downward, recursively
        :type node:  (TreeData)
        """
        if node.key != '':
            if node.icon:
                try:
                    if node.icon not in self.image_dict:
                        if type(node.icon) is bytes:
                            photo = tk.PhotoImage(data=node.icon)
                        else:
                            photo = tk.PhotoImage(file=node.icon)
                        self.image_dict[node.icon] = photo
                    else:
                        photo = self.image_dict.get(node.icon)

                    node.photo = photo
                    id = self.TKTreeview.insert(self.KeyToID[node.parent], 'end', iid=None, text=node.text,
                                                values=node.values, open=self.ShowExpanded, image=node.photo)
                    self.IdToKey[id] = node.key
                    self.KeyToID[node.key] = id
                except:
                    self.photo = None
            else:
                id = self.TKTreeview.insert(self.KeyToID[node.parent], 'end', iid=None, text=node.text,
                                            values=node.values, open=self.ShowExpanded)
                self.IdToKey[id] = node.key
                self.KeyToID[node.key] = id

        for node in node.children:
            self.add_treeview_data(node)

    def update(self, values=None, key=None, value=None, text=None, icon=None, visible=None, expand_node=None):
        """Changes some of the settings for the Tree Element

        Must call `Window.Read` or `Window.Finalize` prior.
        Changes will not be visible in your window until you call `window.read` or `window.refresh`.

        If you change visibility, your element may MOVE. If you want it to remain stationary, use the 'layout helper'
        function 'pin' to ensure your element is 'pinned' to that location in your layout so that it returns there
        when made visible.

        :param values:      Representation of the tree
        :type values:       (TreeData)
        :param key:         identifies a particular item in tree to update
        :type key:          str | int | tuple | object
        :param value:       sets the node identified by key to a particular value
        :type value:        (Any)
        :param text:        sets the node identified by key to this string
        :type text:         (str)
        :param icon:        can be either a base64 icon or a filename for the icon
        :type icon:         bytes | str
        :param visible:     control visibility of element
        :type visible:      (bool)
        :param expand_node: if True the node specified by key parameter will be expanded
        :type expand_node:  (bool)
        """

        if not self._widget_was_created():
            return

        if self._this_elements_window_closed():
            _error_popup_with_traceback('Error in Tree.update:\n- The window was closed')
            return

        if values is not None:
            children = self.TKTreeview.get_children()
            for i in children:
                self.TKTreeview.detach(i)
                self.TKTreeview.delete(i)
            children = self.TKTreeview.get_children()
            self.TreeData = values
            self.IdToKey = {'': ''}
            self.KeyToID = {'': ''}
            self.add_treeview_data(self.TreeData.root_node)
            self.SelectedRows = []
        if key is not None:
            for id in self.IdToKey.keys():
                if key == self.IdToKey[id]:
                    break
            else:
                id = None
                print('** Key not found **')
        else:
            id = None
        if id:
            # item = self.TKTreeview.item(id)
            if value is not None:
                self.TKTreeview.item(id, values=value)
            if text is not None:
                self.TKTreeview.item(id, text=text)
            if icon is not None:
                try:
                    if type(icon) is bytes:
                        photo = tk.PhotoImage(data=icon)
                    else:
                        photo = tk.PhotoImage(file=icon)
                    self.TKTreeview.item(id, image=photo)
                    self.IconList[key] = photo  # save so that it's not deleted (save reference)
                except:
                    pass
            # item = self.TKTreeview.item(id)
        if visible is False:
            self._pack_forget_save_settings(self.element_frame)
        elif visible is True:
            self._pack_restore_settings(self.element_frame)

        if visible is not None:
            self._visible = visible
        if expand_node is not None:
            if id:
                self.TKTreeview.item(id, open=True if expand_node else False)
        return self

    Update = update


class TreeData(object):
    """
    Class that user fills in to represent their tree data. It's a very simple tree representation with a root `Node`
    with possibly one or more children `Node`s.  Each Node contains a key, text to display, list of values to display
    and an icon.  The entire tree is built using a single method, Insert.  Nothing else is required to make the tree.
    """
    class Node(object):
        """Contains information about the individual node in the tree"""
        def __init__(self, parent, key, text, values, icon=None):
            """
            Represents a node within the TreeData class

            :param parent: The parent Node
            :type parent:  (TreeData.Node)
            :param key:    Used to uniquely identify this node
            :type key:     str | int | tuple | object
            :param text:   The text that is displayed at this node's location
            :type text:    (str)
            :param values: The list of values that are displayed at this node
            :type values:  List[Any]
            :param icon:   just a icon
            :type icon:    str | bytes
            """

            self.parent = parent  # type: TreeData.Node
            self.children = []  # type: List[TreeData.Node]
            self.key = key  # type: str
            self.text = text  # type: str
            self.values = values  # type: List[Any]
            self.icon = icon  # type: str | bytes

        def _Add(self, node):
            self.children.append(node)

    def __init__(self):
        """Instantiates the object, initializes the `TreeData`, creates a root node for you"""
        self.tree_dict = {}  # type: Dict[str, TreeData.Node]
        self.root_node = self.Node("", "", 'root', [], None)  # The root node
        self.tree_dict[""] = self.root_node  # Start the tree out with the root node

    def _AddNode(self, key, node):
        """NOTE: Not user callable method

        Adds a node to tree dictionary.

        :param key:  Uniquely identifies this Node
        :type key:   (str)
        :param node: Node being added
        :type node:  (TreeData.Node)
        """
        self.tree_dict[key] = node

    def insert(self, parent, key, text, values, icon=None):
        """Inserts a node into the tree

        This is how user builds their tree, by Inserting `Node`s.
        This is the ONLY user callable method in the `TreeData` class.

        :param parent: the parent Node
        :type parent:  (Node)
        :param key:    Used to uniquely identify this node
        :type key:     str | int | tuple | object
        :param text:   The text that is displayed at this node's location
        :type text:    (str)
        :param values: The list of values that are displayed at this node
        :type values:  List[Any]
        :param icon:   icon
        :type icon:    str | bytes
        """

        node = self.Node(parent, key, text, values, icon)
        self.tree_dict[key] = node
        parent_node = self.tree_dict[parent]
        parent_node._Add(node)

    def __repr__(self):
        """Converts the `TreeData` into a printable version, nicely formatted

        :return: (str) A formatted, text version of the TreeData
        :rtype:
        """
        return self._NodeStr(self.root_node, 1)

    def _NodeStr(self, node, level):
        """Does the actual conversion of the `TreeData` into a nicely formatted string

        :param node:  The node to begin printing the tree
        :type node:   (TreeData.Node)
        :param level: The indentation level for string formatting
        :type level:  (int)
        """
        return '\n'.join(
            [str(node.key) + ' : ' + str(node.text) + ' [ ' + ', '.join([str(v) for v in node.values]) + ' ]'] +
            [' ' * 4 * level + self._NodeStr(child, level + 1) for child in node.children])

    Insert = insert


# ---------------------------------------------------------------------- #
#                           Error Element                                #
# ---------------------------------------------------------------------- #
class ErrorElement(Element):
    """A dummy Element that's returned when on error conditions

    Like trying to find an element that's invalid.
    """
    def __init__(self, key=None, metadata=None):
        """
        :param key: Used with window.find_element and with return values to uniquely identify this element
        :type key:
        """
        self.Key = key

        super().__init__(ELEM_TYPE_ERROR, key=key, metadata=metadata)

    def update(self, silent_on_error=True, *args, **kwargs):
        """Update method for the ErrorElement, an element

        Should not be directly used by developers.

        :param silent_on_error: if False, then a Popup window will be shown
        :type silent_on_error:  (bool)
        :param *args:           meant to "soak up" any normal parameters passed in
        :type *args:            (Any)
        :param **kwargs:        meant to "soak up" any keyword parameters that were passed in
        :type **kwargs:         (Any)
        :return:                returns 'self' so call can be chained
        :rtype:                 (ErrorElement)
        """
        print('** Your update is being ignored because you supplied a bad key earlier **')
        return self

    def get(self):
        """One of the method names found in other Elements

        Used here to return an error string in case it's called.

        :return: A warning text string.
        :rtype:  (str)
        """
        return 'This is NOT a valid Element!\nSTOP trying to do things with it or I will have to crash at some point!'

    Get = get
    Update = update


# ---------------------------------------------------------------------- #
#                           Stretch Element                              #
# ---------------------------------------------------------------------- #
# This is for source code compatibility with tkinter version. No tkinter equivalent but you can fake it using a Text element that expands in the X direction
def Push(background_color=None):
    """Acts like a Stretch element found in the Qt port

    Used in a Horizontal fashion.
    Placing one on each side of an element will enter the element.
    Place one to the left and the element to the right will be right justified.
    See `VStretch` for vertical type

    :param background_color: color of background may be needed because of how this is implemented
    :type background_color:  (str)
    :return:                 (Text)
    """
    return Text(font='_ 1', background_color=background_color, pad=(0, 0), expand_x=True)


P = Push
Stretch = Push


def VPush(background_color=None):
    """Acts like a Stretch element found in the Qt port

    Used in a Vertical fashion.

    :param background_color: color of background may be needed because of how this is implemented
    :type background_color:  (str)
    :return:                 (Text)
    """
    return Text(font='_ 1', background_color=background_color, pad=(0, 0), expand_y=True)


VStretch = VPush
VP = VPush


# ------------------------------------------------------------------------- #
#                       _TimerPeriodic CLASS                                #
# ------------------------------------------------------------------------- #

class _TimerPeriodic:
    id_counter = 1
    # Dictionary containing the active timers.
    # Format is {id : _TimerPeriodic object}
    active_timers = {}  # type: dict[int:_TimerPeriodic]

    def __init__(self, window, frequency_ms, key=EVENT_TIMER, repeating=True):
        """
        :param window:          The window to send events to
        :type window:           Window
        :param frequency_ms:    How often to send events in milliseconds
        :type frequency_ms:     int
        :param repeating:       If True then the timer will run, repeatedly sending events, until stopped
        :type repeating:        bool
        """
        self.window = window
        self.frequency_ms = frequency_ms
        self.repeating = repeating
        self.key = key
        self.id = _TimerPeriodic.id_counter
        _TimerPeriodic.id_counter += 1
        self.start()

    @classmethod
    def stop_timer_with_id(cls, timer_id):
        """NOTE: Not user callable!

        :return: A simple counter that makes each container element unique
        :rtype:
        """
        timer = cls.active_timers.get(timer_id, None)
        if timer is not None:
            timer.stop()

    @classmethod
    def stop_all_timers_for_window(cls, window):
        """ Stops all timers for a given window

        :param window:      The window to stop timers for
        :type window:       Window
        """
        for timer in _TimerPeriodic.active_timers.values():
            if timer.window == window:
                timer.running = False

    @classmethod
    def get_all_timers_for_window(cls, window):
        """Returns a list of timer IDs for a given window

        :param window:      The window to find timers for
        :type window:       Window
        :return:            List of timer IDs for the window
        :rtype:             List[int]
        """
        timers = []
        for timer in _TimerPeriodic.active_timers.values():
            if timer.window == window:
                timers.append(timer.id)

        return timers

    def timer_thread(self):
        """The thread that sends events to the window

        Runs either once or in a loop until timer is stopped.
        """

        if not self.running:  # if timer has been cancelled, abort
            del _TimerPeriodic.active_timers[self.id]
            return
        while True:
            time.sleep(self.frequency_ms / 1000)
            if not self.running:  # if timer has been cancelled, abort
                del _TimerPeriodic.active_timers[self.id]
                return
            self.window.write_event_value(self.key, self.id)

            if not self.repeating:  # if timer does not repeat, then exit thread
                del _TimerPeriodic.active_timers[self.id]
                return

    def start(self):
        """Starts a timer by starting a timer thread

        Adds timer to the list of active timers
        """
        self.running = True
        self.thread = threading.Thread(target=self.timer_thread, daemon=True)
        self.thread.start()
        _TimerPeriodic.active_timers[self.id] = self

    def stop(self):
        """Stops a timer"""
        self.running = False


# ------------------------------------------------------------------------- #
#                       Window CLASS                                        #
# ------------------------------------------------------------------------- #
class Window:
    """Represents a single Window"""

    NumOpenWindows = 0
    _user_defined_icon = None
    hidden_master_root = None  # type: tk.Tk
    _animated_popup_dict = {}  # type: Dict
    _active_windows = {}  # type: Dict[Window, tk.Tk()]
    _move_all_windows = False  # if one window moved, they will move
    _window_that_exited = None  # type: Window
    _root_running_mainloop = None  # type: tk.Tk()    # (may be the hidden root or a window's root)
    _timeout_key = None
    _TKAfterID = None  # timer that is used to run reads with timeouts
    _window_running_mainloop = None  # The window that is running the mainloop
    _container_element_counter = 0  # used to get a number of Container Elements (Frame, Column, Tab)
    _read_call_from_debugger = False
    _timeout_0_counter = 0  # when timeout=0 then go through each window one at a time
    _counter_for_ttk_widgets = 0
    _floating_debug_window_build_needed = False
    _main_debug_window_build_needed = False
    # rereouted stdout info. List of tuples (window, element, previous destination)
    _rerouted_stdout_stack = []  # type: List[Tuple[Window, Element]]
    _rerouted_stderr_stack = []  # type: List[Tuple[Window, Element]]
    _original_stdout = None
    _original_stderr = None


    def __init__(self, title, layout=None, default_element_size=None,
                 default_button_element_size=(None, None),
                 auto_size_text=None, auto_size_buttons=None, location=(None, None), relative_location=(None, None), auto_save_location=False, size=(None, None),
                 element_padding=None, margins=(None, None), button_color=None, font=None,
                 progress_bar_color=(None, None), background_color=None, border_depth=None, auto_close=False,
                 auto_close_duration=DEFAULT_AUTOCLOSE_TIME, icon=None, force_toplevel=False,
                 alpha_channel=None, return_keyboard_events=False, use_default_focus=True, text_justification=None,
                 no_titlebar=False, grab_anywhere=False, grab_anywhere_using_control=True, keep_on_top=None, resizable=False, disable_close=False,
                 disable_minimize=False, right_click_menu=None, transparent_color=None, debugger_enabled=False,
                 right_click_menu_background_color=None, right_click_menu_text_color=None, right_click_menu_disabled_text_color=None, right_click_menu_selected_colors=(None, None),
                 right_click_menu_font=None, right_click_menu_tearoff=False,
                 finalize=False, element_justification='left', ttk_theme=None, use_ttk_buttons=None, modal=False, enable_close_attempted_event=False,
                 enable_window_config_events=False,
                 titlebar_background_color=None, titlebar_text_color=None, titlebar_font=None, titlebar_icon=None,
                 use_custom_titlebar=None, scaling=None,
                 sbar_trough_color=None, sbar_background_color=None, sbar_arrow_color=None, sbar_width=None, sbar_arrow_width=None, sbar_frame_color=None, sbar_relief=None, watermark=None, print_event_values=None,
                 metadata=None):
        """
        :param title:                                The title that will be displayed in the Titlebar and on the Taskbar
        :type title:                                 (str)
        :param layout:                               The layout for the window. Can also be specified in the Layout method
        :type layout:                                List[List[Element]] | Tuple[Tuple[Element]]
        :param default_element_size:                 size in characters (wide) and rows (high) for all elements in this window
        :type default_element_size:                  (int, int) - (width, height)
        :param default_button_element_size:          (width, height) size in characters (wide) and rows (high) for all Button elements in this window
        :type default_button_element_size:           (int, int)
        :param auto_size_text:                       True if Elements in Window should be sized to exactly fir the length of text
        :type auto_size_text:                        (bool)
        :param auto_size_buttons:                    True if Buttons in this Window should be sized to exactly fit the text on this.
        :type auto_size_buttons:                     (bool)
        :param location:                             (x,y) location, in pixels, to locate the upper left corner of the window on the screen. Default is to center on screen. None will not set any location meaning the OS will decide
        :type location:                              (int, int) or (None, None) or None
        :param relative_location:                    (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
        :type relative_location:                     (int, int)
        :param auto_save_location:                   If True the windows location will be automatically saved to a settings file and will be reloaded next time the program is run. Save happens when window close is detected
        :type auto_save_location:                    (bool)
        :param size:                                 (width, height) size in pixels for this window. Normally the window is autosized to fit contents, not set to an absolute size by the user. Try not to set this value. You risk, the contents being cut off, etc. Let the layout determine the window size instead
        :type size:                                  (int, int)
        :param element_padding:                      Default amount of padding to put around elements in window (left/right, top/bottom) or ((left, right), (top, bottom)), or an int. If an int, then it's converted into a tuple (int, int)
        :type element_padding:                       (int, int) or ((int, int),(int,int)) or int
        :param margins:                              (left/right, top/bottom) Amount of pixels to leave inside the window's frame around the edges before your elements are shown.
        :type margins:                               (int, int)
        :param button_color:                         Default button colors for all buttons in the window
        :type button_color:                          (str, str) | str
        :param font:                                 specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                                  (str or (str, int[, str]) or None)
        :param progress_bar_color:                   (bar color, background color) Sets the default colors for all progress bars in the window
        :type progress_bar_color:                    (str, str)
        :param background_color:                     color of background
        :type background_color:                      (str)
        :param border_depth:                         Default border depth (width) for all elements in the window
        :type border_depth:                          (int)
        :param auto_close:                           If True, the window will automatically close itself
        :type auto_close:                            (bool)
        :param auto_close_duration:                  Number of seconds to wait before closing the window
        :type auto_close_duration:                   (int)
        :param icon:                                 Can be either a filename or Base64 value. For Windows if filename, it MUST be ICO format. For Linux, must NOT be ICO. Most portable is to use a Base64 of a PNG file. This works universally across all OS's
        :type icon:                                  (str | bytes)
        :param force_toplevel:                       If True will cause this window to skip the normal use of a hidden master window
        :type force_toplevel:                        (bool)
        :param alpha_channel:                        Sets the opacity of the window. 0 = invisible 1 = completely visible. Values bewteen 0 & 1 will produce semi-transparent windows in SOME environments (The Raspberry Pi always has this value at 1 and cannot change.
        :type alpha_channel:                         (float)
        :param return_keyboard_events:               if True key presses on the keyboard will be returned as Events from Read calls
        :type return_keyboard_events:                (bool)
        :param use_default_focus:                    If True will use the default focus algorithm to set the focus to the "Correct" element
        :type use_default_focus:                     (bool)
        :param text_justification:                   Default text justification for all Text Elements in window
        :type text_justification:                    'left' | 'right' | 'center'
        :param no_titlebar:                          If true, no titlebar nor frame will be shown on window. This means you cannot minimize the window and it will not show up on the taskbar
        :type no_titlebar:                           (bool)
        :param grab_anywhere:                        If True can use mouse to click and drag to move the window. Almost every location of the window will work except input fields on some systems
        :type grab_anywhere:                         (bool)
        :param grab_anywhere_using_control:          If True can use CONTROL key + left mouse mouse to click and drag to move the window. DEFAULT is TRUE. Unlike normal grab anywhere, it works on all elements.
        :type grab_anywhere_using_control:           (bool)
        :param keep_on_top:                          If True, window will be created on top of all other windows on screen. It can be bumped down if another window created with this parm
        :type keep_on_top:                           (bool)
        :param resizable:                            If True, allows the user to resize the window. Note the not all Elements will change size or location when resizing.
        :type resizable:                             (bool)
        :param disable_close:                        If True, the X button in the top right corner of the window will no work.  Use with caution and always give a way out toyour users
        :type disable_close:                         (bool)
        :param disable_minimize:                     if True the user won't be able to minimize window.  Good for taking over entire screen and staying that way.
        :type disable_minimize:                      (bool)
        :param right_click_menu:                     A list of lists of Menu items to show when this element is right clicked. See user docs for exact format.
        :type right_click_menu:                      List[List[ List[str] | str ]]
        :param transparent_color:                    Any portion of the window that has this color will be completely transparent. You can even click through these spots to the window under this window.
        :type transparent_color:                     (str)
        :param debugger_enabled:                     If True then the internal debugger will be enabled.  Also controllable via the global settings.  If global settings is true then will be enabled for all windows
        :type debugger_enabled:                      (bool)
        :param right_click_menu_background_color:    Background color for right click menus
        :type right_click_menu_background_color:     (str)
        :param right_click_menu_text_color:          Text color for right click menus
        :type right_click_menu_text_color:           (str)
        :param right_click_menu_disabled_text_color: Text color for disabled right click menu items
        :type right_click_menu_disabled_text_color:  (str)
        :param right_click_menu_selected_colors:     Text AND background colors for a selected item. Can be a Tuple OR a color string. simplified-button-color-string "foreground on background". Can be a single color if want to set only the background. Normally a tuple, but can be a simplified-dual-color-string "foreground on background". Can be a single color if want to set only the background.
        :type right_click_menu_selected_colors:      (str, str) | str | Tuple
        :param right_click_menu_font:                Font for right click menus
        :type right_click_menu_font:                 (str or (str, int[, str]) or None)
        :param right_click_menu_tearoff:             If True then all right click menus can be torn off
        :type right_click_menu_tearoff:              bool
        :param finalize:                             If True then the Finalize method will be called. Use this rather than chaining .Finalize for cleaner code
        :type finalize:                              (bool)
        :param element_justification:                All elements in the Window itself will have this justification 'left', 'right', 'center' are valid values
        :type element_justification:                 (str)
        :param ttk_theme:                            Set the tkinter ttk "theme" of the window.  Default = DEFAULT_TTK_THEME.  Sets all ttk widgets to this theme as their default
        :type ttk_theme:                             (str)
        :param use_ttk_buttons:                      Affects all buttons in window. True = use ttk buttons. False = do not use ttk buttons.  None = use ttk buttons only if on a Mac
        :type use_ttk_buttons:                       (bool)
        :param modal:                                If True then this window will be the only window a user can interact with until it is closed
        :type modal:                                 (bool)
        :param enable_close_attempted_event:         If True then the window will not close when "X" clicked. Instead an event WINDOW_CLOSE_ATTEMPTED_EVENT if returned from window.read
        :type enable_close_attempted_event:          (bool)
        :param enable_window_config_events:          If True then window configuration events (resizing or moving the window) will return WINDOW_CONFIG_EVENT from window.read. Note you will get several when Window is created.
        :type enable_window_config_events:           (bool)
        :param titlebar_background_color:            If custom titlebar indicated by use_custom_titlebar, then use this as background color
        :type titlebar_background_color:             (str | None)
        :param titlebar_text_color:                  If custom titlebar indicated by use_custom_titlebar, then use this as text color
        :type titlebar_text_color:                   (str | None)
        :param titlebar_font:                        If custom titlebar indicated by use_custom_titlebar, then use this as title font
        :type titlebar_font:                         (str or (str, int[, str]) or None)
        :param titlebar_icon:                        If custom titlebar indicated by use_custom_titlebar, then use this as the icon (file or base64 bytes)
        :type titlebar_icon:                         (bytes | str)
        :param use_custom_titlebar:                  If True, then a custom titlebar will be used instead of the normal titlebar
        :type use_custom_titlebar:                   bool
        :param scaling:                              Apply scaling to the elements in the window. Can be set on a global basis using set_options
        :type scaling:                               float
        :param sbar_trough_color:                    Scrollbar color of the trough
        :type sbar_trough_color:                     (str)
        :param sbar_background_color:                Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
        :type sbar_background_color:                 (str)
        :param sbar_arrow_color:                     Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
        :type sbar_arrow_color:                      (str)
        :param sbar_width:                           Scrollbar width in pixels
        :type sbar_width:                            (int)
        :param sbar_arrow_width:                     Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
        :type sbar_arrow_width:                      (int)
        :param sbar_frame_color:                     Scrollbar Color of frame around scrollbar (available only on some ttk themes)
        :type sbar_frame_color:                      (str)
        :param sbar_relief:                          Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
        :type sbar_relief:                           (str)
        :param watermark:                            If True, then turns on watermarking temporarily for ALL windows created from this point forward. See global settings doc for more info
        :type watermark:                             bool
        :param print_event_values:                   If True then the event and values will be automatically printed when you call the window's read method. GREAT for debugging! Global setting also available to control this.
        :type print_event_values:                    bool
        :param metadata:                             User metadata that can be set to ANYTHING
        :type metadata:                              (Any)
        """

        self._metadata = None  # type: Any
        self.AutoSizeText = auto_size_text if auto_size_text is not None else DEFAULT_AUTOSIZE_TEXT
        self.AutoSizeButtons = auto_size_buttons if auto_size_buttons is not None else DEFAULT_AUTOSIZE_BUTTONS
        self.Title = str(title)
        self.Rows = []  # a list of ELEMENTS for this row
        self.DefaultElementSize = default_element_size if default_element_size is not None else DEFAULT_ELEMENT_SIZE
        self.DefaultButtonElementSize = default_button_element_size if default_button_element_size != (
            None, None) else DEFAULT_BUTTON_ELEMENT_SIZE
        if DEFAULT_WINDOW_LOCATION != (None, None) and location == (None, None):
            self.Location = DEFAULT_WINDOW_LOCATION
        else:
            self.Location = location
        self.RelativeLoction = relative_location
        self.ButtonColor = button_color_to_tuple(button_color)
        self.BackgroundColor = background_color if background_color else DEFAULT_BACKGROUND_COLOR
        self.ParentWindow = None
        self.Font = font if font else DEFAULT_FONT
        self.RadioDict = {}
        self.BorderDepth = border_depth
        if icon:
            self.WindowIcon = icon
        elif Window._user_defined_icon is not None:
            self.WindowIcon = Window._user_defined_icon
        else:
            self.WindowIcon = DEFAULT_WINDOW_ICON
        self.AutoClose = auto_close
        self.NonBlocking = False
        self.TKroot = None  # type: tk.Tk
        self.TKrootDestroyed = False
        self.CurrentlyRunningMainloop = False
        self.FormRemainedOpen = False
        self.TKAfterID = None
        self.ProgressBarColor = progress_bar_color
        self.AutoCloseDuration = auto_close_duration
        self.RootNeedsDestroying = False
        self.Shown = False
        self.ReturnValues = None
        self.ReturnValuesList = []
        self.ReturnValuesDictionary = {}
        self.DictionaryKeyCounter = 0
        self.LastButtonClicked = None
        self.LastButtonClickedWasRealtime = False
        self.UseDictionary = False
        self.UseDefaultFocus = use_default_focus
        self.ReturnKeyboardEvents = return_keyboard_events
        self.LastKeyboardEvent = None
        self.TextJustification = text_justification
        self.NoTitleBar = no_titlebar
        self.Grab = grab_anywhere
        self.GrabAnywhere = grab_anywhere
        self.GrabAnywhereUsingControlKey = grab_anywhere_using_control
        if keep_on_top is None and DEFAULT_KEEP_ON_TOP is not None:
            keep_on_top = DEFAULT_KEEP_ON_TOP
        elif keep_on_top is None:
            keep_on_top = False
        self.KeepOnTop = keep_on_top
        self.ForceTopLevel = force_toplevel
        self.Resizable = resizable
        self._AlphaChannel = alpha_channel if alpha_channel is not None else DEFAULT_ALPHA_CHANNEL
        self.Timeout = None
        self.TimeoutKey = TIMEOUT_KEY
        self.TimerCancelled = False
        self.DisableClose = disable_close
        self.DisableMinimize = disable_minimize
        self._Hidden = False
        self._Size = size
        self.XFound = False
        if element_padding is not None:
            if isinstance(element_padding, int):
                element_padding = (element_padding, element_padding)

        if element_padding is None:
            self.ElementPadding = DEFAULT_ELEMENT_PADDING
        else:
            self.ElementPadding = element_padding
        self.RightClickMenu = right_click_menu
        self.Margins = margins if margins != (None, None) else DEFAULT_MARGINS
        self.ContainerElemementNumber = Window._GetAContainerNumber()
        # The dictionary containing all elements and keys for the window
        # The keys are the keys for the elements and the values are the elements themselves.
        self.AllKeysDict = {}
        self.TransparentColor = transparent_color
        self.UniqueKeyCounter = 0
        if freesimplegui_user_settings.get('-enable debugger-', False) or debugger_enabled:
            self.DebuggerEnabled = True
        else:
            self.DebuggerEnabled = False
        self.WasClosed = False
        self.ElementJustification = element_justification
        self.FocusSet = False
        self.metadata = metadata
        self.TtkTheme = ttk_theme or DEFAULT_TTK_THEME
        self.UseTtkButtons = use_ttk_buttons if use_ttk_buttons is not None else USE_TTK_BUTTONS
        self.user_bind_dict = {}  # Used when user defines a tkinter binding using bind method - convert bind string to key modifier
        self.user_bind_event = None  # Used when user defines a tkinter binding using bind method - event data from tkinter
        self.modal = modal
        self.thread_queue = None  # type: queue.Queue
        self.thread_lock = None  # type: threading.Lock
        self.thread_timer = None  # type: tk.Misc
        self.thread_strvar = None  # type: tk.StringVar
        self.read_closed_window_count = 0
        self.config_last_size = (None, None)
        self.config_last_location = (None, None)
        self.starting_window_position = (None, None)
        self.not_completed_initial_movement = True
        self.config_count = 0
        self.saw_00 = False
        self.maximized = False
        self.right_click_menu_background_color = right_click_menu_background_color if right_click_menu_background_color is not None else theme_input_background_color()
        self.right_click_menu_text_color = right_click_menu_text_color if right_click_menu_text_color is not None else theme_input_text_color()
        self.right_click_menu_disabled_text_color = right_click_menu_disabled_text_color if right_click_menu_disabled_text_color is not None else COLOR_SYSTEM_DEFAULT
        self.right_click_menu_font = right_click_menu_font if right_click_menu_font is not None else self.Font
        self.right_click_menu_tearoff = right_click_menu_tearoff
        self.auto_close_timer_needs_starting = False
        self.finalize_in_progress = False
        self.close_destroys_window = not enable_close_attempted_event if enable_close_attempted_event is not None else None
        self.enable_window_config_events = enable_window_config_events
        self.override_custom_titlebar = False
        self.use_custom_titlebar = use_custom_titlebar or theme_use_custom_titlebar()
        self.titlebar_background_color = titlebar_background_color
        self.titlebar_text_color = titlebar_text_color
        self.titlebar_font = titlebar_font
        self.titlebar_icon = titlebar_icon
        self.right_click_menu_selected_colors = _simplified_dual_color_to_tuple(right_click_menu_selected_colors,
                                                                                (self.right_click_menu_background_color, self.right_click_menu_text_color))
        self.TKRightClickMenu = None
        self._grab_anywhere_ignore_these_list = []
        self._grab_anywhere_include_these_list = []
        self._has_custom_titlebar = use_custom_titlebar
        self._mousex = self._mousey = 0
        self._startx = self._starty = 0
        self._last_location = (None, None) # used by a property
        self.auto_save_location = auto_save_location
        if auto_save_location is True:
            self.Location = user_settings_get_entry('-LAST WINDOW LOCATION-'+title, self.Location)
        self.scaling = scaling if scaling is not None else DEFAULT_SCALING

        if self.use_custom_titlebar:
            self.Margins = (0, 0)
            self.NoTitleBar = True

        self._mouse_offset_x = self._mouse_offset_y = 0
        self.watermark = watermark
        # use the print event values setting if explicitly turned on or disable if explicitly turned off in this window
        if print_event_values is True or (freesimplegui_user_settings.get('-print event values-', False) and print_event_values is not False):
            self.print_event_values = True
        else:
            self.print_event_values = False

        self.ttk_part_overrides = TTKPartOverrides(sbar_trough_color=sbar_trough_color, sbar_background_color=sbar_background_color, sbar_arrow_color=sbar_arrow_color, sbar_width=sbar_width, sbar_arrow_width=sbar_arrow_width, sbar_frame_color=sbar_frame_color, sbar_relief=sbar_relief)

        if no_titlebar is True:
            self.override_custom_titlebar = True

        if layout is not None and type(layout) not in (list, tuple):
            warnings.warn('Your layout is not a list or tuple... this is not good!')

        if layout is not None:
            self.Layout(layout)
            if finalize:
                self.Finalize()

        if CURRENT_LOOK_AND_FEEL == 'Default':
            print("Window will be a boring gray. Try removing the theme call entirely\n",
                  "You will get the default theme or the one set in global settings\n"
                  "If you seriously want this gray window and no more nagging, add  theme('DefaultNoMoreNagging')  or theme('Gray Gray Gray') for completely gray/System Defaults")

    @classmethod
    def _GetAContainerNumber(cls):
        """NOTE: Not user callable method!
        :return: A simple counter that makes each container element unique
        :rtype:
        """
        cls._container_element_counter += 1
        return cls._container_element_counter

    @classmethod
    def _IncrementOpenCount(self):
        """NOTE: Not a user callable method

        Increments the number of open windows.
        TODO: there is a bug where this count easily gets out of sync.
        Issue has been opened already. No ill effects
        """
        self.NumOpenWindows += 1
        # print('+++++ INCREMENTING Num Open Windows = {} ---'.format(Window.NumOpenWindows))

    @classmethod
    def _DecrementOpenCount(self):
        """NOTE: Not a user callable method

        Decrements the number of open windows.
        """
        self.NumOpenWindows -= 1 * (self.NumOpenWindows != 0)  # decrement if not 0
        # print('----- DECREMENTING Num Open Windows = {} ---'.format(Window.NumOpenWindows))

    @classmethod
    def get_screen_size(self):
        """Returns the size of the "screen" as determined by tkinter

        This is a class method meaning you call it by writing:
            `width, height = Window.get_screen_size()`

        This can vary depending on your operating system and the number of monitors
        installed on your system.  For Windows, the primary monitor's size is returns.
        On some multi-monitored Linux systems, the monitors are combined and
        the total size is reported as if one screen.

        :return: Size of the screen in pixels as determined by tkinter
        :rtype:  (int, int)
        """
        root = _get_hidden_master_root()
        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()
        return screen_width, screen_height

    @property
    def metadata(self):
        """Metadata available for all windows.

        :return: the current metadata value
        :rtype:  (Any)
        """
        return self._metadata

    @metadata.setter
    def metadata(self, value):
        """Metadata available for all windows.

        You can set to any value.

        :param value: Anything you want it to be
        :type value:  (Any)
        """
        self._metadata = value

    def last_location(self) -> tuple:
        """The last known location of the window (x,y)

        Set by config events from tkinter.

        :return:    The last location of the window
        :rtype:  (int, int)
        """
        return self._last_location


    # ------------------------- Add ONE Row to Form ------------------------- #
    def add_row(self, *args):
        """Adds a single row of elements to a window's `self.Rows` variables

        Generally speaking this is NOT how users should be building Window layouts.
        Users, create a single layout (a list of lists) and pass as a parameter to Window object, or call `Window.Layout(layout)`

        :param *args: List[Elements]
        :type *args:
        """
        NumRows = len(self.Rows)  # number of existing rows is our row number
        CurrentRowNumber = NumRows  # this row's number
        CurrentRow = []  # start with a blank row and build up
        # -------------------------  Add the elements to a row  ------------------------- #
        for i, element in enumerate(args):  # Loop through list of elements and add them to the row

            if isinstance(element, tuple) or isinstance(element, list):
                self.add_row(*element)
                continue
                _error_popup_with_traceback('Error creating Window layout',
                                            'Layout has a LIST instead of an ELEMENT',
                                            'This sometimes means you have a badly placed ]',
                                            'The erroneous list is:',
                                            element,
                                            'This list will be stripped from your layout'
                                            )
                continue
            elif callable(element) and not isinstance(element, Element):
                _error_popup_with_traceback('Error creating Window layout',
                                            'Layout has a FUNCTION instead of an ELEMENT',
                                            'This likely means you are missing () from your layout',
                                            'The erroneous list is:',
                                            element,
                                            'This item will be stripped from your layout')
                continue
            if element.ParentContainer is not None:
                warnings.warn(
                    '*** YOU ARE ATTEMPTING TO REUSE AN ELEMENT IN YOUR LAYOUT! Once placed in a layout, an element cannot be used in another layout. ***',
                    UserWarning)
                _error_popup_with_traceback('Error detected in layout - Contains an element that has already been used.',
                                            'You have attempted to reuse an element in your layout.',
                                            "The layout specified has an element that's already been used.",
                                            'You MUST start with a "clean", unused layout every time you create a window',
                                            'The erroneous Element = ',
                                            element,
                                            'and has a key = ', element.Key,
                                            'This item will be stripped from your layout',
                                            'Hint - try printing your layout and matching the IDs "print(layout)"')
                continue
            element.Position = (CurrentRowNumber, i)
            element.ParentContainer = self
            CurrentRow.append(element)
            # if this element is a titlebar, then automatically set the window margins to (0,0) and turn off normal titlebar
            if element.metadata == TITLEBAR_METADATA_MARKER:
                self.Margins = (0, 0)
                self.NoTitleBar = True
        # -------------------------  Append the row to list of Rows  ------------------------- #
        self.Rows.append(CurrentRow)

    # ------------------------- Add Multiple Rows to Form ------------------------- #
    def add_rows(self, rows):
        """Loops through a list of lists of elements and adds each row, list, to the layout

        This is NOT the best way to go about creating a window.
        Sending the entire layout at one time and passing it as a parameter to the `Window` call is better.

        :param rows: A list of a list of elements
        :type rows:  List[List[Elements]]
        """
        for row in rows:
            try:
                iter(row)
            except TypeError:
                _error_popup_with_traceback('Error Creating Window Layout', 'Error creating Window layout',
                           'Your row is not an iterable (e.g. a list)',
                           'Instead of a list, the type found was {}'.format(type(row)),
                           'The erroneous row = ',
                           row,
                           'This item will be stripped from your layout')
                continue
            self.add_row(*row)


    def layout(self, rows):
        """Second of two preferred ways of telling a `Window` what its layout is

        The other way is to pass the layout as a parameter to `Window` object.
        The parameter method is the currently preferred method.
        This call to `Layout` has been removed from examples contained
        in documents and in the Demo Programs. Trying to remove this call
        from history and replace with sending as a parameter to Window.

        :param rows: Your entire layout
        :type rows:  List[List[Elements]]
        :return:     self so that you can chain method calls
        :rtype:      (Window)
        """
        if self.use_custom_titlebar and not self.override_custom_titlebar:
            if self.titlebar_icon is not None:
                icon = self.titlebar_icon
            elif CUSTOM_TITLEBAR_ICON is not None:
                icon = CUSTOM_TITLEBAR_ICON
            elif self.titlebar_icon is not None:
                icon = self.titlebar_icon
            elif self.WindowIcon == DEFAULT_WINDOW_ICON:
                icon = DEFAULT_BASE64_ICON_16_BY_16
            else:
                icon = None

            new_rows = [[Titlebar(title=self.Title, icon=icon, text_color=self.titlebar_text_color, background_color=self.titlebar_background_color,
                                  font=self.titlebar_font)]] + rows
        else:
            new_rows = rows
        self.add_rows(new_rows)
        self._BuildKeyDict()

        if self._has_custom_titlebar_element():
            self.Margins = (0, 0)
            self.NoTitleBar = True
            self._has_custom_titlebar = True
        return self

    def extend_layout(self, container, rows):
        """Adds new rows to an existing container element inside of this window

        If the container is a scrollable `Column`, you need to also call the `contents_changed` method

        :param container: The container Element the layout will be placed inside of
        :type container:  Frame | Column | Tab
        :param rows:      The layout to be added
        :type rows:       (List[List[Element]])
        :return:          (Window) self so could be chained
        :rtype:           (Window)
        """
        column = Column(rows, pad=(0, 0), background_color=container.BackgroundColor)
        if self == container:
            frame = self.TKroot
        elif isinstance(container.Widget, TkScrollableFrame):
            frame = container.Widget.TKFrame
        else:
            frame = container.Widget
        PackFormIntoFrame(column, frame, self)
        # sg.PackFormIntoFrame(col, window.TKroot, window)
        self.AddRow(column)
        self.AllKeysDict = self._BuildKeyDictForWindow(self, column, self.AllKeysDict)
        return self

    def _Show(self, non_blocking=False):
        """NOTE: **NOT TO BE CALLED BY USERS.  INTERNAL ONLY!**

        It's this method that first shows the window to the user, collects results.

        :param non_blocking: if True, this is a non-blocking call
        :type non_blocking:  (bool)
        :return:             Tuple[Any, Dict] The event, values turple that is returned from Read calls
        :rtype:
        """
        self.Shown = True
        # Compute num rows & num cols (it'll come in handy debugging)
        self.NumRows = len(self.Rows)
        self.NumCols = max(len(row) for row in self.Rows)
        self.NonBlocking = non_blocking

        # Search through entire form to see if any elements set the focus
        # if not, then will set the focus to the first input element
        found_focus = False
        for row in self.Rows:
            for element in row:
                try:
                    if element.Focus:
                        found_focus = True
                except:
                    pass
                try:
                    if element.Key is not None:
                        self.UseDictionary = True
                except:
                    pass

        if not found_focus and self.UseDefaultFocus:
            self.UseDefaultFocus = True
        else:
            self.UseDefaultFocus = False
        # -=-=-=-=-=-=-=-=- RUN the GUI -=-=-=-=-=-=-=-=- ##
        StartupTK(self)
        # If a button or keyboard event happened but no results have been built, build the results
        if self.LastKeyboardEvent is not None or self.LastButtonClicked is not None:
            return _BuildResults(self, False, self)
        return self.ReturnValues

    # ------------------------- SetIcon - set the window's fav icon ------------------------- #
    def set_icon(self, icon=None, pngbase64=None):
        """Changes the icon that is shown on the title bar and on the task bar

        NOTE: The file type is __important__ and depends on the OS!
        Can pass in:
        * `filename` which must be a .ICO icon file for windows, PNG file for Linux
        * `bytes` object
        * `BASE64` encoded file held in a variable

        :param icon:      Filename or bytes object
        :type icon:       (str)
        :param pngbase64: Base64 encoded image
        :type pngbase64:  (bytes)
        """
        if type(icon) is bytes or pngbase64 is not None:
            wicon = tkinter.PhotoImage(data=icon if icon is not None else pngbase64)
            try:
                self.TKroot.tk.call('wm', 'iconphoto', self.TKroot._w, wicon)
            except:
                wicon = tkinter.PhotoImage(data=DEFAULT_BASE64_ICON)
                try:
                    self.TKroot.tk.call('wm', 'iconphoto', self.TKroot._w, wicon)
                except:
                    pass
            self.WindowIcon = wicon
            return

        wicon = icon
        try:
            self.TKroot.iconbitmap(icon)
        except:
            try:
                wicon = tkinter.PhotoImage(file=icon)
                self.TKroot.tk.call('wm', 'iconphoto', self.TKroot._w, wicon)
            except:
                try:
                    wicon = tkinter.PhotoImage(data=DEFAULT_BASE64_ICON)
                    try:
                        self.TKroot.tk.call('wm', 'iconphoto', self.TKroot._w, wicon)
                    except:
                        pass
                except:
                    pass
        self.WindowIcon = wicon

    def _GetElementAtLocation(self, location):
        """Given a (row, col) location in a layout,
            returns the element located at that position

        :param location: (int, int) Return the element located at (row, col) in layout
        :type location:
        :return:         (Element) The Element located at that position in this window
        :rtype:
        """

        (row_num, col_num) = location
        row = self.Rows[row_num]
        element = row[col_num]
        return element

    def _GetDefaultElementSize(self):
        """Returns the default `elementSize`

        :return: (width, height) of the default element size
        :rtype:  (int, int)
        """

        return self.DefaultElementSize

    def _AutoCloseAlarmCallback(self):
        """Called by tkinter when autoclose timer expires

        Closes the window.
        """
        try:
            window = self
            if window:
                if window.NonBlocking:
                    self.Close()
                else:
                    window._Close()
                    self.TKroot.quit()
                    self.RootNeedsDestroying = True
        except:
            pass

    def _TimeoutAlarmCallback(self):
        """Reads Timeout Alarm callback

        Will kick a main loop call out of the tkinter event loop and cause it to return.
        """
        # first, get the results table built; modify the Results table in the parent FlexForm object
        # print('TIMEOUT CALLBACK')
        if self.TimerCancelled:
            return
        self.LastButtonClicked = self.TimeoutKey
        self.FormRemainedOpen = True
        self.TKroot.quit()  # kick the users out of the mainloop

    def _calendar_chooser_button_clicked(self, elem):
        """
        :param elem:
        :type elem:
        :return:
        :rtype:
        """
        target_element, strvar, should_submit_window = elem._find_target()

        if elem.calendar_default_date_M_D_Y == (None, None, None):
            now = datetime.datetime.now()
            cur_month, cur_day, cur_year = now.month, now.day, now.year
        else:
            cur_month, cur_day, cur_year = elem.calendar_default_date_M_D_Y

        date_chosen = popup_get_date(start_mon=cur_month, start_day=cur_day, start_year=cur_year, close_when_chosen=elem.calendar_close_when_chosen,
                                     no_titlebar=elem.calendar_no_titlebar, begin_at_sunday_plus=elem.calendar_begin_at_sunday_plus,
                                     locale=elem.calendar_locale, location=elem.calendar_location, month_names=elem.calendar_month_names,
                                     day_abbreviations=elem.calendar_day_abbreviations, title=elem.calendar_title)
        if date_chosen is not None:
            month, day, year = date_chosen
            now = datetime.datetime.now()
            hour, minute, second = now.hour, now.minute, now.second
            try:
                date_string = calendar.datetime.datetime(year, month, day, hour, minute, second).strftime(elem.calendar_format)
            except Exception as e:
                print('Bad format string in calendar chooser button', e)
                date_string = 'Bad format string'

            if target_element is not None and target_element != elem:
                target_element.update(date_string)
            elif target_element == elem:
                elem.calendar_selection = date_string

            strvar.set(date_string)
            elem.TKStringVar.set(date_string)
            if should_submit_window:
                self.LastButtonClicked = target_element.Key
                results = _BuildResults(self, False, self)
        else:
            should_submit_window = False
        return should_submit_window

    # @_timeit_summary
    def read(self, timeout=None, timeout_key=TIMEOUT_KEY, close=False):
        """NOTE: THE biggest deal method in the Window class!

        This is how you get all of your data from your `Window`.
        Pass in a timeout (in milliseconds) to wait for a maximum of timeout milliseconds. Will return `timeout_key`.
        if no other GUI events happen first.

        :param timeout:     Milliseconds to wait until the Read will return IF no other GUI events happen first
        :type timeout:      (int)
        :param timeout_key: The value that will be returned from the call if the timer expired
        :type timeout_key:  (Any)
        :param close:       if True the window will be closed prior to returning
        :type close:        (bool)
        :return:            (event, values)
        :rtype:             Tuple[(Any), Dict[Any, Any], List[Any], None]
        """

        if Window._floating_debug_window_build_needed is True:
            Window._floating_debug_window_build_needed = False
            _Debugger.debugger._build_floating_window()

        if Window._main_debug_window_build_needed is True:
            Window._main_debug_window_build_needed = False
            _Debugger.debugger._build_main_debugger_window()

        # ensure called only 1 time through a single read cycle
        if not Window._read_call_from_debugger:
            _refresh_debugger()

        # if the user has not added timeout and a debug window is open, then set a timeout for them so the debugger continuously refreshes
        if _debugger_window_is_open() and not Window._read_call_from_debugger:
            if timeout is None or timeout > 3000:
                timeout = 200


        while True:
            Window._root_running_mainloop = self.TKroot
            results = self._read(timeout=timeout, timeout_key=timeout_key)
            if results is not None:
                if results[0] == DEFAULT_WINDOW_SNAPSHOT_KEY:
                    self.save_window_screenshot_to_disk()
                    popup_quick_message('Saved window screenshot to disk', background_color='#1c1e23', text_color='white', keep_on_top=True, font='_ 30')
                    continue
            # Post processing for Calendar Chooser Button
            try:
                if results[0] == timeout_key:  # if a timeout, then not a calendar button
                    break
                elem = self.find_element(results[0], silent_on_error=True)  # get the element that caused the event
                if elem.Type == ELEM_TYPE_BUTTON:
                    if elem.BType == BUTTON_TYPE_CALENDAR_CHOOSER:
                        if self._calendar_chooser_button_clicked(elem):  # returns True if should break out
                            # results[0] = self.LastButtonClicked
                            results = self.ReturnValues
                            break
                        else:
                            continue
                break
            except:
                break  # wasn't a calendar button for sure

        if close:
            self.close()

        if self.print_event_values:
            try: # in case something weird about the results
                if not (freesimplegui_user_settings.get('-do not print timeouts-', True) and results[0] == TIMEOUT_EVENT):
                    print(f'{results[0]}\n   {results[1]}')
            except Exception as e:
                pass

        return results

    # @_timeit
    def _read(self, timeout=None, timeout_key=TIMEOUT_KEY):
        """NOTE: THE biggest deal method in the `Window` class!

        This is how you get all of your data from your `Window`.
            Pass in a timeout (in milliseconds) to wait for a maximum of timeout milliseconds. Will return `timeout_key`.
            if no other GUI events happen first.

        :param timeout:     Milliseconds to wait until the Read will return IF no other GUI events happen first
        :type timeout:      (int)
        :param timeout_key: The value that will be returned from the call if the timer expired
        :type timeout_key:  (Any)
        :return:            (event, values) (event or timeout_key or None, Dictionary of values or List of values from all elements in the Window)
        :rtype:             Tuple[(Any), Dict[Any, Any], List[Any], None]
        """

        # if there are events in the thread event queue, then return those events before doing anything else.
        if self._queued_thread_event_available():
            self.ReturnValues = results = _BuildResults(self, False, self)
            return results

        if self.finalize_in_progress and self.auto_close_timer_needs_starting:
            self._start_autoclose_timer()
            self.auto_close_timer_needs_starting = False

        timeout = int(timeout) if timeout is not None else None
        if timeout == 0:  # timeout of zero runs the old readnonblocking
            event, values = self._ReadNonBlocking()
            if event is None:
                event = timeout_key
            if values is None:
                event = None
            return event, values  # make event None if values was None and return
        # Read with a timeout
        self.Timeout = timeout
        self.TimeoutKey = timeout_key
        self.NonBlocking = False
        if self.TKrootDestroyed:
            self.read_closed_window_count += 1
            if self.read_closed_window_count > 100:
                popup_error_with_traceback('Trying to read a closed window', 'You have tried 100 times to read a closed window.', 'You need to add a check for event == WIN_CLOSED',)
            return None, None
        if not self.Shown:
            self._Show()
        else:
            # if already have a button waiting, the return previously built results
            if self.LastButtonClicked is not None and not self.LastButtonClickedWasRealtime:
                results = _BuildResults(self, False, self)
                self.LastButtonClicked = None
                return results
            InitializeResults(self)

            if self._queued_thread_event_available():
                self.ReturnValues = results = _BuildResults(self, False, self)
                return results

            # if the last button clicked was realtime, emulate a read non-blocking
            # the idea is to quickly return realtime buttons without any blocks until released
            if self.LastButtonClickedWasRealtime:
                # clear the realtime flag if the element is not a button element (for example a graph element that is dragging)
                if self.AllKeysDict.get(self.LastButtonClicked, None):
                    if self.AllKeysDict.get(self.LastButtonClicked).Type != ELEM_TYPE_BUTTON:
                        self.LastButtonClickedWasRealtime = False  # stops from generating events until something changes
                else:  # it is possible for the key to not be in the dicitonary because it has a modifier. If so, then clear the realtime button flag
                    self.LastButtonClickedWasRealtime = False  # stops from generating events until something changes

                try:
                    rc = self.TKroot.update()
                except:
                    self.TKrootDestroyed = True
                    Window._DecrementOpenCount()
                    # _my_windows.Decrement()
                    # print('ROOT Destroyed')
                results = _BuildResults(self, False, self)
                if results[0] != None and results[0] != timeout_key:
                    return results
                else:
                    pass

                # else:
                #     print("** REALTIME PROBLEM FOUND **", results)

            if self.RootNeedsDestroying:
                # print('*** DESTROYING really late***')
                try:
                    self.TKroot.destroy()
                except:
                    pass
                # _my_windows.Decrement()
                self.LastButtonClicked = None
                return None, None

            # normal read blocking code....
            if timeout != None:
                self.TimerCancelled = False
                self.TKAfterID = self.TKroot.after(timeout, self._TimeoutAlarmCallback)
            self.CurrentlyRunningMainloop = True
            # self.TKroot.protocol("WM_DESTROY_WINDOW", self._OnClosingCallback)
            # self.TKroot.protocol("WM_DELETE_WINDOW", self._OnClosingCallback)
            Window._window_running_mainloop = self
            try:
                Window._root_running_mainloop.mainloop()
            except:
                print('**** EXITING ****')
                exit(-1)

            self.CurrentlyRunningMainloop = False
            try:
                self.TKroot.after_cancel(self.TKAfterID)
                del self.TKAfterID
            except:
                pass

            self.TimerCancelled = True
            if self.RootNeedsDestroying:
                try:
                    self.TKroot.destroy()
                except:
                    pass
                Window._DecrementOpenCount()
                self.LastButtonClicked = None
                return None, None

            # if form was closed with X
            if self.LastButtonClicked is None and self.LastKeyboardEvent is None and self.ReturnValues[0] is None:
                Window._DecrementOpenCount()

        # Determine return values
        if self.LastKeyboardEvent is not None or self.LastButtonClicked is not None:
            results = _BuildResults(self, False, self)
            if not self.LastButtonClickedWasRealtime:
                self.LastButtonClicked = None
            return results
        else:
            if self._queued_thread_event_available():
                self.ReturnValues = results = _BuildResults(self, False, self)
                return results
            if not self.XFound and self.Timeout != 0 and self.Timeout is not None and self.ReturnValues[
                0] is None:  # Special Qt case because returning for no reason so fake timeout
                self.ReturnValues = self.TimeoutKey, self.ReturnValues[1]  # fake a timeout
            elif not self.XFound and self.ReturnValues[0] is None:  # Return a timeout event... can happen when autoclose used on another window
                # print("*** Faking timeout ***")
                self.ReturnValues = self.TimeoutKey, self.ReturnValues[1]  # fake a timeout
            return self.ReturnValues

    def _ReadNonBlocking(self):
        """NOTE: Should be NEVER called directly by the user

        The user can call Window.read(timeout=0) to get same effect.

        :return: (event, values). (event or timeout_key or None, Dictionary of values or List of values from all elements in the Window)
        :rtype:  Tuple[(Any), Dict[Any, Any] | List[Any] | None]
        """
        if self.TKrootDestroyed:
            try:
                self.TKroot.quit()
                self.TKroot.destroy()
            except:
                pass
                # print('DESTROY FAILED')
            return None, None
        if not self.Shown:
            self._Show(non_blocking=True)
        try:
            rc = self.TKroot.update()
        except:
            self.TKrootDestroyed = True
            Window._DecrementOpenCount()
            # _my_windows.Decrement()
            # print("read failed")
            # return None, None
        if self.RootNeedsDestroying:
            # print('*** DESTROYING LATE ***', self.ReturnValues)
            self.TKroot.destroy()
            Window._DecrementOpenCount()
            # _my_windows.Decrement()
            self.Values = None
            self.LastButtonClicked = None
            return None, None
        return _BuildResults(self, False, self)

    def _start_autoclose_timer(self):
        duration = DEFAULT_AUTOCLOSE_TIME if self.AutoCloseDuration is None else self.AutoCloseDuration
        self.TKAfterID = self.TKroot.after(int(duration * 1000), self._AutoCloseAlarmCallback)

    def finalize(self):
        """Use this method to cause your layout to built into a real tkinter window

        In reality this method is like `Read(timeout=0)`.
        It doesn't block and uses your layout to create tkinter widgets to represent the elements.
        Lots of action!

        :return: Returns 'self' so that method "Chaining" can happen (read up about it as it's very cool!)
        :rtype:  (Window)
        """

        if self.TKrootDestroyed:
            return self
        self.finalize_in_progress = True

        self.Read(timeout=1)

        if self.AutoClose:
            self.auto_close_timer_needs_starting = True
        # add the window to the list of active windows
        Window._active_windows[self] = Window.hidden_master_root
        return self
        # OLD CODE FOLLOWS
        if not self.Shown:
            self._Show(non_blocking=True)
        try:
            rc = self.TKroot.update()
        except:
            self.TKrootDestroyed = True
            Window._DecrementOpenCount()
            print('** Finalize failed **')
            # _my_windows.Decrement()
            # return None, None
        return self

    def refresh(self):
        """Refreshes the window by calling `tkroot.update()`

        Can sometimes get away with a refresh instead of a `Read`.
        Use this call when you want something to appear in your `Window`
        immediately (as soon as this function is called).

        If you change an element in a window, your change will not be visible
        until the next call to `Window.read` or a call to `Window.refresh`.

        :return: `self` so that method calls can be easily "chained"
        :rtype:  (Window)
        """
        if self.TKrootDestroyed:
            return self
        try:
            rc = self.TKroot.update()
        except:
            pass
        return self

    def fill(self, values_dict):
        """Fill in elements that are input fields with data based on a 'values dictionary'

        :param values_dict: pairs
        :type values_dict:  (Dict[Any, Any]) - {Element_key : value}
        :return:            returns self so can be chained with other methods
        :rtype:             (Window)
        """

        FillFormWithValues(self, values_dict)
        return self

    def _find_closest_key(self, search_key):
        if not isinstance(search_key, str):
            search_key = str(search_key)
        matches = difflib.get_close_matches(search_key, [str(k) for k in self.AllKeysDict.keys()])
        if not len(matches):
            return None
        for k in self.AllKeysDict.keys():
            if matches[0] == str(k):
                return k
        return matches[0] if len(matches) else None

    def find_element(self, key, silent_on_error=False, supress_guessing=None, supress_raise=None):
        """Find element object associated with the provided key

        NOTE: THIS METHOD IS NO LONGER NEEDED to be called by the user.

        You can perform the same operation by writing this statement:
        `element = window[key]`

        You can drop the entire "find_element" function name and use [ ] instead.

        However, if you wish to perform a lookup without error checking, and don't have error popups turned
        off globally, you'll need to make this call so that you can disable error checks on this call.

        find_element is typically used in combination with a call
        to element's update method (or any other element method!):
            `window[key].update(new_value)`

        Versus the "old way":
            `window.FindElement(key).Update(new_value)`

        This call can be abbreviated to any of these:
            `find_element = FindElement == Element == Find`
        With find_element being the PEP8 compliant call that should be used.

        Rememeber that this call will return `None` if no match is found
        which may cause your code to crash if not checked for.

        :param key:              Used with window.find_element and with return values to uniquely identify this element
        :type key:               str | int | tuple | object
        :param silent_on_error:  If True do not display popup nor print warning of key errors
        :type silent_on_error:   (bool)
        :param supress_guessing: Override for the global key guessing setting.
        :type supress_guessing:  (bool | None)
        :param supress_raise:    Override for the global setting that determines if a key error should raise an exception
        :type supress_raise:     (bool | None)
        :return:                 Return value can be: the Element that matches the supplied key if found; an Error Element if silent_on_error is False; None if silent_on_error True
        :rtype:                  Element | ErrorElement | None
        """

        key_error = False
        closest_key = None
        supress_guessing = supress_guessing if supress_guessing is not None else SUPPRESS_KEY_GUESSING
        supress_raise = supress_raise if supress_raise is not None else SUPPRESS_RAISE_KEY_ERRORS
        try:
            element = self.AllKeysDict[key]
        except KeyError:
            key_error = True
            closest_key = self._find_closest_key(key)
            if not silent_on_error:
                print('** Error looking up your element using the key: ', key, 'The closest matching key: ', closest_key)
                _error_popup_with_traceback('Key Error', 'Problem finding your key ' + str(key), 'Closest match = ' + str(closest_key), emoji=EMOJI_BASE64_KEY)
                element = ErrorElement(key=key)
            else:
                element = None
            if not supress_raise:
                raise KeyError(key)

        if key_error:
            if not supress_guessing and closest_key is not None:
                element = self.AllKeysDict[closest_key]

        return element

    Element = find_element  # Shortcut functions
    Find = find_element
    Elem = find_element

    def find_element_with_focus(self):
        """Returns the Element that currently has focus as reported by tkinter

        If no element is found None is returned!

        :return: An Element if one has been found with focus or None if no element found
        :rtype:  Element | None
        """
        element = _FindElementWithFocusInSubForm(self)
        return element

    def widget_to_element(self, widget):
        """Returns the element that matches a supplied tkinter widget

        If no matching element is found, then `None` is returned.

        :return:    Element that uses the specified widget
        :rtype:     Element | None
        """
        if self.AllKeysDict is None or len(self.AllKeysDict) == 0:
            return None
        for key, element in self.AllKeysDict.items():
            if element.Widget == widget:
                return element
        return None

    def _BuildKeyDict(self):
        """NOTE: Not user callable method

        Builds a dictionary containing all elements with keys for this `Window`.
        """
        dict = {}
        self.AllKeysDict = self._BuildKeyDictForWindow(self, self, dict)

    def _BuildKeyDictForWindow(self, top_window, window, key_dict):
        """Loops through all Rows and all Container Elements for this window
            and creates the keys for all of them

        Note that the calls are recursive as all pathes must be walked.

        :param top_window: The highest level of the window
        :type top_window:  (Window)
        :param window:     The "sub-window" (container element) to be searched
        :type window:      Column | Frame | TabGroup | Pane | Tab
        :param key_dict:   The dictionary as it currently stands.... used as part of recursive call
        :type key_dict:
        :return:           (dict) Dictionary filled with all keys in the window
        :rtype:
        """
        for row_num, row in enumerate(window.Rows):
            for col_num, element in enumerate(row):
                if element.Type == ELEM_TYPE_COLUMN:
                    key_dict = self._BuildKeyDictForWindow(top_window, element, key_dict)
                if element.Type == ELEM_TYPE_FRAME:
                    key_dict = self._BuildKeyDictForWindow(top_window, element, key_dict)
                if element.Type == ELEM_TYPE_TAB_GROUP:
                    key_dict = self._BuildKeyDictForWindow(top_window, element, key_dict)
                if element.Type == ELEM_TYPE_PANE:
                    key_dict = self._BuildKeyDictForWindow(top_window, element, key_dict)
                if element.Type == ELEM_TYPE_TAB:
                    key_dict = self._BuildKeyDictForWindow(top_window, element, key_dict)
                if element.Key is None:  # if no key has been assigned.... create one for input elements
                    if element.Type == ELEM_TYPE_BUTTON:
                        element.Key = element.ButtonText
                    elif element.Type == ELEM_TYPE_TAB:
                        element.Key = element.Title
                    if element.Type in (ELEM_TYPE_MENUBAR, ELEM_TYPE_BUTTONMENU,
                                        ELEM_TYPE_INPUT_SLIDER, ELEM_TYPE_GRAPH, ELEM_TYPE_IMAGE,
                                        ELEM_TYPE_INPUT_CHECKBOX, ELEM_TYPE_INPUT_LISTBOX, ELEM_TYPE_INPUT_COMBO,
                                        ELEM_TYPE_INPUT_MULTILINE, ELEM_TYPE_INPUT_OPTION_MENU, ELEM_TYPE_INPUT_SPIN,
                                        ELEM_TYPE_INPUT_RADIO, ELEM_TYPE_INPUT_TEXT, ELEM_TYPE_PROGRESS_BAR,
                                        ELEM_TYPE_TABLE, ELEM_TYPE_TREE,
                                        ELEM_TYPE_TAB_GROUP, ELEM_TYPE_SEPARATOR):
                        element.Key = top_window.DictionaryKeyCounter
                        top_window.DictionaryKeyCounter += 1
                if element.Key is not None:
                    if element.Key in key_dict.keys():
                        if element.Type == ELEM_TYPE_BUTTON and WARN_DUPLICATE_BUTTON_KEY_ERRORS:  # for Buttons see if should complain
                            warnings.warn('*** Duplicate key found in your layout {} ***'.format(element.Key), UserWarning)
                            warnings.warn('*** Replaced new key with {} ***'.format(str(element.Key) + str(self.UniqueKeyCounter)))
                            if not SUPPRESS_ERROR_POPUPS:
                                _error_popup_with_traceback('Duplicate key found in your layout', 'Dupliate key: {}'.format(element.Key),
                                                            'Is being replaced with: {}'.format(str(element.Key) + str(self.UniqueKeyCounter)),
                                                            'The line of code above shows you which layout, but does not tell you exactly where the element was defined',
                                                            'The element type is {}'.format(element.Type))
                        element.Key = str(element.Key) + str(self.UniqueKeyCounter)
                        self.UniqueKeyCounter += 1
                    key_dict[element.Key] = element
        return key_dict

    def element_list(self):
        """Returns a list of all elements in the `Window`

        :return: List of all elements in the window and container elements in the window
        :rtype:  List[Element]
        """
        return self._build_element_list()

    def _build_element_list(self):
        """NOTE: Not a user callable function

        Builds a dictionary containing all elements with keys for this window.
        """
        elem_list = []
        elem_list = self._build_element_list_for_form(self, self, elem_list)
        return elem_list

    def _build_element_list_for_form(self, top_window, window, elem_list):
        """Loops through all Rows and all Container Elements for this window and create a list

        NOTE: the calls are recursive as all paths must be walked.

        :param top_window: The highest level of the window
        :type top_window:  (Window)
        :param window:     The "sub-window" (container element) to be searched
        :type window:      Column | Frame | TabGroup | Pane | Tab
        :param elem_list:  The element list as it currently stands.... used as part of recursive call
        :type elem_list:   ???
        :return:           List of all elements in this sub-window
        :rtype:            List[Element]
        """
        for row_num, row in enumerate(window.Rows):
            for col_num, element in enumerate(row):
                elem_list.append(element)
                if element.Type in (ELEM_TYPE_COLUMN, ELEM_TYPE_FRAME, ELEM_TYPE_TAB_GROUP, ELEM_TYPE_PANE, ELEM_TYPE_TAB):
                    elem_list = self._build_element_list_for_form(top_window, element, elem_list)
        return elem_list


    def settings_save(self, values: dict):
        """Saves settings to settings file using the values dict

        :param values:  Dictionary of values to potentially save
        :type values:   (Dict)
        """
        if values is None:
            return
        for key, value in values.items():
            try:
                element = self.find_element(key)
                if element.setting is not None:
                    user_settings_set_entry(key, value)
            except Exception as e:
                _error_popup_with_traceback('Error saving settings', e)

    def settings_restore(self):
        """Reads settings and sets the window's Elements to those values

        NOTE: May have trouble on some elements due to how update calls work.

        """
        for key in self.key_dict.keys():
            try:
                element = self.find_element(key)
                if element.setting is not None:
                    value = user_settings_get_entry(key, '')
                    element.update(value)
            except Exception as e:
                _error_popup_with_traceback('Error restoring settings', e)

    def save_to_disk(self, filename):
        """Saves the values contained in each of the input areas of the form

        Saves what would be returned from a call to Read.
        It takes these results and saves them to disk using pickle.

        NOTE: element in your layout that is to be saved must have a key assigned to it.

        :param filename: Filename to save the values to in pickled form
        :type filename:  str
        """
        try:
            event, values = _BuildResults(self, False, self)
            remove_these = []
            for key in values:
                if self.Element(key).Type == ELEM_TYPE_BUTTON:
                    remove_these.append(key)
            for key in remove_these:
                del values[key]
            with open(filename, 'wb') as sf:
                pickle.dump(values, sf)
        except:
            print('*** Error saving Window contents to disk ***')

    def load_from_disk(self, filename):
        """Restore values from a previous call to SaveToDisk

        NOTE: The returned values dictionary was saved in Pickle format.

        :param filename: Pickle Filename to load
        :type filename:  (str)
        """
        try:
            with open(filename, 'rb') as df:
                self.Fill(pickle.load(df))
        except:
            print('*** Error loading form to disk ***')

    def get_screen_dimensions(self):
        """Get the screen dimensions

        NOTE: you must have a window already open for this to work.

        :return: Tuple containing width and height of screen in pixels
        :rtype:  Tuple[None, None] | Tuple[width, height]
        """

        if self.TKrootDestroyed or self.TKroot is None:
            return Window.get_screen_size()

        screen_width = self.TKroot.winfo_screenwidth()
        screen_height = self.TKroot.winfo_screenheight()
        return screen_width, screen_height

    def move(self, x, y):
        """Moves the upper left corner of this window to the x,y coordinates provided

        :param x: x coordinate in pixels
        :type x:  (int)
        :param y: y coordinate in pixels
        :type y:  (int)
        """
        try:
            self.TKroot.geometry("+%s+%s" % (x, y))
            self.config_last_location = (int(x), (int(y)))
        except:
            pass

    def move_to_center(self):
        """Recenters your window after it's been moved or the size changed

        This is a convenience method.
        There are no tkinter calls involved, only pure FreeSimpleGUI API calls.
        """
        if not self._is_window_created('tried Window.move_to_center'):
            return
        screen_width, screen_height = self.get_screen_dimensions()
        win_width, win_height = self.size
        x, y = (screen_width - win_width) // 2, (screen_height - win_height) // 2
        self.move(x, y)

    def minimize(self):
        """Minimizes this window to the task bar"""
        if not self._is_window_created('tried Window.minimize'):
            return
        if self.use_custom_titlebar is True:
            self._custom_titlebar_minimize()
        else:
            self.TKroot.iconify()
        self.maximized = False

    def maximize(self):
        """Maximizes the window

        This is done differently on a Windows system versus a Linux or mac one.
        For non-Windows the root attribute '-fullscreen' is set to True.
        For Windows the "root" state is changed to "zoomed".

        The reason for the difference is the title bar is removed in some cases when using fullscreen option.
        """

        if not self._is_window_created('tried Window.maximize'):
            return
        if not running_linux():
            self.TKroot.state('zoomed')
        else:
            self.TKroot.attributes('-fullscreen', True)
        self.maximized = True

    def normal(self):
        """Restores the window to a non-maximized state

        Does different things depending on platform.
        See `Maximize` for more.
        """
        if not self._is_window_created('tried Window.normal'):
            return
        if self.use_custom_titlebar:
            self._custom_titlebar_restore()
        else:
            if self.TKroot.state() == 'iconic':
                self.TKroot.deiconify()
            else:
                if not running_linux():
                    self.TKroot.state('normal')
                else:
                    self.TKroot.attributes('-fullscreen', False)
            self.maximized = False

    def _StartMoveUsingControlKey(self, event):
        """Used by 'Grab Anywhere' style windows

        This function is bound to mouse-down. It marks the beginning of a drag.

        :param event: event information passed in by tkinter. Contains x,y position of mouse
        :type event:  (event)
        """
        self._start_move_save_offset(event)
        return

    def _StartMoveGrabAnywhere(self, event):
        """Used by 'Grab Anywhere' style windows

        This function is bound to mouse-down. It marks the beginning of a drag.

        :param event: event information passed in by tkinter. Contains x,y position of mouse
        :type event:  (event)
        """
        if (isinstance(event.widget, GRAB_ANYWHERE_IGNORE_THESE_WIDGETS) or event.widget in self._grab_anywhere_ignore_these_list) and event.widget not in self._grab_anywhere_include_these_list:
            return
        self._start_move_save_offset(event)

    def _StartMove(self, event):
        self._start_move_save_offset(event)
        return

    def _StopMove(self, event):
        """Used by 'Grab Anywhere' style windows

        This function is bound to mouse-up. It marks the ending of a drag.
        Sets the position of the window to this final x,y coordinates.

        :param event: event information passed in by tkinter. Contains x,y position of mouse
        :type event:  (event)
        """
        return

    def _start_move_save_offset(self, event):
        self._mousex = event.x + event.widget.winfo_rootx()
        self._mousey = event.y + event.widget.winfo_rooty()
        geometry = self.TKroot.geometry()
        location = geometry[geometry.find('+') + 1:].split('+')
        self._startx = int(location[0])
        self._starty = int(location[1])
        self._mouse_offset_x = self._mousex - self._startx
        self._mouse_offset_y = self._mousey - self._starty
        # ------ Move All Windows code ------
        if Window._move_all_windows:
            for win in Window._active_windows:
                if win == self:
                    continue
                geometry = win.TKroot.geometry()
                location = geometry[geometry.find('+') + 1:].split('+')
                _startx = int(location[0])
                _starty = int(location[1])
                win._mouse_offset_x = event.x_root - _startx
                win._mouse_offset_y = event.y_root - _starty

    def _OnMotionUsingControlKey(self, event):
        self._OnMotion(event)

    def _OnMotionGrabAnywhere(self, event):
        """Used by 'Grab Anywhere' style windows

        This function is bound to mouse motion.
        It actually moves the window.

        :param event: event information passed in by tkinter that contains (x,y) position of mouse
        :type event:  (event)
        """
        if (isinstance(event.widget, GRAB_ANYWHERE_IGNORE_THESE_WIDGETS) or event.widget in self._grab_anywhere_ignore_these_list) and event.widget not in self._grab_anywhere_include_these_list:
            # print('Found widget to ignore in grab anywhere...')
            return
        self._OnMotion(event)

    def _OnMotion(self, event):
        self.TKroot.geometry(
            f"+{event.x_root-self._mouse_offset_x}+{event.y_root-self._mouse_offset_y}")
        # print(f"+{event.x_root}+{event.y_root}")
        # ------ Move All Windows code ------
        try:
            if Window._move_all_windows:
                for win in Window._active_windows:
                    if win == self:
                        continue
                    win.TKroot.geometry(
                        f"+{event.x_root-win._mouse_offset_x}+{event.y_root-win._mouse_offset_y}")
        except Exception as e:
            print('OnMotion error', e)

    def _focus_callback(self, event):
        print('Focus event = {} window = {}'.format(event, self.Title))

    def _config_callback(self, event):
        """Called when a config event happens for the window

        :param event:            From tkinter and is not used
        :type event:             Any
        """
        # do the location auto-save stuff. If the location changes, then the location is written to the settings file
        if self.auto_save_location:
            try:
                cur_location = self.current_location()
                old_location = self._last_location
                if None not in cur_location:
                    self._last_location= cur_location
                    if old_location != cur_location:
                        self._auto_save_location()
            except Exception as e:
                pass

        if self.enable_window_config_events is True:
            self.LastButtonClicked = WINDOW_CONFIG_EVENT
            self.FormRemainedOpen = True
            self.user_bind_event = event
            _exit_mainloop(self)

    def _move_callback(self, event):
        """Called when a control + arrow key is pressed

        This is a built-in window positioning key sequence.

        :param event:            From tkinter and is not used
        :type event:             Any
        """
        if not self._is_window_created('Tried to move window using arrow keys'):
            return
        x,y = self.current_location()
        if event.keysym == 'Up':
            self.move(x, y-1)
        elif event.keysym == 'Down':
            self.move(x, y+1)
        elif event.keysym == 'Left':
            self.move(x-1, y)
        elif event.keysym == 'Right':
            self.move(x+1, y)

    def _KeyboardCallback(self, event):
        """Window keyboard callback called by tkinter

        Will kick user out of the tkinter event loop.
        Should only be called if user has requested window level keyboard events.

        :param event: object provided by tkinter that contains the key information
        :type event:  (event)
        """
        self.LastButtonClicked = None
        self.FormRemainedOpen = True
        if event.char != '':
            self.LastKeyboardEvent = event.char
        else:
            self.LastKeyboardEvent = str(event.keysym) + ':' + str(event.keycode)
        # if not self.NonBlocking:
        #     _BuildResults(self, False, self)
        _exit_mainloop(self)

    def _MouseWheelCallback(self, event):
        """Called by tkinter when a mouse wheel event has happened

        Only called if keyboard events for the window have been enabled.

        :param event: object sent in by tkinter that has the wheel direction
        :type event:  (event)
        """
        self.LastButtonClicked = None
        self.FormRemainedOpen = True
        self.LastKeyboardEvent = 'MouseWheel:Down' if event.delta < 0 or event.num == 5 else 'MouseWheel:Up'
        # if not self.NonBlocking:
        #     _BuildResults(self, False, self)
        _exit_mainloop(self)

    def _Close(self, without_event=False):
        """The internal close call that does the real work of building

        This method basically sets up for closing but doesn't destroy
        the window like the User's version of `Close` does.

        :parm without_event: if True, then do not cause an event to be generated, "silently" close the window
        :type without_event: (bool)
        """
        try:
            self.TKroot.update()
        except:
            pass

        if not self.NonBlocking or not without_event:
            _BuildResults(self, False, self)
        if self.TKrootDestroyed:
            return
        self.TKrootDestroyed = True
        self.RootNeedsDestroying = True
        return

    def toggle_inner_border(self, state=None, color="red", thickness=2):
        """Sets or toggles colored inner border of the window

        NOTE: It revert's the highlight color to `gray` not a system default.
        """
        if not self._is_window_created():
            return

        current_thickness = self.TKroot.cget("highlightthickness")
        if state is True:
            self.TKroot.configure(highlightthickness=thickness, highlightcolor=color)
            return
        elif state is False:
            self.TKroot.configure(highlightthickness=0, highlightcolor="gray")
            return
        if current_thickness != 0:
            self.TKroot.configure(highlightthickness=0, highlightcolor="gray")
        else:
            self.TKroot.configure(highlightthickness=thickness, highlightcolor=color)

    def set_word_boundaries(self, word_chars="\w", non_word_chars="\W"):
        """Sets RegExps for double-click word boundaries detection by tkinter"""
        if not self._is_window_created():
            return

        # This triggers tcl to auto-load the library
        self.TKroot.tk.call('tcl_wordBreakAfter', '', 0)

        # This defines what tcl considers to be a "word"
        # See www.tcl.tk/man/tcl8.5/TclCmd/library.htm#M19
        self.TKroot.tk.call('set', 'tcl_wordchars', word_chars)
        self.TKroot.tk.call('set', 'tcl_nonwordchars', non_word_chars)

    def close(self):
        """Closes the window

        Users can safely call even if window has been destroyed.
        Should always call when done with a window so that resources
        are properly freed up within your thread.
        """
        self._auto_save_location()
        try:
            del Window._active_windows[self]  # will only be in the list if window was explicitly finalized
        except:
            pass
        try:
            self.TKroot.update()  # On Linux must call update if the user closed with X or else won't actually close the window
        except:
            pass

        self._restore_stdout()
        self._restore_stderr()

        _TimerPeriodic.stop_all_timers_for_window(self)

        if self.TKrootDestroyed:
            return
        try:
            self.TKroot.destroy()
            self.TKroot.update()
            Window._DecrementOpenCount()
        except:
            pass
        self.TKrootDestroyed = True

        # Free up anything that was held in the layout and the root variables
        self.Rows = None
        self.TKroot = None

    def is_closed(self, quick_check=None) -> bool:
        """Returns `True` is the window is maybe closed

        Can be difficult to tell sometimes.
        NOTE: The call to TKroot.update was taking over 500 ms sometimes
            so added a flag to bypass the lengthy call.

        :param quick_quick: If True, then don't use the root.update call, only check the flags
        :type quick_check:  bool
        :return:            True if the window was closed or destroyed
        :rtype:             (bool)
        """

        if self.TKrootDestroyed or self.TKroot is None:
            return True

        # skip calling tkinter for performance reasons
        if quick_check is True:
            return False

        # see if can do an update; if not, then it's been destroyed
        try:
            rc = self.TKroot.update()
        except:
            return True
        return False

    def _auto_save_location(self):
        """Internal function to save the location of the window
            in the settings file
        """
        if self.auto_save_location:
            user_settings_set_entry(
            '-LAST WINDOW LOCATION-'+self.Title, self._last_location)

    def _OnClosingCallback(self):
        """Internally used method ONLY

        Not sure callable.
        tkinter calls this when the window is closed by clicking `X`.
        """
        # print('Got closing callback', self.DisableClose)
        if self.DisableClose:
            return
        self._auto_save_location()
        if self.CurrentlyRunningMainloop:  # quit if this is the current mainloop, otherwise don't quit!
            _exit_mainloop(self)
            if self.close_destroys_window:
                self.TKroot.destroy()  # destroy this window
                self.TKrootDestroyed = True
                self.XFound = True
            else:
                self.LastButtonClicked = WINDOW_CLOSE_ATTEMPTED_EVENT
        elif Window._root_running_mainloop == Window.hidden_master_root:
            _exit_mainloop(self)
        else:
            if self.close_destroys_window:
                self.TKroot.destroy()  # destroy this window
                self.XFound = True
            else:
                self.LastButtonClicked = WINDOW_CLOSE_ATTEMPTED_EVENT
        if self.close_destroys_window:
            self.RootNeedsDestroying = True
        self._restore_stdout()
        self._restore_stderr()

    def disable(self):
        """Disables window from taking any input from the user"""
        if not self._is_window_created('tried Window.disable'):
            return
        self.TKroot.attributes('-disabled', 1)
        # self.TKroot.grab_set_global()

    def enable(self):
        """Re-enables window to take user input after having it
            be Disabled previously
        """
        if not self._is_window_created('tried Window.enable'):
            return
        self.TKroot.attributes('-disabled', 0)
        # self.TKroot.grab_release()

    def hide(self):
        """Hides the window from the screen and the task bar"""
        if not self._is_window_created('tried Window.hide'):
            return
        self._Hidden = True
        self.TKroot.withdraw()

    def un_hide(self):
        """Used to bring back a window that was previously hidden
            using the Hide method
        """
        if not self._is_window_created('tried Window.un_hide'):
            return
        if self._Hidden:
            self.TKroot.deiconify()
            self._Hidden = False

    def is_hidden(self) -> bool:
        """Returns True if the window is currently hidden

        :return:    Returns True if the window is currently hidden
        :rtype:     bool
        """
        return self._Hidden

    def disappear(self):
        """Causes a window to "disappear" from the screen,
            but remain on the taskbar.

        It does this by turning the alpha channel to 0.
        NOTE: that on some platforms alpha is not supported.
        The window will remain showing on these platforms.
        The Raspberry Pi for example does not have an alpha setting.
        """
        if not self._is_window_created('tried Window.disappear'):
            return
        self.TKroot.attributes('-alpha', 0)

    def reappear(self):
        """Causes a window previously made to "Disappear" (using that method)

        Does this by restoring the alpha channel.
        """
        if not self._is_window_created('tried Window.reappear'):
            return
        self.TKroot.attributes('-alpha', 255)

    def set_alpha(self, alpha):
        """Sets the Alpha Channel for a window

        Values are between 0 and 1 where 0 is completely transparent.

        :param alpha: 0 to 1. 0 is completely transparent.  1 is completely visible and solid (can't see through)
        :type alpha:  (float)
        """
        if not self._is_window_created('tried Window.set_alpha'):
            return
        self._AlphaChannel = alpha
        self.TKroot.attributes('-alpha', alpha)

    @property
    def alpha_channel(self):
        """A property that changes the current alpha channel value (internal)

        :return: the current alpha channel setting according to self, not read directly from tkinter
        :rtype:  (float)
        """
        return self._AlphaChannel

    @alpha_channel.setter
    def alpha_channel(self, alpha):
        """The setter method for this alpha channel value

        Planning on depricating so that a Set call is always used by users. This is more in line with the SDK
        :param alpha: 0 to 1. 0 is completely transparent.  1 is completely visible and solid (can't see through)
        :type alpha:  (float)
        """
        if not self._is_window_created('tried Window.alpha_channel'):
            return
        self._AlphaChannel = alpha
        self.TKroot.attributes('-alpha', alpha)

    def bring_to_front(self):
        """Brings this window to the top of all other windows

        (perhaps may not be brought before a window made to "stay on top")
        """
        if not self._is_window_created('tried Window.bring_to_front'):
            return
        if running_windows():
            try:
                self.TKroot.wm_attributes("-topmost", 0)
                self.TKroot.wm_attributes("-topmost", 1)
                if not self.KeepOnTop:
                    self.TKroot.wm_attributes("-topmost", 0)
            except Exception as e:
                warnings.warn('Problem in Window.bring_to_front' + str(e), UserWarning)
        else:
            try:
                self.TKroot.lift()
            except:
                pass

    def send_to_back(self):
        """Pushes this window to the bottom of the stack of windows

        It is the opposite of BringToFront.
        """
        if not self._is_window_created('tried Window.send_to_back'):
            return
        try:
            self.TKroot.lower()
        except:
            pass

    def keep_on_top_set(self):
        """Sets keep_on_top after a window has been created

        Effect is the same as if the window was created with this set.
        The Window is also brought to the front
        """
        if not self._is_window_created('tried Window.keep_on_top_set'):
            return
        self.KeepOnTop = True
        self.bring_to_front()
        try:
            self.TKroot.wm_attributes("-topmost", 1)
        except Exception as e:
            warnings.warn('Problem in Window.keep_on_top_set trying to set wm_attributes topmost' + str(e), UserWarning)

    def keep_on_top_clear(self):
        """Clears keep_on_top after a window has been created

        Effect is the same as if the window was created with this set.
        """
        if not self._is_window_created('tried Window.keep_on_top_clear'):
            return
        self.KeepOnTop = False
        try:
            self.TKroot.wm_attributes("-topmost", 0)
        except Exception as e:
            warnings.warn('Problem in Window.keep_on_top_clear trying to clear wm_attributes topmost' + str(e), UserWarning)

    def current_location(self, more_accurate=False, without_titlebar=False):
        """Gets the current location of the window's top left corner

        Sometimes, depending on the environment, the value returned does not
        include the titlebar,etc
        A new option, more_accurate, can be used to get the theoretical upper
        leftmost corner of the window.
        The titlebar and menubar are crated by the OS. It gets really confusing
        when running in a webpage (repl, trinket)
        Thus, the values can appear top be "off" due to the sometimes
        unpredictable way the location is calculated.
        If without_titlebar is set then the location of the root x,y
        is used which should not include the titlebar but
        may be OS dependent.

        :param more_accurate:    If True, will use the window's geometry to get the topmost location with titlebar, menubar taken into account
        :type more_accurate:     (bool)
        :param without_titlebar: If True, return location of top left of main window area without the titlebar (may be OS dependent?)
        :type without_titlebar:  (bool)
        :return:                 The x and y location in tuple form (x,y)
        :rtype:                  Tuple[(int | None), (int | None)]
        """

        if not self._is_window_created('tried Window.current_location'):
            return (None, None)
        try:
            if without_titlebar is True:
                x, y = self.TKroot.winfo_rootx(), self.TKroot.winfo_rooty()
            elif more_accurate:
                geometry = self.TKroot.geometry()
                location = geometry[geometry.find('+') + 1:].split('+')
                x, y = int(location[0]), int(location[1])
            else:
                x, y =  int(self.TKroot.winfo_x()), int(self.TKroot.winfo_y())
        except Exception as e:
            warnings.warn('Error in Window.current_location. Trouble getting x,y location\n' + str(e), UserWarning)
            x, y = (None, None)
        return (x,y)

    def current_size_accurate(self):
        """Gets the current location of the window based on tkinter's geometry setting

        :return:              The x and y size in tuple form (x,y)
        :rtype:               Tuple[(int | None), (int | None)]
        """

        if not self._is_window_created('tried Window.current_location'):
            return (None, None)
        try:
            geometry = self.TKroot.geometry()
            geometry_tuple = geometry.split('+')
            window_size = geometry_tuple[0].split('x')
            x, y = int(window_size[0]), int(window_size[1])
        except Exception as e:
            warnings.warn('Error in Window.current_size_accurate. Trouble getting x,y size\n{} {}'.format(geometry, geometry_tuple) + str(e), UserWarning)
            x, y = (None, None)
        return (x,y)

    @property
    def size(self):
        """Returns the current size of the window in pixels

        :return: (width, height) of the window
        :rtype:  Tuple[(int), (int)] or Tuple[None, None]
        """
        if not self._is_window_created('Tried to use Window.size property'):
            return (None, None)
        win_width = self.TKroot.winfo_width()
        win_height = self.TKroot.winfo_height()
        return win_width, win_height

    @size.setter
    def size(self, size):
        """Changes the size of the window, if possible

        :param size: (width, height) of the desired window size
        :type size:  (int, int)
        """
        try:
            self.TKroot.geometry("%sx%s" % (size[0], size[1]))
            self.TKroot.update_idletasks()
        except:
            pass

    def set_size(self, size):
        """Changes the size of the window, if possible

        You can also use the Window.size prooerty to set/get the size.

        :param size: (width, height) of the desired window size
        :type size:  (int, int)
        """
        if not self._is_window_created('Tried to change the size of the window prior to creation.'):
            return
        try:
            self.TKroot.geometry("%sx%s" % (size[0], size[1]))
            self.TKroot.update_idletasks()
        except:
            pass

    def set_min_size(self, size):
        """Changes the minimum size of the window

        NOTE: Window must be read or finalized first.

        :param size: (width, height) tuple (int, int) of the desired window size in pixels
        :type size:  (int, int)
        """
        if not self._is_window_created('tried Window.set_min_size'):
            return
        self.TKroot.minsize(size[0], size[1])
        self.TKroot.update_idletasks()

    def set_resizable(self, x_axis_enable, y_axis_enable):
        """Changes if a window can be resized in either the X or the Y direction

        NOTE: Window must be read or finalized first.

        :param x_axis_enable: If True, the window can be changed in the X-axis direction. If False, it cannot
        :type x_axis_enable: (bool)
        :param y_axis_enable: If True, the window can be changed in the Y-axis direction. If False, it cannot
        :type y_axis_enable: (bool)
        """

        if not self._is_window_created('tried Window.set_resixable'):
            return
        try:
            self.TKroot.resizable(x_axis_enable, y_axis_enable)
        except Exception as e:
            _error_popup_with_traceback('Window.set_resizable - tkinter reported error', e)

    def visibility_changed(self):
        """
        When making an element in a column or someplace that has a scrollbar
        then you'll want to call this function prior to the column's `contents_changed`
        method.
        """
        self.refresh()

    def set_transparent_color(self, color):
        """Set the color that will be transparent in your window

        Areas with this color will be SEE THROUGH.

        :param color: Color string that defines the transparent color
        :type color:  (str)
        """
        if not self._is_window_created('tried Window.set_transparent_color'):
            return
        try:
            self.TKroot.attributes('-transparentcolor', color)
            self.TransparentColor = color
        except:
            print('Transparent color not supported on this platform (windows only)')

    def mouse_location(self):
        """Return the (x,y) location of the mouse relative to the entire screen

        It's the same location that you would use to create a window, popup, etc.

        :return:    The location of the mouse pointer
        :rtype:     (int, int)
        """
        if not self._is_window_created('tried Window.mouse_location'):
            return (0, 0)

        return (self.TKroot.winfo_pointerx(), self.TKroot.winfo_pointery())

    def grab_any_where_on(self):
        """Turns on Grab Anywhere functionality **after** a window has been created

        Don't try on a window that's not yet been `Finalized` or `Read`.
        """
        if not self._is_window_created('tried Window.grab_any_where_on'):
            return
        self.TKroot.bind("<ButtonPress-1>", self._StartMoveGrabAnywhere)
        self.TKroot.bind("<ButtonRelease-1>", self._StopMove)
        self.TKroot.bind("<B1-Motion>", self._OnMotionGrabAnywhere)

    def grab_any_where_off(self):
        """Turns off Grab Anywhere functionality AFTER a window has been created

        Don't try on a window that's not yet been `Finalized` or `Read`.
        """
        if not self._is_window_created('tried Window.grab_any_where_off'):
            return
        self.TKroot.unbind("<ButtonPress-1>")
        self.TKroot.unbind("<ButtonRelease-1>")
        self.TKroot.unbind("<B1-Motion>")

    def _user_bind_callback(self, bind_string, event, propagate=True):
        """Used when user binds a tkinter event directly to an element

        :param bind_string: The event that was bound so can lookup the key modifier
        :type bind_string:  (str)
        :param event:       Event data passed in by tkinter (not used)
        :type event:
        :param propagate:   If True then tkinter will be told to propagate the event
        :type propagate:    (bool)
        """
        # print('bind callback', bind_string, event)
        key = self.user_bind_dict.get(bind_string, '')
        self.user_bind_event = event
        if key is not None:
            self.LastButtonClicked = key
        else:
            self.LastButtonClicked = bind_string
        self.FormRemainedOpen = True
        # if self.CurrentlyRunningMainloop:
        #     self.TKroot.quit()
        _exit_mainloop(self)
        return 'break' if propagate is not True else None

    def bind(self, bind_string, key, propagate=True):
        """Used to add tkinter events to a `Window`

        The tkinter specific data is in the `Window`'s member variable `user_bind_event`

        :param bind_string: The string tkinter expected in its bind function
        :type bind_string:  (str)
        :param key:         The event that will be generated when the tkinter event occurs
        :type key:          str | int | tuple | object
        :param propagate:   If True then tkinter will be told to propagate the event
        :type propagate:    (bool)
        """
        if not self._is_window_created('tried Window.bind'):
            return
        try:
            self.TKroot.bind(bind_string, lambda evt: self._user_bind_callback(bind_string, evt, propagate))
        except Exception as e:
            self.TKroot.unbind_all(bind_string)
            return
            # _error_popup_with_traceback('Window.bind error', e)
        self.user_bind_dict[bind_string] = key

    def unbind(self, bind_string):
        """Used to remove tkinter events to a `Window`

        This implementation removes ALL of the binds of the `bind_string`
        from the Window.
        If there are multiple binds for the Window itself,
        they will all be removed.  This can be extended later if there is a need.

        :param bind_string: The string tkinter expected in its bind function
        :type bind_string:  (str)
        """
        if not self._is_window_created('tried Window.unbind'):
            return
        self.TKroot.unbind(bind_string)

    def _callback_main_debugger_window_create_keystroke(self, event):
        """Called when user presses the key that creates the main debugger window

        Causes the user reads to return timeout events automatically.

        :param event: (event) not used. Passed in event info
        :type event:
        """
        Window._main_debug_window_build_needed = True
        # exit the event loop in a way that resembles a timeout occurring
        self.LastButtonClicked = self.TimeoutKey
        self.FormRemainedOpen = True
        self.TKroot.quit()  # kick the users out of the mainloop

    def _callback_popout_window_create_keystroke(self, event):
        """Called when user presses the key that creates the floating debugger window

        Causes the user reads to return timeout events automatically.

        :param event: (event) not used. Passed in event info
        :type event:
        """
        Window._floating_debug_window_build_needed = True
        # exit the event loop in a way that resembles a timeout occurring
        self.LastButtonClicked = self.TimeoutKey
        self.FormRemainedOpen = True
        self.TKroot.quit()  # kick the users out of the mainloop

    def enable_debugger(self):
        """Enables the internal debugger

        By default, the debugger IS enabled.
        """
        if not self._is_window_created('tried Window.enable_debugger'):
            return
        self.TKroot.bind('<Cancel>', self._callback_main_debugger_window_create_keystroke)
        self.TKroot.bind('<Pause>', self._callback_popout_window_create_keystroke)
        self.DebuggerEnabled = True

    def disable_debugger(self):
        """Disable the internal debugger

        By default the debugger is ENABLED.
        """
        if not self._is_window_created('tried Window.disable_debugger'):
            return
        self.TKroot.unbind("<Cancel>")
        self.TKroot.unbind("<Pause>")
        self.DebuggerEnabled = False

    def set_title(self, title):
        """Changes the title of the window

        :param title: The string to set the title to
        :type title:  (str)
        """
        if not self._is_window_created('tried Window.set_title'):
            return
        if self._has_custom_titlebar:
            try:  # just in case something goes badly, don't crash
                self.find_element(TITLEBAR_TEXT_KEY).update(title)
            except:
                pass
        # even with custom titlebar, set the main window's title too so it'll match when minimized
        self.TKroot.wm_title(str(title))

    def make_modal(self):
        """Makes a window into a pseud-modal window

        This means user will not be able to interact with other windows until this one is closed.
        NOTE: Sorry Mac users - you can't have modal windows.
        """
        if not self._is_window_created('tried Window.make_modal'):
            return

        if running_mac() and ENABLE_MAC_MODAL_DISABLE_PATCH:
            return

        # if modal windows have been disabled globally
        if not DEFAULT_MODAL_WINDOWS_ENABLED and not DEFAULT_MODAL_WINDOWS_FORCED:
            # if not DEFAULT_MODAL_WINDOWS_ENABLED:
            return

        try:
            self.TKroot.transient()
            self.TKroot.grab_set()
            self.TKroot.focus_force()
        except Exception as e:
            print('Exception trying to make modal', e)

    def force_focus(self):
        """Forces this window to take focus"""
        if not self._is_window_created('tried Window.force_focus'):
            return
        self.TKroot.focus_force()

    def was_closed(self) -> bool:
        """Returns `True` if the window was closed

        :return: True if the window is closed
        :rtype:  bool
        """
        return self.TKrootDestroyed

    def set_cursor(self, cursor):
        """Sets the cursor for the window

        If you do not want any mouse pointer, then use the string "none"

        :param cursor: The tkinter cursor name
        :type cursor:  (str)
        """

        if not self._is_window_created('tried Window.set_cursor'):
            return
        try:
            self.TKroot.config(cursor=cursor)
        except Exception as e:
            print('Warning bad cursor specified ', cursor)
            print(e)

    def ding(self, display_number=0):
        """Makes a 'bell' sound

        A capability provided by tkinter.
        Your window needs to be finalized prior to calling.
        Ring a display's bell is the tkinter description of the call.

        :param display_number: Passed to tkinter's bell method as parameter "displayof".
        :type display_number:  int
        """
        if not self._is_window_created('tried Window.ding'):
            return
        try:
            self.TKroot.bell(display_number)
        except Exception as e:
            if not SUPPRESS_ERROR_POPUPS:
                _error_popup_with_traceback('Window.ding() - tkinter reported error from bell() call', e)

    def _window_tkvar_changed_callback(self, *args):
        """Internal callback function for when the thread changed tkvar

        :param event: Information from tkinter about the callback
        :type event:

        """
        if self._queued_thread_event_available():
            self.FormRemainedOpen = True
            _exit_mainloop(self)

    def _create_thread_queue(self):
        """Creates the queue used by threads to communicate with this window"""

        if self.thread_queue is None:
            self.thread_queue = queue.Queue()

        if self.thread_lock is None:
            self.thread_lock = threading.Lock()

        if self.thread_strvar is None:
            self.thread_strvar = tk.StringVar()
            self.thread_strvar.trace('w', self._window_tkvar_changed_callback)

    def write_event_value(self, key, value):
        """Adds a key & value tuple to the queue that is used
            by threads to communicate with the window

        :param key:   The key that will be returned as the event when reading the window
        :type key:    Any
        :param value: The value that will be in the values dictionary
        :type value:  Any
        """
        if self.thread_queue is None:
            print('*** Warning Window.write_event_value - no thread queue found ***')
            return
        # self.thread_lock.acquire()  # first lock the critical section
        self.thread_queue.put(item=(key, value))
        self.TKroot.tk.willdispatch()  # brilliant bit of code provided by Giuliano who I owe a million thank yous!
        self.thread_strvar.set('new item')

    def _queued_thread_event_read(self):
        if self.thread_queue is None:
            return None
        try:
            message = self.thread_queue.get_nowait()
        except queue.Empty:
            return None
        return message

    def _queued_thread_event_available(self):
        if self.thread_queue is None:
            return False
        # self.thread_lock.acquire()
        qsize = self.thread_queue.qsize()
        if qsize == 0:
            self.thread_timer = None
        # self.thread_lock.release()
        return qsize != 0

    def _RightClickMenuCallback(self, event):
        """
        When a right click menu is specified for an entire window, then this callback catches right clicks
        that happen to the window itself, when there are no elements that are in that area.

        The only portion that is not currently covered correctly is the row frame itself.  There will still
        be parts of the window, at the moment, that don't respond to a right click.  It's getting there, bit
        by bit.

        Callback function that's called when a right click happens. Shows right click menu as result.

        :param event: information provided by tkinter about the event including x,y location of click
        :type event:
        """
        # if there are widgets under the mouse, then see if it's the root only.  If not, then let the widget (element) show their menu instead
        x, y = self.TKroot.winfo_pointerxy()
        widget = self.TKroot.winfo_containing(x, y)
        if widget != self.TKroot:
            return
        self.TKRightClickMenu.tk_popup(event.x_root, event.y_root, 0)
        self.TKRightClickMenu.grab_release()

    def save_window_screenshot_to_disk(self, filename=None):
        """Saves an image of the `Window` into the filename provided

        :param filename:        Optional filename to save screenshot to. If not included, the User Settinds are used to get the filename
        :return:                A PIL ImageGrab object that can be saved or manipulated
        :rtype:                 (PIL.ImageGrab | None)
        """
        global pil_import_attempted, pil_imported, PIL, ImageGrab, Image

        if not pil_import_attempted:
            try:
                import PIL as PIL
                from PIL import ImageGrab
                from PIL import Image
                pil_imported = True
                pil_import_attempted = True
            except:
                pil_imported = False
                pil_import_attempted = True
                print('FAILED TO IMPORT PIL!')
                return None
        try:
            # Get location of window to save
            pos = self.current_location()
            # Add a little to the X direction if window has a titlebar
            if not self.NoTitleBar:
                pos = (pos[0] + 7, pos[1])
            # Get size of wiondow
            size = self.current_size_accurate()
            # Get size of the titlebar
            titlebar_height = self.TKroot.winfo_rooty() - self.TKroot.winfo_y()
            # Add titlebar to size of window so that titlebar and window will be saved
            size = (size[0], size[1] + titlebar_height)
            if not self.NoTitleBar:
                size_adjustment = (2, 1)
            else:
                size_adjustment = (0, 0)
            # Make the "Bounding rectangle" used by PLK to do the screen grap "operation
            rect = (pos[0], pos[1], pos[0] + size[0] + size_adjustment[0], pos[1] + size[1] + size_adjustment[1])
            # Grab the image
            grab = ImageGrab.grab(bbox=rect)
            # Save the grabbed image to disk
        except Exception as e:
            popup_error_with_traceback('Screen capture failure', 'Error happened while trying to save screencapture', e)
            return None

        if filename is None:
            folder = freesimplegui_user_settings.get('-screenshots folder-', '')
            filename = freesimplegui_user_settings.get('-screenshots filename-', '')
            full_filename = os.path.join(folder, filename)
        else:
            full_filename = filename
        if full_filename:
            try:
                grab.save(full_filename)
            except Exception as e:
                popup_error_with_traceback('Screen capture failure', 'Error happened while trying to save screencapture', e)
        else:
            popup_error_with_traceback('Screen capture failure', 'You have attempted a screen capture but have not set up a good filename to save to')
        return grab

    def perform_long_operation(self, func, end_key=None):
        """
        Call your function that will take a long time to execute.
        When it's complete, send an event specified by the `end_key`.

        Starts a thread on your behalf.

        This is a way for you to "ease into" threading without learning the details of threading.
        Your function will run, and when it returns 2 things will happen:
        1. The value you provide for end_key will be returned to you when you call window.read()
        2. If your function returns a value, then the value returned will also be included
            in your windows.read call in the values dictionary

        IMPORTANT: This method uses THREADS. This means you
        CANNOT make any other framework calls from the function
        you provide with the exception of one function, `Window.write_event_value`.

        :param func:    A lambda or a function name with no parms
        :type func:     Any
        :param end_key: Optional key that will be generated when the function returns
        :type end_key:  (Any | None)
        :return:        The id of the thread
        :rtype:         threading.Thread
        """

        thread = threading.Thread(target=_long_func_thread, args=(self, end_key, func), daemon=True)
        thread.start()
        return thread

    @property
    def key_dict(self):
        """
        Returns a dictionary with all keys and their corresponding elements
        { key : Element }
        :return: Dictionary of keys and elements
        :rtype:  Dict[Any, Element]
        """
        return self.AllKeysDict

    def key_is_good(self, key):
        """Checks to see if this is a good key for this window

        If there's an element with the key provided, then True is returned
        :param key:     The key to check
        :type key:      str | int | tuple | object
        :return:        True if key is an element in this window
        :rtype:         bool
        """
        if key in self.key_dict:
            return True
        return False

    def get_scaling(self):
        """Returns the current scaling value set for this window

        :return:    Scaling according to tkinter. Returns DEFAULT_SCALING if error
        :rtype:     float
        """

        if not self._is_window_created('Tried Window.set_scaling'):
            return DEFAULT_SCALING
        try:
            scaling = self.TKroot.tk.call('tk', 'scaling')
        except Exception as e:
            if not SUPPRESS_ERROR_POPUPS:
                _error_popup_with_traceback('Window.get_scaling() - tkinter reported error', e)
            scaling = DEFAULT_SCALING

        return scaling

    def _custom_titlebar_restore_callback(self, event):
        self._custom_titlebar_restore()

    def _custom_titlebar_restore(self):
        if running_linux():
            self.TKroot.unbind('<Button-1>')
            self.TKroot.deiconify()
            self.TKroot.wm_attributes("-type", 'dock')

        else:
            self.TKroot.unbind('<Expose>')
            self.TKroot.wm_overrideredirect(True)
        if self.TKroot.state() == 'iconic':
            self.TKroot.deiconify()
        else:
            if not running_linux():
                self.TKroot.state('normal')
            else:
                self.TKroot.attributes('-fullscreen', False)
        self.maximized = False

    def _custom_titlebar_minimize(self):
        if running_linux():
            self.TKroot.wm_attributes("-type", "normal")
            self.TKroot.wm_overrideredirect(False)
            self.TKroot.iconify()
            self.TKroot.bind('<Button-1>', self._custom_titlebar_restore_callback)
        else:
            self.TKroot.wm_overrideredirect(False)
            self.TKroot.iconify()
            self.TKroot.bind('<Expose>', self._custom_titlebar_restore_callback)

    def _custom_titlebar_callback(self, key):
        """Callback when one of the custom titlbar buttons was clicked

        :param key:
        :return:
        """
        if key == TITLEBAR_MINIMIZE_KEY:
            if not self.DisableMinimize:
                self._custom_titlebar_minimize()
        elif key == TITLEBAR_MAXIMIZE_KEY:
            if self.Resizable:
                if self.maximized:
                    self.normal()
                else:
                    self.maximize()
        elif key == TITLEBAR_CLOSE_KEY:
            if not self.DisableClose:
                self._OnClosingCallback()

    def timer_start(self, frequency_ms, key=EVENT_TIMER, repeating=True):
        """Starts a timer that generates timer `Event`s

        The default is to repeat the timer events until timer is stopped.
        You can provide your own key or a default key will be used.
        The default key is defined with the constants EVENT_TIMER or TIMER_KEY.
        They both equal the same value.
        The values dictionary will contain the timer ID that
        is returned from this function.

        :param frequency_ms:    How often to generate timer events in milliseconds
        :type frequency_ms:     int
        :param key:             Key to be returned as the timer event
        :type key:              str | int | tuple | object
        :param repeating:       If True then repeat timer events until timer is explicitly stopped
        :type repeating:        bool
        :return:                Timer ID for the timer
        :rtype:                 int
        """
        timer = _TimerPeriodic(self, frequency_ms=frequency_ms, key=key, repeating=repeating)
        return timer.id

    def timer_stop(self, timer_id):
        """Stops a timer with a given ID

        :param timer_id:        Timer ID of timer to stop
        :type timer_id:         int
        :return:
        """
        _TimerPeriodic.stop_timer_with_id(timer_id)

    def timer_stop_all(self):
        """Stops all timers for **this** window"""
        _TimerPeriodic.stop_all_timers_for_window(self)

    def timer_get_active_timers(self):
        """Returns a list of currently active timers for a window

        :return:    List of timers for the window
        :rtype:     List[int]
        """
        return _TimerPeriodic.get_all_timers_for_window(self)

    @classmethod
    def _restore_stdout(cls):
        for item in cls._rerouted_stdout_stack:
            (window, element) = item  # type: (Window, Element)
            if not window.is_closed():
                sys.stdout = element
                break
        cls._rerouted_stdout_stack = [item for item in cls._rerouted_stdout_stack if not item[0].is_closed()]
        if len(cls._rerouted_stdout_stack) == 0 and cls._original_stdout is not None:
            sys.stdout = cls._original_stdout

    @classmethod
    def _restore_stderr(cls):
        for item in cls._rerouted_stderr_stack:
            (window, element) = item  # type: (Window, Element)
            if not window.is_closed():
                sys.stderr = element
                break
        cls._rerouted_stderr_stack = [item for item in cls._rerouted_stderr_stack if not item[0].is_closed()]
        if len(cls._rerouted_stderr_stack) == 0 and cls._original_stderr is not None:
            sys.stderr = cls._original_stderr

    def __getitem__(self, key):
        """Returns Element that matches the passed in key

        This is "called" by writing code as thus:
            `window['element key'].update`

        :param key: The key to find
        :type key:  str | int | tuple | object
        :return:    The element found
        :rtype:     Element | Input | Combo | OptionMenu | Listbox | Radio | Checkbox | Spin | Multiline | Text | StatusBar | Output | Button | ButtonMenu | ProgressBar | Image | Canvas | Graph | Frame | VerticalSeparator | HorizontalSeparator | Tab | TabGroup | Slider | Column | Pane | Menu | Table | Tree | ErrorElement | None
        """

        return self.find_element(key)

    def __call__(self, *args, **kwargs):
        """Call window.read but without having to type it out

        ```
        window() == window.read()
        window(timeout=50) == window.read(timeout=50)
        ```

        :return: The famous event, values that read returns.
        :rtype:  Tuple[Any, Dict[Any, Any]]
        """
        return self.read(*args, **kwargs)

    def _is_window_created(self, additional_message=''):
        msg = str(additional_message)
        if self.TKroot is None:
            warnings.warn(
                'You cannot perform operations on a Window until it is read or finalized. Adding a "finalize=True" parameter to your Window creation will fix this. ' + msg,
                UserWarning)
            if not SUPPRESS_ERROR_POPUPS:
                _error_popup_with_traceback('You cannot perform operations on a Window until it is read or finalized.',
                                            'Adding a "finalize=True" parameter to your Window creation will likely fix this', msg)
            return False
        return True

    def _has_custom_titlebar_element(self):
        for elem in self.AllKeysDict.values():
            if elem.Key in (TITLEBAR_MAXIMIZE_KEY, TITLEBAR_CLOSE_KEY, TITLEBAR_IMAGE_KEY):
                return True
            if elem.metadata == TITLEBAR_METADATA_MARKER:
                return True
        return False

    AddRow = add_row
    AddRows = add_rows
    AlphaChannel = alpha_channel
    BringToFront = bring_to_front
    Close = close
    CurrentLocation = current_location
    Disable = disable
    DisableDebugger = disable_debugger
    Disappear = disappear
    Enable = enable
    EnableDebugger = enable_debugger
    Fill = fill
    Finalize = finalize
    # FindElement = find_element
    FindElementWithFocus = find_element_with_focus
    GetScreenDimensions = get_screen_dimensions
    GrabAnyWhereOff = grab_any_where_off
    GrabAnyWhereOn = grab_any_where_on
    Hide = hide
    Layout = layout
    LoadFromDisk = load_from_disk
    Maximize = maximize
    Minimize = minimize
    Move = move
    Normal = normal
    Read = read
    Reappear = reappear
    Refresh = refresh
    SaveToDisk = save_to_disk
    SendToBack = send_to_back
    SetAlpha = set_alpha
    SetIcon = set_icon
    SetTransparentColor = set_transparent_color
    Size = size
    UnHide = un_hide
    VisibilityChanged = visibility_changed
    CloseNonBlocking = close
    CloseNonBlockingForm = close
    start_thread = perform_long_operation


# -------------------------------- PEP8-ify the Window Class USER Interfaces -------------------------------- #
FlexForm = Window


def _long_func_thread(window, end_key, original_func):
    """Used to run long operations on the user's behalf

    Called by the window object.

    :param window:        The window that will get the event
    :type window:         (Window)
    :param end_key:       The event that will be sent when function returns. If None then no event will be sent when exiting thread
    :type end_key:        (Any|None)
    :param original_func: The user's function that is called. Can be a function with no arguments or a lambda experession
    :type original_func:  (Any)
    """
    return_value = original_func()
    if end_key is not None:
        window.write_event_value(end_key, return_value)


def _exit_mainloop(exiting_window):
    if exiting_window == Window._window_running_mainloop or Window._root_running_mainloop == Window.hidden_master_root:
        Window._window_that_exited = exiting_window
        if Window._root_running_mainloop is not None:
            Window._root_running_mainloop.quit()
        #print('** Exited window mainloop **')


def _timeout_alarm_callback_hidden():
    """Reads Timeout Alarm callback

    Will kick a main loop call out of the tkinter event loop and cause it to return.
    """
    del Window._TKAfterID

    # first, get the results table built
    # modify the Results table in the parent FlexForm object
    # print('TIMEOUT CALLBACK')
    Window._root_running_mainloop.quit()  # kick the users out of the mainloop
    # Get window that caused return
    Window._window_that_exited = None


def read_all_windows(timeout=None, timeout_key=TIMEOUT_KEY):
    """Reads all windows that are active when the call is made

    "Active" means that it's been finalized or read.
    If a window has not been finalized then it will not be considered an active window.

    If any of the active windows returns a value then the window and its event and values
    are returned.

    If no windows are open, then the value (None, WIN_CLOSED, None) will be returned
        Since WIN_CLOSED is None, it means (None, None, None) is what's returned when no windows remain opened

    :param timeout:     Time in milliseconds to delay before a returning a timeout event
    :type timeout:      (int)
    :param timeout_key: Key to return when a timeout happens. Defaults to the standard TIMEOUT_KEY
    :type timeout_key:  (Any)
    :return:            A tuple with the  (Window, event, values dictionary/list)
    :rtype:             (Window, Any, Dict | List)
    """

    if len(Window._active_windows) == 0:
        return None, WIN_CLOSED, None

    # first see if any queued events are waiting for any of the windows
    for window in Window._active_windows.keys():
        if window._queued_thread_event_available():
            _BuildResults(window, False, window)
            event, values = window.ReturnValues
            return window, event, values

    Window._root_running_mainloop = Window.hidden_master_root
    Window._timeout_key = timeout_key

    if timeout == 0:
        window = list(Window._active_windows.keys())[Window._timeout_0_counter]
        event, values = window._ReadNonBlocking()
        if event is None:
            event = timeout_key
        if values is None:
            event = None
        Window._timeout_0_counter = (Window._timeout_0_counter + 1) % len(Window._active_windows)
        return window, event, values

    Window._timeout_0_counter = 0  # reset value if not reading with timeout 0 so ready next time needed

    # setup timeout timer
    if timeout != None:
        try:
            Window.hidden_master_root.after_cancel(Window._TKAfterID)
            del Window._TKAfterID
        except:
            pass

        Window._TKAfterID = Window.hidden_master_root.after(timeout, _timeout_alarm_callback_hidden)

    # ------------ Call Mainloop ------------
    Window._root_running_mainloop.mainloop()

    try:
        Window.hidden_master_root.after_cancel(Window._TKAfterID)
        del Window._TKAfterID
    except:
        pass

    # Get window that caused return
    window = Window._window_that_exited

    if window is None:
        return None, timeout_key, None

    if window.XFound:
        event, values = None, None
        window.close()
        try:
            del Window._active_windows[window]
        except:
            pass
    else:
        _BuildResults(window, False, window)
        event, values = window.ReturnValues

    return window, event, values


# MP""""""`MM                     dP
# M  mmmmm..M                     88
# M.      `YM dP    dP .d8888b. d8888P .d8888b. 88d8b.d8b.
# MMMMMMM.  M 88    88 Y8ooooo.   88   88ooood8 88'`88'`88
# M. .MMM'  M 88.  .88       88   88   88.  ... 88  88  88
# Mb.     .dM `8888P88 `88888P'   dP   `88888P' dP  dP  dP
# MMMMMMMMMMM      .88
#              d8888P
# M""""""""M
# Mmmm  mmmM
# MMMM  MMMM 88d888b. .d8888b. dP    dP
# MMMM  MMMM 88'  `88 88'  `88 88    88
# MMMM  MMMM 88       88.  .88 88.  .88
# MMMM  MMMM dP       `88888P8 `8888P88
# MMMMMMMMMM                        .88
#                               d8888P

# ------------------------------------------------------------------------- #
#                       SystemTray - class for implementing a pseudo tray  #
# ------------------------------------------------------------------------- #

# -------------------------------- System Tray Begins Here -------------------------------- #
# fade in/out info and default window alpha
SYSTEM_TRAY_WIN_MARGINS = 160, 60  # from right edge of screen, from bottom of screen
SYSTEM_TRAY_MESSAGE_MAX_LINE_LENGTH = 50
# colors
SYSTEM_TRAY_MESSAGE_WIN_COLOR = "#282828"
SYSTEM_TRAY_MESSAGE_TEXT_COLOR = "#ffffff"

SYSTEM_TRAY_MESSAGE_DISPLAY_DURATION_IN_MILLISECONDS = 3000  # how long to display the window
SYSTEM_TRAY_MESSAGE_FADE_IN_DURATION = 1000  # how long to fade in / fade out the window

EVENT_SYSTEM_TRAY_ICON_DOUBLE_CLICKED = '__DOUBLE_CLICKED__'
EVENT_SYSTEM_TRAY_ICON_ACTIVATED = '__ACTIVATED__'
EVENT_SYSTEM_TRAY_MESSAGE_CLICKED = '__MESSAGE_CLICKED__'

# Base64 Images to use as icons in the window
_tray_icon_error = b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAADlAAAA5QGP5Zs8AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAIpQTFRF////20lt30Bg30pg4FJc409g4FBe4E9f4U9f4U9g4U9f4E9g31Bf4E9f4E9f4E9f4E9f4E9f4FFh4Vdm4lhn42Bv5GNx5W575nJ/6HqH6HyI6YCM6YGM6YGN6oaR8Kev9MPI9cbM9snO9s3R+Nfb+dzg+d/i++vt/O7v/fb3/vj5//z8//7+////KofnuQAAABF0Uk5TAAcIGBktSYSXmMHI2uPy8/XVqDFbAAAA8UlEQVQ4y4VT15LCMBBTQkgPYem9d9D//x4P2I7vILN68kj2WtsAhyDO8rKuyzyLA3wjSnvi0Eujf3KY9OUP+kno651CvlB0Gr1byQ9UXff+py5SmRhhIS0oPj4SaUUCAJHxP9+tLb/ezU0uEYDUsCc+l5/T8smTIVMgsPXZkvepiMj0Tm5txQLENu7gSF7HIuMreRxYNkbmHI0u5Hk4PJOXkSMz5I3nyY08HMjbpOFylF5WswdJPmYeVaL28968yNfGZ2r9gvqFalJNUy2UWmq1Wa7di/3Kxl3tF1671YHRR04dWn3s9cXRV09f3vb1fwPD7z9j1WgeRgAAAABJRU5ErkJggg=='
_tray_icon_success = b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAAEKAAABCgEWpLzLAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAHJQTFRF////ZsxmbbZJYL9gZrtVar9VZsJcbMRYaMZVasFYaL9XbMFbasRZaMFZacRXa8NYasFaasJaasFZasJaasNZasNYasJYasJZasJZasJZasJZasJZasJYasJZasJZasJZasJZasJaasJZasJZasJZasJZ2IAizQAAACV0Uk5TAAUHCA8YGRobHSwtPEJJUVtghJeYrbDByNjZ2tvj6vLz9fb3/CyrN0oAAADnSURBVDjLjZPbWoUgFIQnbNPBIgNKiwwo5v1fsQvMvUXI5oqPf4DFOgCrhLKjC8GNVgnsJY3nKm9kgTsduVHU3SU/TdxpOp15P7OiuV/PVzk5L3d0ExuachyaTWkAkLFtiBKAqZHPh/yuAYSv8R7XE0l6AVXnwBNJUsE2+GMOzWL8k3OEW7a/q5wOIS9e7t5qnGExvF5Bvlc4w/LEM4Abt+d0S5BpAHD7seMcf7+ZHfclp10TlYZc2y2nOqc6OwruxUWx0rDjNJtyp6HkUW4bJn0VWdf/a7nDpj1u++PBOR694+Ftj/8PKNdnDLn/V8YAAAAASUVORK5CYII='
_tray_icon_halt = b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMAUExURQAAANswNuMPDO8HBO8FCe0HCu4IBu4IB+oLDeoLDu8JC+wKCu4JDO4LDOwKEe4OEO4OEeUQDewQDe0QDucVEuYcG+ccHOsQFuwWHe4fH/EGAvMEBfMFBvAHBPMGBfEGBvYCAfYDAvcDA/cDBPcDBfUDBvYEAPYEAfYEAvYEA/QGAPQGAfQGAvYEBPUEBvYFB/QGBPQGBfQHB/EFCvIHCPMHCfIHC/IFDfMHDPQGCPQGCfQGCvEIBPIIBfAIB/UIB/QICPYICfoBAPoBAfoBAvsBA/kCAPkCAfkCAvkCA/oBBPkCBPkCBfkCBvgCB/gEAPkEAfgEAvkEA/gGAfkGAvkEBPgEBfkEBv0AAP0AAfwAAvwAA/wCAPwCAfwCAvwCA/wABP0ABfwCBfwEAPwFA/ASD/ESFPAUEvAUE/EXFvAdH+kbIOobIeofIfEfIOcmKOohIukgJOggJesiKuwiKewoLe0tLO0oMOQ3OO43Oew4OfAhIPAhIfAiIPEiI+dDRe9ES+lQTOdSWupSUOhTUehSV+hUVu1QUO1RUe1SV+tTWe5SWOxXWOpYV+pZWelYXexaW+xaXO9aX+lZYeNhYOxjZ+lna+psbOttbehsbupscepucuxtcuxucep3fet7e+p/ffB6gOmKiu2Iie2Sk+2Qle2QluySlOyTleuYmvKFivCOjgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIxGNZsAAAEAdFJOU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wBT9wclAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACVElEQVQ4T22S93PTMBhADQdl791SSsuRARTKKHsn+STZBptAi6zIacous+w9yyxl7z1T1h8ptHLhrrzLD5+/987R2XZElZ/39tZsbGg42NdvF4pqcGMs4XEcozAB/oQeu6wGr5fkAZcKOUIIRgQXR723wgaXt/NSgcwlO1r3oARkATfhbmNMMCnlMZdz5J8RN9fVhglS5JA/pJUOJiYXoShCkz/flheDvpzlBCBmya5KcDG1sMSB+r/VQtG+YoFXlwN0Us4yeBXujPmWCOqNlVwX5zHntLH5iQ420YiqX9pqTZFSCrBGBc+InBUDAsbwLRlMC40fGJT8YLRwfnhY3v6/AUtDc9m5z0tRJBOAvHUaFchdY6+zDzEghHv1tUnrNCaIOw84Q2WQmkeO/Xopj1xFBREFr8ZZjuRhA++PEB+t05ggwBucpbH8i/n5C1ZU0EEEmRZnSMxoIYcarKigA0Cb1zpHAyZnGj21xqICAA9dcvo4UgEdZ41FBZSTzEOn30f6QeE3Vhl0gLN+2RGDzZPMHLHKoAO3MFy+ix4sDxFlvMXfrdNgFezy7qrXPaaJg0u27j5nneKrCjJ4pf4e3m4DVMcjNNNKxWnpo6jtnfnkunExB4GbuGKk5FNanpB1nJCjCsThJPAAJ8lVdSF5sSrklM2ZqmYdiC40G7Dfnhp57ZsQz6c3hylEO6ZoZQJxqiVgbhoQK3T6AIgU4rbjxthAPF6NAwAOAcS+ixlp/WBFJRDi0fj2RtcjWRwif8Qdu/w3EKLcu3/YslnrZzwo24UQQvwFCrp/iM1NnHwAAAAASUVORK5CYII='
_tray_icon_notallowed = b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMAUExURQAAAPcICPcLC/cMDPcQEPcSEvcXF/cYGPcaGvcbG/ccHPgxMfgyMvg0NPg5Ofg6Ovg7O/hBQfhCQvlFRflGRvljY/pkZPplZfpnZ/p2dgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMgEwNYAAAEAdFJOU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wBT9wclAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABE0lEQVQ4T4WT65bDIAiExWbbtN0m3Uua+P4P6g4jGtN4NvNL4DuCCC5WWobe++uwmEmtwNxJUTebcwWCt5jJBwsYcKf3NE4hTOOJxj1FEnBTz4NH6qH2jUcCGr/QLLpkQgHe/6VWJXVqFgBB4yI/KVCkBCoFgPrPHw0CWbwCL8RibBFwzQDQH62/QeAtHQBeADUIDbkF/UnmnkB1ixtERrN3xCgyuF5kMntHTCJXh2vyv+wIdMhvgTeCQJ0C2hBMgSKfZlM1wSLXZ5oqgs8sjSpaCQ2VVlfKhLU6fdZGSvyWz9JMb+NE4jt/Nwfm0yJZSkBpYDg7TcJGrjm0Z7jK0B6P/fHiHK8e9Pp/eSmuf1+vf4x/ralnCN9IrncAAAAASUVORK5CYII='
_tray_icon_stop = b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMAUExURQAAANsAANsBAdsCAtwEBNwFBdwHB9wICNwLC90MDN0NDd0PD90REd0SEt4TE94UFN4WFt4XF94ZGeAjI+AlJeEnJ+EpKeEqKuErK+EsLOEuLuIvL+IyMuIzM+M1NeM2NuM3N+M6OuM8POQ9PeQ+PuQ/P+RAQOVISOVJSeVKSuZLS+ZOTuZQUOZRUedSUudVVehbW+lhYeljY+poaOtvb+twcOtxcetzc+t0dOx3d+x4eOx6eu19fe1+fu2AgO2Cgu6EhO6Ghu6Hh+6IiO6Jie+Kiu+Li++MjO+Nje+Oju+QkPCUlPCVlfKgoPKkpPKlpfKmpvOrq/SurvSxsfSysvW4uPW6uvW7u/W8vPa9vfa+vvbAwPbCwvfExPfFxffGxvfHx/fIyPfJyffKyvjLy/jNzfjQ0PjR0fnS0vnU1PnY2Pvg4Pvi4vvj4/vl5fvm5vzo6Pzr6/3u7v3v7/3x8f3z8/309P719f729v739/74+P75+f76+v77+//8/P/9/f/+/v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPHCyoUAAAEAdFJOU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wBT9wclAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABnUlEQVQ4T33S50PTQBgG8D6lzLbsIUv2kD0FFWTvPWTvISDIUBGV1ecvj+8luZTR9P1wSe755XK5O4+hK4gn5bc7DcMBz/InQoMXeVjY4FXuCAtEyLUwQcTcFgq45JYQ4JqbwhMtV8IjeUJDjQ+5paqCyG9srEsGgoUlpeXpIjxA1nfyi2+Jqmo7Q9JeV+ODerpvBQTM8/ySzQ3t+xxoL7h7nJve5jd85M7wJq9McHaT8o6TwBTfIIfHQGzoAZ/YiSTSq8D5dSDQVqFADrJ5KFMLPaKLHQiQMQoscClezdgCB4CXD/jM90izR8g85UaKA3YAn4AejhV189acA5LX+DVOg00gnvfoVX/BRQsgbplNGqzLusgIffx1tDchiyRgdRbVHNdgRRZHQD9H1asm+PMzYyYMtoBU/sYgRxxgrmGtBRL/cnf5RL4zzCEHZF2QE14LoOWf6B9vMcJBG/iBxKo8dVtYnyStv6yuUq7FLfmqTzbLEOFest1GNGEemCjCPnKuwjm0LsLMbRBJWLkGr4WdO+Cl0HkYPBc6N4z//HcQqVwcOuIAAAAASUVORK5CYII='
_tray_icon_exclamation = b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMAUExURQAAAN0zM900NN01Nd02Nt03N944ON45Od46Ot47O98/P99BQd9CQt9DQ+FPT+JSUuJTU+JUVOJVVeJWVuNbW+ReXuVjY+Zra+dxceh4eOl7e+l8fOl+ful/f+qBgeqCguqDg+qFheuJieuLi+yPj+yQkO2Wlu+cnO+hofGqqvGtrfre3vrf3/ri4vvn5/75+f76+v/+/v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMQ8SQkAAAEAdFJOU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wBT9wclAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABJElEQVQ4T4WS63KCMBBGsyBai62X0otY0aq90ZZa3v/dtpvsJwTijOfXt7tnILOJYY9tNonjNCtQOlqhuKKG0RrNVjgkmIHBHgMId+h7zHSiwg2a9FNVVYScupETmjkd67o+CWpYwft+R6CpCgeUlq5AOyf45+8JsRUKFI6eQLkI3n5CIREBUekLxGaLpATCymRISiAszARJCYSxiZGUQKDLQoqgnPnFhUPOTWeRoZD3FvVZlmVHkE2OEM9iV71GVoZDBGUpAg9QWN5/jx+Ilsi9hz0q4VHOWD+hEF70yc1QEr1a4Q0F0S3eJDfLuv8T4QEFXduZE1rj+et7g6hzCDxF08N+X4DAu+6lUSTnc5wE5tx73ckSTV8QVoux3N88Rykw/wP3i+vwPKk17AAAAABJRU5ErkJggg=='
_tray_icon_none = None

SYSTEM_TRAY_MESSAGE_ICON_ERROR = _tray_icon_error
SYSTEM_TRAY_MESSAGE_ICON_INFORMATION = _tray_icon_success
SYSTEM_TRAY_MESSAGE_ICON_WARNING = _tray_icon_exclamation
SYSTEM_TRAY_MESSAGE_ICON_CRITICAL = _tray_icon_stop
SYSTEM_TRAY_MESSAGE_ICON_NOICON = _tray_icon_none


# ------------------------------------------------------------------------- #
#                       Tray CLASS                                      #
# ------------------------------------------------------------------------- #
class SystemTray:
    """A 'Simulated System Tray' that duplicates the API calls
        available to FreeSimpleGUIWx and FreeSimpleGUIQt users

    All of the functionality works.
    The icon is displayed ABOVE the system tray rather than inside of it.
    """

    def __init__(self, menu=None, filename=None, data=None, data_base64=None, tooltip=None, metadata=None):
        """
        SystemTray - create an icon in the system tray
        :param menu:        Menu definition. Example - ['UNUSED', ['My', 'Simple', '---', 'Menu', 'Exit']]
        :type menu:         List[List[List[str] or str]]
        :param filename:    filename for icon
        :type filename:     (str)
        :param data:        in-ram image for icon (same as data_base64 parm)
        :type data:         (bytes)
        :param data_base64: base-64 data for icon
        :type data_base64:  (bytes)
        :param tooltip:     tooltip string
        :type tooltip:      (str)
        :param metadata:    User metadata that can be set to ANYTHING
        :type metadata:     (Any)
        """
        self._metadata = None
        self.Menu = menu
        self.TrayIcon = None
        self.Shown = False
        self.MenuItemChosen = TIMEOUT_KEY
        self.metadata = metadata
        self.last_message_event = None

        screen_size = Window.get_screen_size()

        if filename:
            image_elem = Image(filename=filename, background_color='red', enable_events=True, tooltip=tooltip, key='-IMAGE-')
        elif data_base64:
            image_elem = Image(data=data_base64, background_color='red', enable_events=True, tooltip=tooltip, key='-IMAGE-')
        elif data:
            image_elem = Image(data=data, background_color='red', enable_events=True, tooltip=tooltip, key='-IMAGE-')
        else:
            image_elem = Image(background_color='red', enable_events=True, tooltip=tooltip, key='-IMAGE-')
        layout = [
            [image_elem],
        ]
        self.window = Window('Window Title', layout, element_padding=(0, 0), margins=(0, 0), grab_anywhere=True, no_titlebar=True, transparent_color='red',
                             keep_on_top=True, right_click_menu=menu, location=(screen_size[0] - 100, screen_size[1] - 100), finalize=True)

        self.window['-IMAGE-'].bind('<Double-Button-1>', '+DOUBLE_CLICK')

    @property
    def metadata(self):
        """Metadata of an `SystemTray` property

        :return: the current metadata value
        :rtype:  (Any)
        """
        return self._metadata

    @metadata.setter
    def metadata(self, value):
        """Metadata is an `SystemTray` property that you can use at any time to hold any value

        :param value: Anything you want it to be
        :type value:  (Any)
        """
        self._metadata = value

    def read(self, timeout=None):
        """Reads the context menu

        :param timeout: Optional.  Any value other than None indicates a non-blocking read
        :type timeout:
        :return:
        :rtype:
        """
        if self.last_message_event != TIMEOUT_KEY and self.last_message_event is not None:
            event = self.last_message_event
            self.last_message_event = None
            return event
        event, values = self.window.read(timeout=timeout)
        if event.endswith('DOUBLE_CLICK'):
            return EVENT_SYSTEM_TRAY_ICON_DOUBLE_CLICKED
        elif event == '-IMAGE-':
            return EVENT_SYSTEM_TRAY_ICON_ACTIVATED

        return event

    def hide(self):
        """Hides the icon"""
        self.window.hide()

    def un_hide(self):
        """Restores a previously hidden icon"""
        self.window.un_hide()

    def show_message(self, title, message, filename=None, data=None, data_base64=None, messageicon=None,
                     time=(SYSTEM_TRAY_MESSAGE_FADE_IN_DURATION, SYSTEM_TRAY_MESSAGE_DISPLAY_DURATION_IN_MILLISECONDS)):
        """
        Shows a balloon above icon in system tray
        :param title:       Title shown in balloon
        :type title:        str
        :param message:     Message to be displayed
        :type message:      str
        :param filename:    Optional icon filename
        :type filename:     str
        :param data:        Optional in-ram icon
        :type data:         bytes
        :param data_base64: Optional base64 icon
        :type data_base64:  bytes
        :param time:        Amount of time to display message in milliseconds. If tuple, first item is fade in/out duration
        :type time:         int | (int, int)
        :return:            The event that happened during the display such as user clicked on message
        :rtype:             Any
        """
        if isinstance(time, tuple):
            fade_duration, display_duration = time
        else:
            fade_duration = SYSTEM_TRAY_MESSAGE_FADE_IN_DURATION
            display_duration = time

        user_icon = data_base64 or filename or data or messageicon

        event = self.notify(title, message, icon=user_icon, fade_in_duration=fade_duration, display_duration_in_ms=display_duration)
        self.last_message_event = event
        return event

    def close(self):
        """Closes the system tray window"""
        self.window.close()

    def update(self, menu=None, tooltip=None, filename=None, data=None, data_base64=None, ):
        """Updates the menu, tooltip or icon

        :param menu:        menu defintion
        :type menu:         ???
        :param tooltip:     string representing tooltip
        :type tooltip:      ???
        :param filename:    icon filename
        :type filename:     ???
        :param data:        icon raw image
        :type data:         ???
        :param data_base64: icon base 64 image
        :type data_base64:  ???
        """
        # Menu
        if menu is not None:
            top_menu = tk.Menu(self.window.TKroot, tearoff=False)
            AddMenuItem(top_menu, menu[1], self.window['-IMAGE-'])
            self.window['-IMAGE-'].TKRightClickMenu = top_menu

        if filename:
            self.window['-IMAGE-'].update(filename=filename)
        elif data_base64:
            self.window['-IMAGE-'].update(data=data_base64)
        elif data:
            self.window['-IMAGE-'].update(data=data)
        if tooltip:
            self.window['-IMAGE-'].set_tooltip(tooltip)

    @classmethod
    def notify(cls, title, message, icon=_tray_icon_success, display_duration_in_ms=SYSTEM_TRAY_MESSAGE_DISPLAY_DURATION_IN_MILLISECONDS,
               fade_in_duration=SYSTEM_TRAY_MESSAGE_FADE_IN_DURATION, alpha=0.9, location=None):
        """Displays a notification window

        Usually in the bottom right corner of your display.
        Has an icon, a title, and a message.

        The window will slowly fade in and out if desired.
        Clicking on the window will cause it to move through the end the current "phase".
        For example, if the window was fading in and it was clicked, then it would
        immediately stop fading in and instead be fully visible.
        It's a way for the user to quickly dismiss the window.

        :param title:                  Text to be shown at the top of the window in a larger font
        :type title:                   (str)
        :param message:                Text message that makes up the majority of the window
        :type message:                 (str)
        :param icon:                   A base64 encoded PNG/GIF image or PNG/GIF filename that will be displayed in the window
        :type icon:                    bytes | str
        :param display_duration_in_ms: Number of milliseconds to show the window
        :type display_duration_in_ms:  (int)
        :param fade_in_duration:       Number of milliseconds to fade window in and out
        :type fade_in_duration:        (int)
        :param alpha:                  Alpha channel. 0 - invisible 1 - fully visible
        :type alpha:                   (float)
        :param location:               Location on the screen to display the window
        :type location:                (int, int)
        :return:                       (int) reason for returning
        :rtype:                        (int)
        """

        messages = message.split('\n')
        full_msg = ''
        for m in messages:
            m_wrap = textwrap.fill(m, SYSTEM_TRAY_MESSAGE_MAX_LINE_LENGTH)
            full_msg += m_wrap + '\n'
        message = full_msg[:-1]

        win_msg_lines = message.count("\n") + 1
        max_line = max(message.split('\n'))

        screen_res_x, screen_res_y = Window.get_screen_size()
        win_margin = SYSTEM_TRAY_WIN_MARGINS  # distance from screen edges
        win_width, win_height = 364, 66 + (14.8 * win_msg_lines)

        layout = [[Graph(canvas_size=(win_width, win_height), graph_bottom_left=(0, win_height), graph_top_right=(win_width, 0), key="-GRAPH-",
                         background_color=SYSTEM_TRAY_MESSAGE_WIN_COLOR, enable_events=True)]]

        win_location = location if location is not None else (screen_res_x - win_width - win_margin[0], screen_res_y - win_height - win_margin[1])
        window = Window(title, layout, background_color=SYSTEM_TRAY_MESSAGE_WIN_COLOR, no_titlebar=True,
                        location=win_location, keep_on_top=True, alpha_channel=0, margins=(0, 0), element_padding=(0, 0), grab_anywhere=True, finalize=True)

        window["-GRAPH-"].draw_rectangle((win_width, win_height), (-win_width, -win_height), fill_color=SYSTEM_TRAY_MESSAGE_WIN_COLOR,
                                         line_color=SYSTEM_TRAY_MESSAGE_WIN_COLOR)
        if type(icon) is bytes:
            window["-GRAPH-"].draw_image(data=icon, location=(20, 20))
        elif icon is not None:
            window["-GRAPH-"].draw_image(filename=icon, location=(20, 20))
        window["-GRAPH-"].draw_text(title, location=(64, 20), color=SYSTEM_TRAY_MESSAGE_TEXT_COLOR, font=("Helvetica", 12, "bold"),
                                    text_location=TEXT_LOCATION_TOP_LEFT)
        window["-GRAPH-"].draw_text(message, location=(64, 44), color=SYSTEM_TRAY_MESSAGE_TEXT_COLOR, font=("Helvetica", 9),
                                    text_location=TEXT_LOCATION_TOP_LEFT)
        window["-GRAPH-"].set_cursor('hand2')

        if fade_in_duration:
            for i in range(1, int(alpha * 100)):  # fade in
                window.set_alpha(i / 100)
                event, values = window.read(timeout=fade_in_duration // 100)
                if event != TIMEOUT_KEY:
                    window.set_alpha(1)
                    break
            if event != TIMEOUT_KEY:
                window.close()
                return EVENT_SYSTEM_TRAY_MESSAGE_CLICKED if event == '-GRAPH-' else event
            event, values = window(timeout=display_duration_in_ms)
            if event == TIMEOUT_KEY:
                for i in range(int(alpha * 100), 1, -1):  # fade out
                    window.set_alpha(i / 100)
                    event, values = window.read(timeout=fade_in_duration // 100)
                    if event != TIMEOUT_KEY:
                        break
        else:
            window.set_alpha(alpha)
            event, values = window(timeout=display_duration_in_ms)
        window.close()

        return EVENT_SYSTEM_TRAY_MESSAGE_CLICKED if event == '-GRAPH-' else event

    Close = close
    Hide = hide
    Read = read
    ShowMessage = show_message
    UnHide = un_hide
    Update = update

# ################################################################################
# ################################################################################
#  END OF ELEMENT DEFINITIONS
# ################################################################################
# ################################################################################

# =========================================================================== #
# Button Lazy Functions so the caller doesn't have to define a bunch of stuff #
# =========================================================================== #

# ------------------------- A fake Element... the Sizer Element ------------------------- #
def Sizer(h_pixels=0, v_pixels=0):
    """'Pushes' out the size of whatever it is placed inside of

    This includes Columns, Frames, Tabs and Windows.

    :param h_pixels: number of horizontal pixels
    :type h_pixels:  (int)
    :param v_pixels: number of vertical pixels
    :type v_pixels:  (int)
    :return:         (Canvas) A canvas element that has a pad setting set according to parameters
    :rtype:          (Canvas)
    """
    return Canvas(size=(0, 0), pad=((h_pixels, 0), (v_pixels, 0)))

def pin(elem, vertical_alignment=None, shrink=True, expand_x=None, expand_y=None):
    """'Pins' an element provided into a layout so that when
        it's made invisible and visible again, it will be in the correct place

    Otherwise it will be placed at the end of its containing window/column.

    The element you want to pin is the element
    that you'll be making visibile/invisible.

    The pin helper function also causes containers to shrink to fit
    the contents correct after something inside has changed visiblity.
    NOTE: Setting a hardcoded size on your window can impact this
    ability to shrink.

    :param elem:               the element to put into the layout
    :type elem:                Element
    :param vertical_alignment: Aligns elements vertically. 'top', 'center', 'bottom'. Can be shortened to 't', 'c', 'b'
    :type vertical_alignment:  str | None
    :param shrink:             If True, then the space will shrink down to a single pixel when hidden. False leaves the area large and blank
    :type shrink:              bool
    :param expand_x:           If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_x:            (bool)
    :param expand_y:           If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_y:            (bool)
    :return:                   A column element containing the provided element
    :rtype:                    Column
    """
    if shrink:
        # return Column([[elem, Canvas(size=(0, 0),background_color=elem.BackgroundColor, pad=(0, 0))]], pad=(0, 0), vertical_alignment=vertical_alignment, expand_x=expand_x, expand_y=expand_y)
        return Column([[elem, Column([[]], pad=(0, 0))]], pad=(0, 0), vertical_alignment=vertical_alignment, expand_x=expand_x, expand_y=expand_y)
    else:
        return Column([[elem]], pad=(0, 0), vertical_alignment=vertical_alignment, expand_x=expand_x, expand_y=expand_y)


def vtop(elem_or_row, expand_x=None, expand_y=None, background_color=None):
    """Aligns an element or a row of elements to the top
        of the row that contains it

    :param elem_or_row:      the element or row of elements
    :type elem_or_row:       Element | List[Element] | Tuple[Element]
    :param expand_x:         If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_x:          (bool)
    :param expand_y:         If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_y:          (bool)
    :param background_color: Background color for container that is used by vtop to do the alignment
    :type background_color:  str | None
    :return:                 A column element containing the provided element aligned to the top or list of elements (a row)
    :rtype:                  Column | List[Column]
    """

    if isinstance(elem_or_row, list) or isinstance(elem_or_row, tuple):
        return [Column([[e]], pad=(0, 0), vertical_alignment='top', expand_x=expand_x, expand_y=expand_y, background_color=background_color) for e in elem_or_row]

    return Column([[elem_or_row]], pad=(0, 0), vertical_alignment='top', expand_x=expand_x, expand_y=expand_y, background_color=background_color)


def vcenter(elem_or_row, expand_x=None, expand_y=None, background_color=None):
    """Aligns an element or a row of elements to the center
        of the row that contains it

    :param elem_or_row:      the element or row of elements
    :type elem_or_row:       Element | List[Element] | Tuple[Element]
    :param expand_x:         If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_x:          (bool)
    :param expand_y:         If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_y:          (bool)
    :param background_color: Background color for container that is used by vcenter to do the alignment
    :type background_color:  str | None
    :return:                 A column element containing the provided element aligned to the center or list of elements (a row)
    :rtype:                  Column | List[Column]
    """

    if isinstance(elem_or_row, list) or isinstance(elem_or_row, tuple):
        return [Column([[e]], pad=(0, 0), vertical_alignment='center', expand_x=expand_x, expand_y=expand_y, background_color=background_color) for e in elem_or_row]

    return Column([[elem_or_row]], pad=(0, 0), vertical_alignment='center', expand_x=expand_x, expand_y=expand_y, background_color=background_color)


def vbottom(elem_or_row, expand_x=None, expand_y=None, background_color=None):
    """Aligns an element or a row of elements to the bottom
        of the row that contains it

    :param elem_or_row:      the element or row of elements
    :type elem_or_row:       Element | List[Element] | Tuple[Element]
    :param expand_x:         If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_x:          (bool)
    :param expand_y:         If True/False the value will be passed to the Column Elements used to make this feature
    :type expand_y:          (bool)
    :param background_color: Background color for container that is used by vcenter to do the alignment
    :type background_color:  str | None
    :return:                 A column element containing the provided element aligned to the bottom or list of elements (a row)
    :rtype:                  Column | List[Column]
    """

    if isinstance(elem_or_row, list) or isinstance(elem_or_row, tuple):
        return [Column([[e]], pad=(0, 0), vertical_alignment='bottom', expand_x=expand_x, expand_y=expand_y, background_color=background_color) for e in elem_or_row]

    return Column([[elem_or_row]], pad=(0, 0), vertical_alignment='bottom', expand_x=expand_x, expand_y=expand_y, background_color=background_color)


def Titlebar(title='', icon=None, text_color=None, background_color=None, font=None, key=None, k=None):
    """A custom title bar that replaces the OS provided title bar,
        thus giving you control

    NOTE: LINUX users at the moment the minimize function is not yet working.
    Windows users should have no problem and it should function
    as a normal window would.

    This titlebar is created from a row of elements that is then encapsulated
    into single Column element which is what this Titlebar function returns.

    A custom titlebar removes the margins from your window.
    If you want the  remainder of your Window to have margins,
    place the layout after the Titlebar into a Column and
    set the pad of that Column to the dimensions you would
    like your margins to have.

    The Titlebar is a COLUMN element.  You can thus call the update method
    for the column and perform operations such as making the column
    visible/invisible

    :param icon:             Can be either a filename or Base64 byte string of a PNG or GIF. This is used in an Image element to create the titlebar
    :type icon:              str or bytes or None
    :param title:            The "title" to show in the titlebar
    :type title:             str
    :param text_color:       Text color for titlebar
    :type text_color:        str | None
    :param background_color: Background color for titlebar
    :type background_color:  str | None
    :param font:             Font to be used for the text and the symbols
    :type font:              (str or (str, int[, str]) or None)
    :param key:              Identifies an Element. Should be UNIQUE to this window.
    :type key:               str | int | tuple | object | None
    :param k:                Exactly the same as key.  Choose one of them to use
    :type k:                 str | int | tuple | object | None
    :return:                 A single Column element that has eveything in 1 element
    :rtype:                  Column
    """
    bc = background_color or CUSTOM_TITLEBAR_BACKGROUND_COLOR or theme_button_color()[1]
    tc = text_color or CUSTOM_TITLEBAR_TEXT_COLOR or theme_button_color()[0]
    font = font or CUSTOM_TITLEBAR_FONT or ('Helvetica', 12)
    key = k or key
    if key is None:
        key = TITLEBAR_KEY
    if isinstance(icon, bytes):
        icon_and_text_portion = [Image(data=icon, background_color=bc, key=TITLEBAR_IMAGE_KEY)]
    elif icon == TITLEBAR_DO_NOT_USE_AN_ICON:
        icon_and_text_portion = []
    elif icon is not None:
        icon_and_text_portion = [Image(filename=icon, background_color=bc, key=TITLEBAR_IMAGE_KEY)]
    elif CUSTOM_TITLEBAR_ICON is not None:
        if isinstance(CUSTOM_TITLEBAR_ICON, bytes):
            icon_and_text_portion = [Image(data=CUSTOM_TITLEBAR_ICON, background_color=bc, key=TITLEBAR_IMAGE_KEY)]
        else:
            icon_and_text_portion = [Image(filename=CUSTOM_TITLEBAR_ICON, background_color=bc, key=TITLEBAR_IMAGE_KEY)]
    else:
        icon_and_text_portion = [Image(data=DEFAULT_BASE64_ICON_16_BY_16, background_color=bc, key=TITLEBAR_IMAGE_KEY)]

    icon_and_text_portion += [T(title, text_color=tc, background_color=bc, font=font, grab=True, key=TITLEBAR_TEXT_KEY)]

    return Column([[Column([icon_and_text_portion], pad=(0, 0), background_color=bc),
                    Column([[T(SYMBOL_TITLEBAR_MINIMIZE, text_color=tc, background_color=bc, enable_events=True, font=font, key=TITLEBAR_MINIMIZE_KEY),
                             Text(SYMBOL_TITLEBAR_MAXIMIZE, text_color=tc, background_color=bc, enable_events=True, font=font, key=TITLEBAR_MAXIMIZE_KEY),
                             Text(SYMBOL_TITLEBAR_CLOSE, text_color=tc, background_color=bc, font=font, enable_events=True, key=TITLEBAR_CLOSE_KEY), ]],
                           element_justification='r', expand_x=True, grab=True, pad=(0, 0), background_color=bc)]], expand_x=True, grab=True,
                  background_color=bc, pad=(0, 0), metadata=TITLEBAR_METADATA_MARKER, key=key)


def MenubarCustom(menu_definition, disabled_text_color=None, bar_font=None, font=None, tearoff=False, pad=0, p=None, background_color=None, text_color=None,
                  bar_background_color=None, bar_text_color=None, key=None, k=None):
    """Custom menu bar that replaces the OS provided menu bar

    Why?
    Two reasons - 1. they look great (see custom titlebar) 2. if you have a custom titlebar, then you have to use a custom menubar if you want a menubar

    :param menu_definition:      The Menu definition specified using lists (docs explain the format)
    :type menu_definition:       List[List[Tuple[str, List[str]]]
    :param disabled_text_color:  color to use for text when item is disabled. Can be in #RRGGBB format or a color name "black"
    :type disabled_text_color:   (str)
    :param bar_font:             specifies the font family, size to be used for the chars in the bar itself
    :type bar_font:              (str or (str, int[, str]) or None)
    :param font:                 specifies the font family, size to be used for the menu items
    :type font:                  (str or (str, int[, str]) or None)
    :param tearoff:              if True, then can tear the menu off from the window ans use as a floating window. Very cool effect
    :type tearoff:               (bool)
    :param pad:                  Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int).  TIP - 0 will make flush with titlebar
    :type pad:                   (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                    Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                     (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param background_color:     color to use for background of the menus that are displayed after making a section. Can be in #RRGGBB format or a color name "black". Defaults to the color of the bar text
    :type background_color:      (str)
    :param text_color:           color to use for the text of the many items in the displayed menus. Can be in #RRGGBB format or a color name "black". Defaults to the bar background
    :type text_color:            (str)
    :param bar_background_color: color to use for the menubar. Can be in #RRGGBB format or a color name "black". Defaults to theme's button text color
    :type bar_background_color:  (str)
    :param bar_text_color:       color to use for the menu items text. Can be in #RRGGBB format or a color name "black". Defaults to theme's button background color
    :type bar_text_color:        (str)
    :param key:                  Value that uniquely identifies this element from all other elements. Used when Finding an element or in return values. Must be unique to the window
    :type key:                   str | int | tuple | object
    :param k:                    Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                     str | int | tuple | object
    :returns:                    A Column element that has a series of ButtonMenu elements
    :rtype:                      Column
    """

    bar_bg = bar_background_color if bar_background_color is not None else theme_button_color()[0]
    bar_text = bar_text_color if bar_text_color is not None else theme_button_color()[1]
    menu_bg = background_color if background_color is not None else bar_text
    menu_text = text_color if text_color is not None else bar_bg
    pad = pad if pad is not None else p

    row = []
    for menu in menu_definition:
        text = menu[0]
        if MENU_SHORTCUT_CHARACTER in text:
            text = text.replace(MENU_SHORTCUT_CHARACTER, '')
        if text.startswith(MENU_DISABLED_CHARACTER):
            disabled = True
            text = text[len(MENU_DISABLED_CHARACTER):]
        else:
            disabled = False

        button_menu = ButtonMenu(text, menu, border_width=0, button_color=(bar_text, bar_bg), key=text, pad=(0, 0), disabled=disabled, font=bar_font,
                                 item_font=font, disabled_text_color=disabled_text_color, text_color=menu_text, background_color=menu_bg, tearoff=tearoff)
        button_menu.part_of_custom_menubar = True
        button_menu.custom_menubar_key = key if key is not None else k
        row += [button_menu]
    return Column([row], pad=pad, background_color=bar_bg, expand_x=True, key=key if key is not None else k)


# -------------------------  FOLDER BROWSE Element lazy function  ------------------------- #
def FolderBrowse(button_text='Browse', target=(ThisRow, -1), initial_folder=None, tooltip=None, size=(None, None), s=(None, None),
                 auto_size_button=None, button_color=None, disabled=False, change_submits=False, enable_events=False,
                 font=None, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'Browse')
    :type button_text:       (str)
    :param target:           target for the button (Default value = (ThisRow, -1))
    :type target:            str | (int, int)
    :param initial_folder:   starting path for folders and files
    :type initial_folder:    (str)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param change_submits:   If True, pressing Enter key submits window (Default = False)
    :type enable_events:     (bool)
    :param enable_events:    Turns on the element specific events.(Default = False)
    :type enable_events:     (bool)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              Used with window.find_element and with return values to uniquely identify this element
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 The Button created
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_BROWSE_FOLDER, target=target,
                  initial_folder=initial_folder, tooltip=tooltip, size=size, s=s, auto_size_button=auto_size_button,
                  disabled=disabled, button_color=button_color, change_submits=change_submits,
                  enable_events=enable_events, font=font, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  FILE BROWSE Element lazy function  ------------------------- #
def FileBrowse(button_text='Browse', target=(ThisRow, -1), file_types=FILE_TYPES_ALL_FILES, initial_folder=None,
               tooltip=None, size=(None, None), s=(None, None), auto_size_button=None, button_color=None, change_submits=False,
               enable_events=False, font=None, disabled=False,
               pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'Browse')
    :type button_text:       (str)
    :param target:           key or (row,col) target for the button (Default value = (ThisRow, -1))
    :type target:            str | (int, int)
    :param file_types:       filter file types Default value = (("ALL Files", "*.* *"),).
    :type file_types:        Tuple[(str, str), ...]
    :param initial_folder:   starting path for folders and files
    :type initial_folder:
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param change_submits:   If True, pressing Enter key submits window (Default = False)
    :type change_submits:    (bool)
    :param enable_events:    Turns on the element specific events.(Default = False)
    :type enable_events:     (bool)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_BROWSE_FILE, target=target, file_types=file_types,
                  initial_folder=initial_folder, tooltip=tooltip, size=size, s=s, auto_size_button=auto_size_button,
                  change_submits=change_submits, enable_events=enable_events, disabled=disabled,
                  button_color=button_color, font=font, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  FILES BROWSE Element (Multiple file selection) lazy function  ------------------------- #
def FilesBrowse(button_text='Browse', target=(ThisRow, -1), file_types=FILE_TYPES_ALL_FILES, disabled=False,
                initial_folder=None, tooltip=None, size=(None, None), s=(None, None), auto_size_button=None, button_color=None,
                change_submits=False, enable_events=False,
                font=None, pad=None, p=None, key=None, k=None, visible=True, files_delimiter=BROWSE_FILES_DELIMITER, metadata=None, expand_x=False, expand_y=False):
    """Allows browsing of multiple files

    File list is returned as a single list with the delimiter defined
    using the files_delimiter parameter.

    :param button_text:      text in the button (Default value = 'Browse')
    :type button_text:       (str)
    :param target:           key or (row,col) target for the button (Default value = (ThisRow, -1))
    :type target:            str | (int, int)
    :param file_types:       Default value = (("ALL Files", "*.* *"),).
    :type file_types:        Tuple[(str, str), ...]
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param initial_folder:   starting path for folders and files
    :type initial_folder:    (str)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param change_submits:   If True, pressing Enter key submits window (Default = False)
    :type change_submits:    (bool)
    :param enable_events:    Turns on the element specific events.(Default = False)
    :type enable_events:     (bool)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param files_delimiter:  String to place between files when multiple files are selected. Normally a ;
    :type files_delimiter:   str
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    button = Button(button_text=button_text, button_type=BUTTON_TYPE_BROWSE_FILES, target=target, file_types=file_types,
                    initial_folder=initial_folder, change_submits=change_submits, enable_events=enable_events,
                    tooltip=tooltip, size=size, s=s, auto_size_button=auto_size_button,
                    disabled=disabled, button_color=button_color, font=font, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)
    button._files_delimiter = files_delimiter
    return button


# -------------------------  FILE BROWSE Element lazy function  ------------------------- #
def FileSaveAs(button_text='Save As...', target=(ThisRow, -1), file_types=FILE_TYPES_ALL_FILES, initial_folder=None,
               default_extension='', disabled=False, tooltip=None, size=(None, None), s=(None, None), auto_size_button=None, button_color=None,
               change_submits=False, enable_events=False, font=None,
               pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:       text in the button (Default value = 'Save As...')
    :type button_text:        (str)
    :param target:            key or (row,col) target for the button (Default value = (ThisRow, -1))
    :type target:             str | (int, int)
    :param file_types:        Default value = (("ALL Files", "*.* *"),).
    :type file_types:         Tuple[(str, str), ...]
    :param default_extension: If no extension entered by user, add this to filename (only used in saveas dialogs)
    :type default_extension:  (str)
    :param initial_folder:    starting path for folders and files
    :type initial_folder:     (str)
    :param disabled:          set disable state for element (Default = False)
    :type disabled:           (bool)
    :param tooltip:           text, that will appear when mouse hovers over the element
    :type tooltip:            (str)
    :param size:              (w,h) w=characters-wide, h=rows-high
    :type size:               (int, int)
    :param s:                 Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                  (int, int)  | (None, None) | int
    :param auto_size_button:  True if button size is determined by button text
    :type auto_size_button:   (bool)
    :param button_color:      button color (foreground, background)
    :type button_color:       (str, str) | str
    :param change_submits:    If True, pressing Enter key submits window (Default = False)
    :type change_submits:     (bool)
    :param enable_events:     Turns on the element specific events.(Default = False)
    :type enable_events:      (bool)
    :param font:              specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:               (str or (str, int[, str]) or None)
    :param pad:               Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:                (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                 Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                  (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:               key for uniquely identify this element (for window.find_element)
    :type key:                str | int | tuple | object
    :param k:                 Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                  str | int | tuple | object
    :param visible:           set initial visibility state of the Button
    :type visible:            (bool)
    :param metadata:          Anything you want to store along with this button
    :type metadata:           (Any)
    :param expand_x:          If True Element will expand in the Horizontal directions
    :type expand_x:           (bool)
    :param expand_y:          If True Element will expand in the Vertical directions
    :type expand_y:           (bool)        :return:                  returns a button
    :rtype:                   (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_SAVEAS_FILE, target=target, file_types=file_types,
                  initial_folder=initial_folder, default_extension=default_extension, tooltip=tooltip, size=size, s=s, disabled=disabled,
                  auto_size_button=auto_size_button, button_color=button_color, change_submits=change_submits,
                  enable_events=enable_events, font=font, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  SAVE AS Element lazy function  ------------------------- #
def SaveAs(button_text='Save As...', target=(ThisRow, -1), file_types=FILE_TYPES_ALL_FILES, initial_folder=None, default_extension='',
           disabled=False, tooltip=None, size=(None, None), s=(None, None), auto_size_button=None, button_color=None,
           change_submits=False, enable_events=False, font=None,
           pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:       text in the button (Default value = 'Save As...')
    :type button_text:        (str)
    :param target:            key or (row,col) target for the button (Default value = (ThisRow, -1))
    :type target:             str | (int, int)
    :param file_types:        Default value = (("ALL Files", "*.* *"),).
    :type file_types:         Tuple[(str, str), ...]
    :param default_extension: If no extension entered by user, add this to filename (only used in saveas dialogs)
    :type default_extension:  (str)
    :param initial_folder:    starting path for folders and files
    :type initial_folder:     (str)
    :param disabled:          set disable state for element (Default = False)
    :type disabled:           (bool)
    :param tooltip:           text, that will appear when mouse hovers over the element
    :type tooltip:            (str)
    :param size:              (w,h) w=characters-wide, h=rows-high
    :type size:               (int, int)
    :param s:                 Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                  (int, int)  | (None, None) | int
    :param auto_size_button:  True if button size is determined by button text
    :type auto_size_button:   (bool)
    :param button_color:      button color (foreground, background)
    :type button_color:       (str, str) | str
    :param change_submits:    If True, pressing Enter key submits window (Default = False)
    :type change_submits:     (bool)
    :param enable_events:     Turns on the element specific events.(Default = False)
    :type enable_events:      (bool)
    :param font:              specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:               (str or (str, int[, str]) or None)
    :param pad:               Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:                (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                 Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                  (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int    :param key:               key for uniquely identify this element (for window.find_element)
    :type key:                str | int | tuple | object
    :param k:                 Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                  str | int | tuple | object
    :param visible:           set initial visibility state of the Button
    :type visible:            (bool)
    :param metadata:          Anything you want to store along with this button
    :type metadata:           (Any)
    :param expand_x:          If True Element will expand in the Horizontal directions
    :type expand_x:           (bool)
    :param expand_y:          If True Element will expand in the Vertical directions
    :type expand_y:           (bool)
    :return:                  returns a button
    :rtype:                   (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_SAVEAS_FILE, target=target, file_types=file_types,
                  initial_folder=initial_folder, default_extension=default_extension, tooltip=tooltip, size=size, s=s, disabled=disabled,
                  auto_size_button=auto_size_button, button_color=button_color, change_submits=change_submits,
                  enable_events=enable_events, font=font, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  SAVE BUTTON Element lazy function  ------------------------- #
def Save(button_text='Save', size=(None, None), s=(None, None), auto_size_button=None, button_color=None, bind_return_key=True,
         disabled=False, tooltip=None, font=None, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'Save')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param bind_return_key:  (Default = True) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_READ_FORM, tooltip=tooltip, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  SUBMIT BUTTON Element lazy function  ------------------------- #
def Submit(button_text='Submit', size=(None, None), s=(None, None), auto_size_button=None, button_color=None, disabled=False,
           bind_return_key=True, tooltip=None, font=None, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'Submit')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param bind_return_key:  (Default = True) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_READ_FORM, tooltip=tooltip, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  OPEN BUTTON Element lazy function  ------------------------- #
def Open(button_text='Open', size=(None, None), s=(None, None), auto_size_button=None, button_color=None, disabled=False,
         bind_return_key=True, tooltip=None, font=None, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'Open')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param bind_return_key:  (Default = True) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_READ_FORM, tooltip=tooltip, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  OK BUTTON Element lazy function  ------------------------- #
def OK(button_text='OK', size=(None, None), s=(None, None), auto_size_button=None, button_color=None, disabled=False,
       bind_return_key=True, tooltip=None, font=None, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'OK')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param bind_return_key:  (Default = True) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_READ_FORM, tooltip=tooltip, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  YES BUTTON Element lazy function  ------------------------- #
def Ok(button_text='Ok', size=(None, None), s=(None, None), auto_size_button=None, button_color=None, disabled=False,
       bind_return_key=True, tooltip=None, font=None, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'Ok')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param bind_return_key:  (Default = True) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_READ_FORM, tooltip=tooltip, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  CANCEL BUTTON Element lazy function  ------------------------- #
def Cancel(button_text='Cancel', size=(None, None), s=(None, None), auto_size_button=None, button_color=None, disabled=False,
           tooltip=None, font=None, bind_return_key=False, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'Cancel')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_READ_FORM, tooltip=tooltip, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  QUIT BUTTON Element lazy function  ------------------------- #
def Quit(button_text='Quit', size=(None, None), s=(None, None), auto_size_button=None, button_color=None, disabled=False, tooltip=None,
         font=None, bind_return_key=False, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'Quit')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:             (bool)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_READ_FORM, tooltip=tooltip, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  Exit BUTTON Element lazy function  ------------------------- #
def Exit(button_text='Exit', size=(None, None), s=(None, None), auto_size_button=None, button_color=None, disabled=False, tooltip=None,
         font=None, bind_return_key=False, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'Exit')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_READ_FORM, tooltip=tooltip, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  YES BUTTON Element lazy function  ------------------------- #
def Yes(button_text='Yes', size=(None, None), s=(None, None), auto_size_button=None, button_color=None, disabled=False, tooltip=None,
        font=None, bind_return_key=True, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'Yes')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = True) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_READ_FORM, tooltip=tooltip, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  NO BUTTON Element lazy function  ------------------------- #
def No(button_text='No', size=(None, None), s=(None, None), auto_size_button=None, button_color=None, disabled=False, tooltip=None,
       font=None, bind_return_key=False, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'No')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, then the return key will cause a the Listbox to generate an event
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_READ_FORM, tooltip=tooltip, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  NO BUTTON Element lazy function  ------------------------- #
def Help(button_text='Help', size=(None, None), s=(None, None), auto_size_button=None, button_color=None, disabled=False, font=None,
         tooltip=None, bind_return_key=False, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button (Default value = 'Help')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param bind_return_key:  (Default = False) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_READ_FORM, tooltip=tooltip, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  NO BUTTON Element lazy function  ------------------------- #
def Debug(button_text='', size=(None, None), s=(None, None), auto_size_button=None, button_color=None, disabled=False, font=None,
          tooltip=None, bind_return_key=False, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    This Button has been changed in how it works!!
    Your button has been replaced with a normal button that has the FreeSimpleGUI Debugger buggon logo on it.
    In your event loop, you will need to check for the event of this button and then call:
            show_debugger_popout_window()
    :param button_text:      text in the button (Default value = '')
    :type button_text:       (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param bind_return_key:  (Default = False) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """

    user_key = key if key is not None else k if k is not None else button_text

    return Button(button_text='', button_type=BUTTON_TYPE_READ_FORM, tooltip=tooltip, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=theme_button_color(), font=font, disabled=disabled,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=user_key, k=k, visible=visible, image_data=PSG_DEBUGGER_LOGO,
                  image_subsample=2, border_width=0, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  GENERIC BUTTON Element lazy function  ------------------------- #
def ReadButton(button_text, image_filename=None, image_data=None, image_size=(None, None), image_subsample=None,
               border_width=None, tooltip=None, size=(None, None), s=(None, None), auto_size_button=None, button_color=None, font=None,
               bind_return_key=False, disabled=False, focus=False, pad=None, p=None, key=None, k=None, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button
    :type button_text:       (str)
    :param image_filename:   image filename if there is a button image
    :type image_filename:    image filename if there is a button image
    :param image_data:       in-RAM image to be displayed on button
    :type image_data:        in-RAM image to be displayed on button
    :param image_size:       image size (O.K.)
    :type image_size:        (Default = (None))
    :param image_subsample:  amount to reduce the size of the image
    :type image_subsample:   amount to reduce the size of the image
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param focus:            if focus should be set to this
    :type focus:             idk_yetReally
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param border_width:     width of border around element
    :type border_width:      (int)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 Button created
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_READ_FORM, image_filename=image_filename,
                  image_data=image_data, image_size=image_size, image_subsample=image_subsample,
                  border_width=border_width, tooltip=tooltip, size=size, s=s, disabled=disabled,
                  auto_size_button=auto_size_button, button_color=button_color, font=font,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


ReadFormButton = ReadButton
RButton = ReadFormButton


# -------------------------  Realtime BUTTON Element lazy function  ------------------------- #
def RealtimeButton(button_text, image_filename=None, image_data=None, image_size=(None, None), image_subsample=None,
                   border_width=None, tooltip=None, size=(None, None), s=(None, None), auto_size_button=None, button_color=None,
                   font=None, disabled=False, bind_return_key=False, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button
    :type button_text:       (str)
    :param image_filename:   image filename if there is a button image
    :type image_filename:    image filename if there is a button image
    :param image_data:       in-RAM image to be displayed on button
    :type image_data:        in-RAM image to be displayed on button
    :param image_size:       image size (O.K.)
    :type image_size:        (Default = (None))
    :param image_subsample:  amount to reduce the size of the image
    :type image_subsample:   amount to reduce the size of the image
    :param border_width:     width of border around element
    :type border_width:      (int)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param bind_return_key:  (Default = False) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:             (bool)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 Button created
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_REALTIME, image_filename=image_filename,
                  image_data=image_data, image_size=image_size, image_subsample=image_subsample,
                  border_width=border_width, tooltip=tooltip, disabled=disabled, size=size, s=s,
                  auto_size_button=auto_size_button, button_color=button_color, font=font,
                  bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  Dummy Button Element lazy function  ------------------------- #
def DummyButton(button_text, image_filename=None, image_data=None, image_size=(None, None), image_subsample=None,
                border_width=None, tooltip=None, size=(None, None), s=(None, None), auto_size_button=None, button_color=None, font=None,
                disabled=False, bind_return_key=False, focus=False, pad=None, p=None, key=None, k=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """Special type of button

    It will close the window but **not** send an event that the window has been closed.

    It's used in conjunction with non-blocking windows to silently close them.
    They are used to implement the non-blocking popup windows.
    They're also found in some Demo Programs, so look there for proper use.

    :param button_text:      text in the button
    :type button_text:       (str)
    :param image_filename:   image filename if there is a button image
    :type image_filename:    image filename if there is a button image
    :param image_data:       in-RAM image to be displayed on button
    :type image_data:        in-RAM image to be displayed on button
    :param image_size:       image size (O.K.)
    :type image_size:        (Default = (None))
    :param image_subsample:  amount to reduce the size of the image
    :type image_subsample:   amount to reduce the size of the image
    :param border_width:     width of border around element
    :type border_width:      (int)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param bind_return_key:  (Default = False) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param focus:            if focus should be set to this
    :type focus:             (bool)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         Anything you want to store along with this button
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    return Button(button_text=button_text, button_type=BUTTON_TYPE_CLOSES_WIN_ONLY, image_filename=image_filename,
                  image_data=image_data, image_size=image_size, image_subsample=image_subsample,
                  border_width=border_width, tooltip=tooltip, size=size, s=s, auto_size_button=auto_size_button,
                  button_color=button_color, font=font, disabled=disabled, bind_return_key=bind_return_key, focus=focus,
                  pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)


# -------------------------  Calendar Chooser Button lazy function  ------------------------- #
def CalendarButton(button_text, target=(ThisRow, -1), close_when_date_chosen=True, default_date_m_d_y=(None, None, None),
                   image_filename=None, image_data=None, image_size=(None, None),
                   image_subsample=None, tooltip=None, border_width=None, size=(None, None), s=(None, None), auto_size_button=None,
                   button_color=None, disabled=False, font=None, bind_return_key=False, focus=False, pad=None, p=None, enable_events=None,
                   key=None, k=None, visible=True, locale=None, format='%Y-%m-%d %H:%M:%S', begin_at_sunday_plus=0, month_names=None, day_abbreviations=None,
                   title='Choose Date',
                   no_titlebar=True, location=(None, None), metadata=None, expand_x=False, expand_y=False):
    """
    Button that will show a calendar chooser window.  Fills in the target element with result

    :param button_text:            text in the button
    :type button_text:             (str)
    :param target:                 Key or "coordinate" (see docs) of target element
    :type target:                  (int, int) | Any
    :param close_when_date_chosen: (Default = True)
    :type close_when_date_chosen:  bool
    :param default_date_m_d_y:     Beginning date to show
    :type default_date_m_d_y:      (int, int or None, int)
    :param image_filename:         image filename if there is a button image
    :type image_filename:          image filename if there is a button image
    :param image_data:             in-RAM image to be displayed on button
    :type image_data:              in-RAM image to be displayed on button
    :param image_size:             image size (O.K.)
    :type image_size:              (Default = (None))
    :param image_subsample:        amount to reduce the size of the image
    :type image_subsample:         amount to reduce the size of the image
    :param tooltip:                text, that will appear when mouse hovers over the element
    :type tooltip:                 (str)
    :param border_width:           width of border around element
    :type border_width:            width of border around element
    :param size:                   (w,h) w=characters-wide, h=rows-high
    :type size:                    (int, int)
    :param s:                      Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                       (int, int)  | (None, None) | int
    :param auto_size_button:       True if button size is determined by button text
    :type auto_size_button:        (bool)
    :param button_color:           button color (foreground, background)
    :type button_color:            (str, str) | str
    :param disabled:               set disable state for element (Default = False)
    :type disabled:                (bool)
    :param font:                   specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                    (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:         bool
    :param focus:                  if focus should be set to this
    :type focus:                   bool
    :param pad:                    Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:                     (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                      Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                       (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:                    key for uniquely identify this element (for window.find_element)
    :type key:                     str | int | tuple | object
    :param k:                      Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                       str | int | tuple | object
    :param locale:                 defines the locale used to get day names
    :type locale:                  str
    :param format:                 formats result using this strftime format
    :type format:                  str
    :param begin_at_sunday_plus:   Determines the left-most day in the display. 0=sunday, 1=monday, etc
    :type begin_at_sunday_plus:    (int)
    :param month_names:            optional list of month names to use (should be 12 items)
    :type month_names:             List[str]
    :param day_abbreviations:      optional list of abbreviations to display as the day of week
    :type day_abbreviations:       List[str]
    :param title:                  Title shown on the date chooser window
    :type title:                   (str)
    :param no_titlebar:            if True no titlebar will be shown on the date chooser window
    :type no_titlebar:             bool
    :param location:               Location on the screen (x,y) to show the calendar popup window
    :type location:                (int, int)
    :param visible:                set initial visibility state of the Button
    :type visible:                 (bool)
    :param metadata:               Anything you want to store along with this button
    :type metadata:                (Any)
    :param expand_x:               If True Element will expand in the Horizontal directions
    :type expand_x:                (bool)
    :param expand_y:               If True Element will expand in the Vertical directions
    :type expand_y:                (bool)
    :return:                       returns a button
    :rtype:                        (Button)
    """
    button = Button(button_text=button_text, button_type=BUTTON_TYPE_CALENDAR_CHOOSER, target=target,
                    image_filename=image_filename, image_data=image_data, image_size=image_size,
                    image_subsample=image_subsample, border_width=border_width, tooltip=tooltip, size=size, s=s,
                    auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled, enable_events=enable_events,
                    bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)
    button.calendar_close_when_chosen = close_when_date_chosen
    button.calendar_default_date_M_D_Y = default_date_m_d_y
    button.calendar_locale = locale
    button.calendar_format = format
    button.calendar_no_titlebar = no_titlebar
    button.calendar_location = location
    button.calendar_begin_at_sunday_plus = begin_at_sunday_plus
    button.calendar_month_names = month_names
    button.calendar_day_abbreviations = day_abbreviations
    button.calendar_title = title

    return button


# -------------------------  Calendar Chooser Button lazy function  ------------------------- #
def ColorChooserButton(button_text, target=(ThisRow, -1), image_filename=None, image_data=None, image_size=(None, None),
                       image_subsample=None, tooltip=None, border_width=None, size=(None, None), s=(None, None), auto_size_button=None,
                       button_color=None, disabled=False, font=None, bind_return_key=False, focus=False, pad=None, p=None,
                       key=None, k=None, default_color=None, visible=True, metadata=None, expand_x=False, expand_y=False):
    """
    :param button_text:      text in the button
    :type button_text:       (str)
    :param target:           key or (row,col) target for the button. Note that -1 for column means 1 element to the left of this one. The constant ThisRow is used to indicate the current row. The Button itself is a valid target for some types of button
    :type target:            str | (int, int)
    :type image_filename:    (str)
    :param image_filename:   image filename if there is a button image. GIFs and PNGs only.
    :type image_filename:    (str)
    :param image_data:       Raw or Base64 representation of the image to put on button. Choose either filename or data
    :type image_data:        bytes | str
    :param image_size:       Size of the image in pixels (width, height)
    :type image_size:        (int, int)
    :param image_subsample:  amount to reduce the size of the image. Divides the size by this number. 2=1/2, 3=1/3, 4=1/4, etc
    :type image_subsample:   (int)
    :param tooltip:          text, that will appear when mouse hovers over the element
    :type tooltip:           (str)
    :param border_width:     width of border around element
    :type border_width:      (int)
    :param size:             (w,h) w=characters-wide, h=rows-high
    :type size:              (int, int)
    :param s:                Same as size parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, size will be used
    :type s:                 (int, int)  | (None, None) | int
    :param auto_size_button: True if button size is determined by button text
    :type auto_size_button:  (bool)
    :param button_color:     button color (foreground, background)
    :type button_color:      (str, str) | str
    :param disabled:         set disable state for element (Default = False)
    :type disabled:          (bool)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:              (str or (str, int[, str]) or None)
    :param bind_return_key:  (Default = False) If True, this button will appear to be clicked when return key is pressed in other elements such as Input and elements with return key options
    :type bind_return_key:   (bool)
    :param focus:            Determines if initial focus should go to this element.
    :type focus:             (bool)
    :param pad:              Amount of padding to put around element in pixels (left/right, top/bottom) or ((left, right), (top, bottom)) or an int. If an int, then it's converted into a tuple (int, int)
    :type pad:               (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param p:                Same as pad parameter.  It's an alias. If EITHER of them are set, then the one that's set will be used. If BOTH are set, pad will be used
    :type p:                 (int, int) or ((int, int),(int,int)) or (int,(int,int)) or  ((int, int),int) | int
    :param key:              key for uniquely identify this element (for window.find_element)
    :type key:               str | int | tuple | object
    :param k:                Same as the Key. You can use either k or key. Which ever is set will be used.
    :type k:                 str | int | tuple | object
    :param default_color:    Color to be sent to tkinter to use as the default color
    :type default_color:     str
    :param visible:          set initial visibility state of the Button
    :type visible:           (bool)
    :param metadata:         User metadata that can be set to ANYTHING
    :type metadata:          (Any)
    :param expand_x:         If True Element will expand in the Horizontal directions
    :type expand_x:          (bool)
    :param expand_y:         If True Element will expand in the Vertical directions
    :type expand_y:          (bool)
    :return:                 returns a button
    :rtype:                  (Button)
    """
    button = Button(button_text=button_text, button_type=BUTTON_TYPE_COLOR_CHOOSER, target=target,
                    image_filename=image_filename, image_data=image_data, image_size=image_size,
                    image_subsample=image_subsample, border_width=border_width, tooltip=tooltip, size=size, s=s,
                    auto_size_button=auto_size_button, button_color=button_color, font=font, disabled=disabled,
                    bind_return_key=bind_return_key, focus=focus, pad=pad, p=p, key=key, k=k, visible=visible, metadata=metadata, expand_x=expand_x, expand_y=expand_y)
    button.default_color = default_color
    return button


#####################################  -----  Button Functions   ------ ##################################################

def button_color_to_tuple(color_tuple_or_string, default=(None, None)):
    """Converts a color tuple or color string into 2 components
        and returns them as a tuple (Text Color, Button Background Color)

    If `None` is passed in as the first parameter, then the theme's button color is returned.

    :param color_tuple_or_string: Button color - tuple or a simplied color string with word "on" between color
    :type  color_tuple_or_string: str | (str, str)
    :param default:               The 2 colors to use if there is a problem. Otherwise defaults to the theme's button color
    :type  default:               (str, str)
    :return:                      (str | (str, str)
    :rtype:                       str | (str, str)
    """
    if default == (None, None):
        color_tuple = _simplified_dual_color_to_tuple(color_tuple_or_string, default=theme_button_color())
    elif color_tuple_or_string == COLOR_SYSTEM_DEFAULT:
        color_tuple = (COLOR_SYSTEM_DEFAULT, COLOR_SYSTEM_DEFAULT)
    else:
        color_tuple = _simplified_dual_color_to_tuple(color_tuple_or_string, default=default)
    return color_tuple


def _simplified_dual_color_to_tuple(color_tuple_or_string, default=(None, None)):
    """Converts a color tuple or color string into 2 components
        and returns them as a tuple (Text Color, Button Background Color)

    If `None` is passed in as the first parameter, sets default theme's.

    :param color_tuple_or_string: Button color - tuple or a simplied color string with word "on" between color
    :type  color_tuple_or_string: str | (str, str} | (None, None)
    :param default:               The 2 colors to use if there is a problem. Otherwise defaults to the theme's button color
    :type  default:               (str, str)
    :return:                      (str | (str, str)
    :rtype:                       str | (str, str)
    """
    if color_tuple_or_string is None or color_tuple_or_string == (None, None):
        color_tuple_or_string = default
    if color_tuple_or_string == COLOR_SYSTEM_DEFAULT:
        return (COLOR_SYSTEM_DEFAULT, COLOR_SYSTEM_DEFAULT)
    text_color = background_color = COLOR_SYSTEM_DEFAULT
    try:
        if isinstance(color_tuple_or_string, (tuple, list)):
            if len(color_tuple_or_string) >= 2:
                text_color = color_tuple_or_string[0] or default[0]
                background_color = color_tuple_or_string[1] or default[1]
            elif len(color_tuple_or_string) == 1:
                background_color = color_tuple_or_string[0] or default[1]
        elif isinstance(color_tuple_or_string, str):
            color_tuple_or_string = color_tuple_or_string.lower()
            split_colors = color_tuple_or_string.split(' on ')
            if len(split_colors) >= 2:
                text_color = split_colors[0].strip() or default[0]
                background_color = split_colors[1].strip() or default[1]
            elif len(split_colors) == 1:
                split_colors = color_tuple_or_string.split('on')
                if len(split_colors) == 1:
                    text_color, background_color = default[0], split_colors[0].strip()
                else:
                    split_colors = split_colors[0].strip(), split_colors[1].strip()
                    text_color = split_colors[0] or default[0]
                    background_color = split_colors[1] or default[1]
                    # text_color, background_color = color_tuple_or_string, default[1]
            else:
                text_color, background_color = default
        else:
            if not SUPPRESS_ERROR_POPUPS:
                _error_popup_with_traceback(
                    '** Badly formatted dual-color... not a tuple nor string **', color_tuple_or_string)
            else:
                print(
                    '** Badly formatted dual-color... not a tuple nor string **', color_tuple_or_string)
            text_color, background_color = default
    except Exception as e:
        if not SUPPRESS_ERROR_POPUPS:
            _error_popup_with_traceback(
                '** Badly formatted button color **', color_tuple_or_string, e)
        else:
            print(
                '** Badly formatted button color... not a tuple nor string **', color_tuple_or_string, e)
        text_color, background_color = default
    if isinstance(text_color, int):
        text_color = "#%06X" % text_color
    if isinstance(background_color, int):
        background_color = "#%06X" % background_color

    return (text_color, background_color)


#####################################  -----  RESULTS   ------ ##################################################

def AddToReturnDictionary(form, element, value):
    form.ReturnValuesDictionary[element.Key] = value

def AddToReturnList(form, value):
    form.ReturnValuesList.append(value)

# ----------------------------------------------------------------------------#

# -------  FUNCTION InitializeResults.  Sets up form results matrix  --------#
def InitializeResults(form):
    _BuildResults(form, True, form)
    return

# =====  Radio Button RadVar encoding and decoding =====#

# =====  The value is simply the row * 1000 + col  =====#
def DecodeRadioRowCol(RadValue):
    container = RadValue // 100000
    row = RadValue // 1000
    col = RadValue % 1000
    return container, row, col


def EncodeRadioRowCol(container, row, col):
    RadValue = container * 100000 + row * 1000 + col
    return RadValue


# -------  FUNCTION BuildResults.  Form exiting so build the results to pass back  ------- #
# format of return values is
# (Button Pressed, input_values)
def _BuildResults(form, initialize_only, top_level_form):
    """Results for elements are:
        TEXT - nothing
        INPUT - read value from TK
        Button - button text and position as a Tuple
    """
    # Get the initialized results so we don't have to rebuild
    form.ReturnValuesDictionary = {}
    form.ReturnValuesList = []
    _BuildResultsForSubform(form, initialize_only, top_level_form)
    if not top_level_form.LastButtonClickedWasRealtime:
        top_level_form.LastButtonClicked = None
    return form.ReturnValues


def _BuildResultsForSubform(form, initialize_only, top_level_form):
    event = top_level_form.LastButtonClicked
    for row_num, row in enumerate(form.Rows):
        for col_num, element in enumerate(row):
            if element.Key is not None and WRITE_ONLY_KEY in str(element.Key):
                continue
            value = None
            if element.Type == ELEM_TYPE_COLUMN:
                element.DictionaryKeyCounter = top_level_form.DictionaryKeyCounter
                element.ReturnValuesList = []
                element.ReturnValuesDictionary = {}
                _BuildResultsForSubform(element, initialize_only, top_level_form)
                for item in element.ReturnValuesList:
                    AddToReturnList(top_level_form, item)
                if element.UseDictionary:
                    top_level_form.UseDictionary = True
                if element.ReturnValues[0] is not None:  # if a button was clicked
                    event = element.ReturnValues[0]

            if element.Type == ELEM_TYPE_FRAME:
                element.DictionaryKeyCounter = top_level_form.DictionaryKeyCounter
                element.ReturnValuesList = []
                element.ReturnValuesDictionary = {}
                _BuildResultsForSubform(element, initialize_only, top_level_form)
                for item in element.ReturnValuesList:
                    AddToReturnList(top_level_form, item)
                if element.UseDictionary:
                    top_level_form.UseDictionary = True
                if element.ReturnValues[0] is not None:  # if a button was clicked
                    event = element.ReturnValues[0]

            if element.Type == ELEM_TYPE_PANE:
                element.DictionaryKeyCounter = top_level_form.DictionaryKeyCounter
                element.ReturnValuesList = []
                element.ReturnValuesDictionary = {}
                _BuildResultsForSubform(element, initialize_only, top_level_form)
                for item in element.ReturnValuesList:
                    AddToReturnList(top_level_form, item)
                if element.UseDictionary:
                    top_level_form.UseDictionary = True
                if element.ReturnValues[0] is not None:  # if a button was clicked
                    event = element.ReturnValues[0]

            if element.Type == ELEM_TYPE_TAB_GROUP:
                element.DictionaryKeyCounter = top_level_form.DictionaryKeyCounter
                element.ReturnValuesList = []
                element.ReturnValuesDictionary = {}
                _BuildResultsForSubform(element, initialize_only, top_level_form)
                for item in element.ReturnValuesList:
                    AddToReturnList(top_level_form, item)
                if element.UseDictionary:
                    top_level_form.UseDictionary = True
                if element.ReturnValues[0] is not None:  # if a button was clicked
                    event = element.ReturnValues[0]

            if element.Type == ELEM_TYPE_TAB:
                element.DictionaryKeyCounter = top_level_form.DictionaryKeyCounter
                element.ReturnValuesList = []
                element.ReturnValuesDictionary = {}
                _BuildResultsForSubform(element, initialize_only, top_level_form)
                for item in element.ReturnValuesList:
                    AddToReturnList(top_level_form, item)
                if element.UseDictionary:
                    top_level_form.UseDictionary = True
                if element.ReturnValues[0] is not None:  # if a button was clicked
                    event = element.ReturnValues[0]

            if not initialize_only:
                if element.Type == ELEM_TYPE_INPUT_TEXT:
                    try:
                        value = element.TKStringVar.get()
                    except:
                        value = ''
                    if not top_level_form.NonBlocking and not element.do_not_clear and not top_level_form.ReturnKeyboardEvents:
                        element.TKStringVar.set('')
                elif element.Type == ELEM_TYPE_INPUT_CHECKBOX:
                    value = element.TKIntVar.get()
                    value = (value != 0)
                elif element.Type == ELEM_TYPE_INPUT_RADIO:
                    RadVar = element.TKIntVar.get()
                    this_rowcol = EncodeRadioRowCol(form.ContainerElemementNumber, row_num, col_num)
                    #this_rowcol = element.EncodedRadioValue # could use the saved one
                    value = RadVar == this_rowcol
                elif element.Type == ELEM_TYPE_BUTTON:
                    if top_level_form.LastButtonClicked == element.Key:
                        event = top_level_form.LastButtonClicked
                        if element.BType != BUTTON_TYPE_REALTIME:  # Do not clear realtime buttons
                            top_level_form.LastButtonClicked = None
                    if element.BType == BUTTON_TYPE_CALENDAR_CHOOSER:
                        # value = None
                        value = element.calendar_selection
                    else:
                        try:
                            value = element.TKStringVar.get()
                        except:
                            value = None
                elif element.Type == ELEM_TYPE_INPUT_COMBO:
                    element = element  # type: Combo
                    try:
                        if element.TKCombo.current() == -1:  # if the current value was not in the original list
                            value = element.TKCombo.get()
                        else:
                            value = element.Values[element.TKCombo.current()]  # get value from original list given index
                    except:
                        value = '*Exception occurred*'
                elif element.Type == ELEM_TYPE_INPUT_OPTION_MENU:
                    value = element.TKStringVar.get()
                elif element.Type == ELEM_TYPE_INPUT_LISTBOX:
                    try:
                        items = element.TKListbox.curselection()
                        value = [element.Values[int(item)] for item in items]
                    except Exception as e:
                        value = ''
                elif element.Type == ELEM_TYPE_INPUT_SPIN:
                    try:
                        value = element.TKStringVar.get()
                        for v in element.Values:
                            if str(v) == value:
                                value = v
                                break
                    except:
                        value = 0
                elif element.Type == ELEM_TYPE_INPUT_SLIDER:
                    try:
                        value = float(element.TKScale.get())
                    except:
                        value = 0
                elif element.Type == ELEM_TYPE_INPUT_MULTILINE:
                    if element.WriteOnly:  # if marked as "write only" when created, then don't include with the values being returned
                        continue
                    try:
                        value = element.TKText.get(1.0, tk.END)
                        if element.rstrip:
                            value = value.rstrip()
                        if not top_level_form.NonBlocking and not element.do_not_clear and not top_level_form.ReturnKeyboardEvents:
                            element.TKText.delete('1.0', tk.END)
                    except:
                        value = None
                elif element.Type == ELEM_TYPE_TAB_GROUP:
                    try:
                        value = element.TKNotebook.tab(element.TKNotebook.index('current'))['text']
                        tab_key = element.find_currently_active_tab_key()
                        if tab_key is not None:
                            value = tab_key
                    except:
                        value = None
                elif element.Type == ELEM_TYPE_TABLE:
                    value = element.SelectedRows
                elif element.Type == ELEM_TYPE_TREE:
                    value = element.SelectedRows
                elif element.Type == ELEM_TYPE_GRAPH:
                    value = element.ClickPosition
                elif element.Type == ELEM_TYPE_MENUBAR:
                    if element.MenuItemChosen is not None:
                        event = top_level_form.LastButtonClicked = element.MenuItemChosen
                    value = element.MenuItemChosen
                    element.MenuItemChosen = None
                elif element.Type == ELEM_TYPE_BUTTONMENU:
                    element = element  # type: ButtonMenu
                    value = element.MenuItemChosen
                    if element.part_of_custom_menubar:
                        if element.MenuItemChosen is not None:
                            value = event = element.MenuItemChosen
                            top_level_form.LastButtonClicked = element.MenuItemChosen
                            if element.custom_menubar_key is not None:
                                top_level_form.ReturnValuesDictionary[element.custom_menubar_key] = value
                            element.MenuItemChosen = None
                        else:
                            if element.custom_menubar_key not in top_level_form.ReturnValuesDictionary:
                                top_level_form.ReturnValuesDictionary[element.custom_menubar_key] = None
                            value = None

                    # if element.MenuItemChosen is not None:
                    #     button_pressed_text = top_level_form.LastButtonClicked = element.MenuItemChosen
                    # value = element.MenuItemChosen
                    # element.MenuItemChosen = None
            else:
                value = None

            # if an input type element, update the results
            if element.Type not in (
            ELEM_TYPE_BUTTON, ELEM_TYPE_TEXT, ELEM_TYPE_IMAGE, ELEM_TYPE_OUTPUT, ELEM_TYPE_PROGRESS_BAR, ELEM_TYPE_COLUMN, ELEM_TYPE_FRAME, ELEM_TYPE_SEPARATOR,
            ELEM_TYPE_TAB):
                if not (element.Type == ELEM_TYPE_BUTTONMENU and element.part_of_custom_menubar):
                    AddToReturnList(form, value)
                    AddToReturnDictionary(top_level_form, element, value)
            elif (element.Type == ELEM_TYPE_BUTTON and
                  element.BType == BUTTON_TYPE_COLOR_CHOOSER and
                  element.Target == (None, None)) or \
                    (element.Type == ELEM_TYPE_BUTTON
                     and element.Key is not None and
                     (element.BType in (BUTTON_TYPE_SAVEAS_FILE, BUTTON_TYPE_BROWSE_FILE, BUTTON_TYPE_BROWSE_FILES,
                                        BUTTON_TYPE_BROWSE_FOLDER, BUTTON_TYPE_CALENDAR_CHOOSER))):
                AddToReturnList(form, value)
                AddToReturnDictionary(top_level_form, element, value)

    # if this is a column, then will fail so need to wrap with try
    try:
        if form.ReturnKeyboardEvents and form.LastKeyboardEvent is not None:
            event = form.LastKeyboardEvent
            form.LastKeyboardEvent = None
    except:
        pass
    try:
        form.ReturnValuesDictionary.pop(None, None)  # clean up dictionary include None was included
    except:
        pass
    # if no event was found
    if not initialize_only and event is None and form == top_level_form:
        queued_event_value = form._queued_thread_event_read()
        if queued_event_value is not None:
            event, value = queued_event_value
            AddToReturnList(form, value)
            form.ReturnValuesDictionary[event] = value

    if not form.UseDictionary:
        form.ReturnValues = event, form.ReturnValuesList
    else:
        form.ReturnValues = event, form.ReturnValuesDictionary
    return form.ReturnValues


def fill_form_with_values(window, values_dict):
    """Fills a window with values provided in a values dictionary `{ element_key : new_value }`

    :param window:      The window object to fill
    :type window:       (Window)
    :param values_dict: A dictionary with element keys as key and value is values parm for Update call
    :type values_dict:  (Dict[Any, Any])
    :return:            None
    :rtype:             None
    """
    for element_key in values_dict:
        try:
            window.AllKeysDict[element_key].Update(values_dict[element_key])
        except Exception as e:
            print('Problem filling form. Perhaps bad key?  This is a suspected bad key: {}'.format(element_key))


def _FindElementWithFocusInSubForm(form):
    """Searches through a sub-form (can be a window or container)
        for the current element with focus

    :param form: a Window, Column, Frame, or TabGroup (container elements)
    :type form:  container elements
    :return:     Element
    :rtype:      Element | None
    """
    for row_num, row in enumerate(form.Rows):
        for col_num, element in enumerate(row):
            if element.Type == ELEM_TYPE_COLUMN:
                matching_elem = _FindElementWithFocusInSubForm(element)
                if matching_elem is not None:
                    return matching_elem
            elif element.Type == ELEM_TYPE_FRAME:
                matching_elem = _FindElementWithFocusInSubForm(element)
                if matching_elem is not None:
                    return matching_elem
            elif element.Type == ELEM_TYPE_TAB_GROUP:
                matching_elem = _FindElementWithFocusInSubForm(element)
                if matching_elem is not None:
                    return matching_elem
            elif element.Type == ELEM_TYPE_TAB:
                matching_elem = _FindElementWithFocusInSubForm(element)
                if matching_elem is not None:
                    return matching_elem
            elif element.Type == ELEM_TYPE_PANE:
                matching_elem = _FindElementWithFocusInSubForm(element)
                if matching_elem is not None:
                    return matching_elem
            elif element.Type == ELEM_TYPE_INPUT_TEXT:
                if element.TKEntry is not None:
                    if element.TKEntry is element.TKEntry.focus_get():
                        return element
            elif element.Type == ELEM_TYPE_INPUT_MULTILINE:
                if element.TKText is not None:
                    if element.TKText is element.TKText.focus_get():
                        return element
            elif element.Type == ELEM_TYPE_BUTTON:
                if element.TKButton is not None:
                    if element.TKButton is element.TKButton.focus_get():
                        return element
            else:  # The "Catch All" - if type isn't one of the above, try generic element.Widget
                try:
                    if element.Widget is not None:
                        if element.Widget is element.Widget.focus_get():
                            return element
                except:
                    return None

    return None


def AddMenuItem(top_menu, sub_menu_info, element, is_sub_menu=False, skip=False, right_click_menu=False):
    """NOTE: Not a user callable method

    :param top_menu:      ???
    :type top_menu:       ???
    :param sub_menu_info: ???
    :type sub_menu_info:
    :param element:       ???
    :type element:        idk_yetReally
    :param is_sub_menu:   (Default = False)
    :type is_sub_menu:    (bool)
    :param skip:          (Default = False)
    :type skip:           (bool)

    """
    return_val = None
    if type(sub_menu_info) is str:
        if not is_sub_menu and not skip:
            pos = sub_menu_info.find(MENU_SHORTCUT_CHARACTER)
            if pos != -1:
                if pos < len(MENU_SHORTCUT_CHARACTER) or sub_menu_info[pos - len(MENU_SHORTCUT_CHARACTER)] != "\\":
                    sub_menu_info = sub_menu_info[:pos] + sub_menu_info[pos + len(MENU_SHORTCUT_CHARACTER):]
            if sub_menu_info == '---':
                top_menu.add('separator')
            else:
                try:
                    item_without_key = sub_menu_info[:sub_menu_info.index(MENU_KEY_SEPARATOR)]
                except:
                    item_without_key = sub_menu_info

                if item_without_key[0] == MENU_DISABLED_CHARACTER:
                    top_menu.add_command(label=item_without_key[len(MENU_DISABLED_CHARACTER):], underline=pos - 1,
                                         command=lambda: element._MenuItemChosenCallback(sub_menu_info))
                    top_menu.entryconfig(item_without_key[len(MENU_DISABLED_CHARACTER):], state='disabled')
                else:
                    top_menu.add_command(label=item_without_key, underline=pos,
                                         command=lambda: element._MenuItemChosenCallback(sub_menu_info))
    else:
        i = 0
        while i < (len(sub_menu_info)):
            item = sub_menu_info[i]
            if i != len(sub_menu_info) - 1:
                if type(sub_menu_info[i + 1]) == list:
                    new_menu = tk.Menu(top_menu, tearoff=element.Tearoff)
                    # if a right click menu, then get styling from the top-level window
                    if right_click_menu:
                        window = element.ParentForm
                        if window.right_click_menu_background_color not in (COLOR_SYSTEM_DEFAULT, None):
                            new_menu.config(bg=window.right_click_menu_background_color)
                            new_menu.config(activeforeground=window.right_click_menu_background_color)
                        if window.right_click_menu_text_color not in (COLOR_SYSTEM_DEFAULT, None):
                            new_menu.config(fg=window.right_click_menu_text_color)
                            new_menu.config(activebackground=window.right_click_menu_text_color)
                        if window.right_click_menu_disabled_text_color not in (COLOR_SYSTEM_DEFAULT, None):
                            new_menu.config(disabledforeground=window.right_click_menu_disabled_text_color)
                        if window.right_click_menu_font is not None:
                            new_menu.config(font=window.right_click_menu_font)
                    else:
                        if element.Font is not None:
                            new_menu.config(font=element.Font)
                        if element.BackgroundColor not in (COLOR_SYSTEM_DEFAULT, None):
                            new_menu.config(bg=element.BackgroundColor)
                            new_menu.config(activeforeground=element.BackgroundColor)
                        if element.TextColor not in (COLOR_SYSTEM_DEFAULT, None):
                            new_menu.config(fg=element.TextColor)
                            new_menu.config(activebackground=element.TextColor)
                        if element.DisabledTextColor not in (COLOR_SYSTEM_DEFAULT, None):
                            new_menu.config(disabledforeground=element.DisabledTextColor)
                        if element.ItemFont is not None:
                            new_menu.config(font=element.ItemFont)
                    return_val = new_menu
                    pos = sub_menu_info[i].find(MENU_SHORTCUT_CHARACTER)
                    if pos != -1:
                        if pos < len(MENU_SHORTCUT_CHARACTER) or sub_menu_info[i][pos - len(MENU_SHORTCUT_CHARACTER)] != "\\":
                            sub_menu_info[i] = sub_menu_info[i][:pos] + sub_menu_info[i][pos + len(MENU_SHORTCUT_CHARACTER):]
                    if sub_menu_info[i][0] == MENU_DISABLED_CHARACTER:
                        top_menu.add_cascade(label=sub_menu_info[i][len(MENU_DISABLED_CHARACTER):], menu=new_menu,
                                             underline=pos, state='disabled')
                    else:
                        top_menu.add_cascade(label=sub_menu_info[i], menu=new_menu, underline=pos)
                    AddMenuItem(new_menu, sub_menu_info[i + 1], element, is_sub_menu=True, right_click_menu=right_click_menu)
                    i += 1  # skip the next one
                else:
                    AddMenuItem(top_menu, item, element, right_click_menu=right_click_menu)
            else:
                AddMenuItem(top_menu, item, element, right_click_menu=right_click_menu)
            i += 1
    return return_val


# 888    888      d8b          888
# 888    888      Y8P          888
# 888    888                   888
# 888888 888  888 888 88888b.  888888  .d88b.  888d888
# 888    888 .88P 888 888 "88b 888    d8P  Y8b 888P"
# 888    888888K  888 888  888 888    88888888 888
# Y88b.  888 "88b 888 888  888 Y88b.  Y8b.     888
#  "Y888 888  888 888 888  888  "Y888  "Y8888  888


class VarHolder(object):
    canvas_holder = None

    def __init__(self):
        self.canvas_holder = None

# Also, to get to the point in the code where each element's widget is created, look for element + "p lacement" (without the space)

# ========================   TK CODE STARTS HERE ========================================= #
def _fixed_map(style, style_name, option, highlight_colors=(None, None)):
    # Fix for setting text colour for Tkinter 8.6.9
    default_map = [elm for elm in style.map("Treeview", query_opt=option) if '!' not in elm[0] and 'selected' not in elm[0]]
    custom_map = [elm for elm in style.map(style_name, query_opt=option) if '!' not in elm[0] and 'selected' not in elm[0]]
    if option == 'background':
        custom_map.append(('selected', highlight_colors[1] if highlight_colors[1] is not None else ALTERNATE_TABLE_AND_TREE_SELECTED_ROW_COLORS[1]))
    elif option == 'foreground':
        custom_map.append(('selected', highlight_colors[0] if highlight_colors[0] is not None else ALTERNATE_TABLE_AND_TREE_SELECTED_ROW_COLORS[0]))

    new_map = custom_map + default_map
    return new_map

def _add_right_click_menu(element, toplevel_form):
    if element.RightClickMenu == MENU_RIGHT_CLICK_DISABLED:
        return
    if element.RightClickMenu or toplevel_form.RightClickMenu:
        menu = element.RightClickMenu or toplevel_form.RightClickMenu
        top_menu = tk.Menu(toplevel_form.TKroot, tearoff=toplevel_form.right_click_menu_tearoff, tearoffcommand=element._tearoff_menu_callback)

        if toplevel_form.right_click_menu_background_color not in (COLOR_SYSTEM_DEFAULT, None):
            top_menu.config(bg=toplevel_form.right_click_menu_background_color)
        if toplevel_form.right_click_menu_text_color not in (COLOR_SYSTEM_DEFAULT, None):
            top_menu.config(fg=toplevel_form.right_click_menu_text_color)
        if toplevel_form.right_click_menu_disabled_text_color not in (COLOR_SYSTEM_DEFAULT, None):
            top_menu.config(disabledforeground=toplevel_form.right_click_menu_disabled_text_color)
        if toplevel_form.right_click_menu_font is not None:
            top_menu.config(font=toplevel_form.right_click_menu_font)

        if toplevel_form.right_click_menu_selected_colors[0] not in (COLOR_SYSTEM_DEFAULT, None):
            top_menu.config(activeforeground=toplevel_form.right_click_menu_selected_colors[0])
        if toplevel_form.right_click_menu_selected_colors[1] not in (COLOR_SYSTEM_DEFAULT, None):
            top_menu.config(activebackground=toplevel_form.right_click_menu_selected_colors[1])
        AddMenuItem(top_menu, menu[1], element, right_click_menu=True)
        element.TKRightClickMenu = top_menu
        if (running_mac()):
            element.Widget.bind('<ButtonRelease-2>', element._RightClickMenuCallback)
        else:
            element.Widget.bind('<ButtonRelease-3>', element._RightClickMenuCallback)


def _change_ttk_theme(style, theme_name):
    global ttk_theme_in_use
    if theme_name not in style.theme_names():
        _error_popup_with_traceback(
            'You are trying to use TTK theme "{}"'.format(theme_name),
            'This is not legal for your system',
            'The valid themes to choose from are: {}'.format(', '.join(style.theme_names())))
        return False

    style.theme_use(theme_name)
    ttk_theme_in_use = theme_name
    return True


def _make_ttk_style_name(base_style, element, primary_style=False):
    Window._counter_for_ttk_widgets += 1
    style_name = str(Window._counter_for_ttk_widgets) + '___' + str(element.Key) + base_style
    if primary_style:
        element.ttk_style_name = style_name
    return style_name


def _make_ttk_scrollbar(element, orientation, window):
    """Creates a ttk scrollbar for elements as they are being added to the layout

    :param element:     The element
    :type element:      (Element)
    :param orientation: The orientation vertical ('v') or horizontal ('h')
    :type orientation:  (str)
    :param window:      The window containing the scrollbar
    :type window:       (Window)
    """

    style = ttk.Style()
    _change_ttk_theme(style, window.TtkTheme)
    if orientation[0].lower() == 'v':
        orient = 'vertical'
        style_name = _make_ttk_style_name('.Vertical.TScrollbar', element)
        # style_name_thumb = _make_ttk_style_name('.Vertical.TScrollbar.thumb', element)
        element.vsb_style = style
        element.vsb = ttk.Scrollbar(element.element_frame, orient=orient, command=element.Widget.yview, style=style_name)
        element.vsb_style_name = style_name
    else:
        orient = 'horizontal'
        style_name = _make_ttk_style_name('.Horizontal.TScrollbar', element)
        element.hsb_style = style
        element.hsb = ttk.Scrollbar(element.element_frame, orient=orient, command=element.Widget.xview, style=style_name)
        element.hsb_style_name = style_name

    # ------------------ Get the colors using heirarchy of element, window, options, settings ------------------
    # Trough Color
    if element.ttk_part_overrides.sbar_trough_color is not None:
        trough_color = element.ttk_part_overrides.sbar_trough_color
    elif window.ttk_part_overrides.sbar_trough_color is not None:
        trough_color = window.ttk_part_overrides.sbar_trough_color
    elif ttk_part_overrides_from_options.sbar_trough_color is not None:
        trough_color = ttk_part_overrides_from_options.sbar_trough_color
    else:
        trough_color = element.scroll_trough_color
    # Relief
    if element.ttk_part_overrides.sbar_relief is not None:
        scroll_relief = element.ttk_part_overrides.sbar_relief
    elif window.ttk_part_overrides.sbar_relief is not None:
        scroll_relief = window.ttk_part_overrides.sbar_relief
    elif ttk_part_overrides_from_options.sbar_relief is not None:
        scroll_relief = ttk_part_overrides_from_options.sbar_relief
    else:
        scroll_relief = element.scroll_relief
    # Frame Color
    if element.ttk_part_overrides.sbar_frame_color is not None:
        frame_color = element.ttk_part_overrides.sbar_frame_color
    elif window.ttk_part_overrides.sbar_frame_color is not None:
        frame_color = window.ttk_part_overrides.sbar_frame_color
    elif ttk_part_overrides_from_options.sbar_frame_color is not None:
        frame_color = ttk_part_overrides_from_options.sbar_frame_color
    else:
        frame_color = element.scroll_frame_color
    # Background Color
    if element.ttk_part_overrides.sbar_background_color is not None:
        background_color = element.ttk_part_overrides.sbar_background_color
    elif window.ttk_part_overrides.sbar_background_color is not None:
        background_color = window.ttk_part_overrides.sbar_background_color
    elif ttk_part_overrides_from_options.sbar_background_color is not None:
        background_color = ttk_part_overrides_from_options.sbar_background_color
    else:
        background_color = element.scroll_background_color
    # Arrow Color
    if element.ttk_part_overrides.sbar_arrow_color is not None:
        arrow_color = element.ttk_part_overrides.sbar_arrow_color
    elif window.ttk_part_overrides.sbar_arrow_color is not None:
        arrow_color = window.ttk_part_overrides.sbar_arrow_color
    elif ttk_part_overrides_from_options.sbar_arrow_color is not None:
        arrow_color = ttk_part_overrides_from_options.sbar_arrow_color
    else:
        arrow_color = element.scroll_arrow_color
    # Arrow Width
    if element.ttk_part_overrides.sbar_arrow_width is not None:
        arrow_width = element.ttk_part_overrides.sbar_arrow_width
    elif window.ttk_part_overrides.sbar_arrow_width is not None:
        arrow_width = window.ttk_part_overrides.sbar_arrow_width
    elif ttk_part_overrides_from_options.sbar_arrow_width is not None:
        arrow_width = ttk_part_overrides_from_options.sbar_arrow_width
    else:
        arrow_width = element.scroll_arrow_width
    # Scroll Width
    if element.ttk_part_overrides.sbar_width is not None:
        scroll_width = element.ttk_part_overrides.sbar_width
    elif window.ttk_part_overrides.sbar_width is not None:
        scroll_width = window.ttk_part_overrides.sbar_width
    elif ttk_part_overrides_from_options.sbar_width is not None:
        scroll_width = ttk_part_overrides_from_options.sbar_width
    else:
        scroll_width = element.scroll_width

    if trough_color not in (None, COLOR_SYSTEM_DEFAULT):
        style.configure(style_name, troughcolor=trough_color)

    if frame_color not in (None, COLOR_SYSTEM_DEFAULT):
        style.configure(style_name, framecolor=frame_color)
    if frame_color not in (None, COLOR_SYSTEM_DEFAULT):
        style.configure(style_name, bordercolor=frame_color)

    if (background_color not in (None, COLOR_SYSTEM_DEFAULT)) and \
        (arrow_color not in (None, COLOR_SYSTEM_DEFAULT)):
        style.map(style_name, background=[("selected", background_color), ('active', arrow_color), ('background', background_color), ('!focus', background_color)])
    if (background_color not in (None, COLOR_SYSTEM_DEFAULT)) and \
        (arrow_color not in (None, COLOR_SYSTEM_DEFAULT)):
        style.map(style_name, arrowcolor=[("selected", arrow_color), ('active', background_color), ('background', background_color),('!focus', arrow_color)])

    if scroll_width not in (None, COLOR_SYSTEM_DEFAULT):
        style.configure(style_name, width=scroll_width)
    if arrow_width not in (None, COLOR_SYSTEM_DEFAULT):
        style.configure(style_name, arrowsize=arrow_width)

    if scroll_relief not in (None, COLOR_SYSTEM_DEFAULT):
        style.configure(style_name, relief=scroll_relief)


# @_timeit
def PackFormIntoFrame(form, containing_frame, toplevel_form):
    """
    :param form:             a window class
    :type form:              (Window)
    :param containing_frame: ???
    :type containing_frame:  ???
    :param toplevel_form:    ???
    :type toplevel_form:     (Window)
    """
    # Old bindings
    def yscroll_old(event):
        try:
            if event.num == 5 or event.delta < 0:
                VarHolder.canvas_holder.yview_scroll(1, "unit")
            elif event.num == 4 or event.delta > 0:
                VarHolder.canvas_holder.yview_scroll(-1, "unit")
        except:
            pass

    def xscroll_old(event):
        try:
            if event.num == 5 or event.delta < 0:
                VarHolder.canvas_holder.xview_scroll(1, "unit")
            elif event.num == 4 or event.delta > 0:
                VarHolder.canvas_holder.xview_scroll(-1, "unit")
        except:
            pass

    def testMouseHook2(em):
        combo = em.TKCombo
        combo.unbind_class("TCombobox", "<MouseWheel>")
        combo.unbind_class("TCombobox", "<ButtonPress-4>")
        combo.unbind_class("TCombobox", "<ButtonPress-5>")
        containing_frame.unbind_all('<4>')
        containing_frame.unbind_all('<5>')
        containing_frame.unbind_all("<MouseWheel>")
        containing_frame.unbind_all("<Shift-MouseWheel>")

    def testMouseUnhook2(em):
        containing_frame.bind_all('<4>', yscroll_old, add="+")
        containing_frame.bind_all('<5>', yscroll_old, add="+")
        containing_frame.bind_all("<MouseWheel>", yscroll_old, add="+")
        containing_frame.bind_all("<Shift-MouseWheel>", xscroll_old, add="+")

    def testMouseHook(em):
        containing_frame.unbind_all('<4>')
        containing_frame.unbind_all('<5>')
        containing_frame.unbind_all("<MouseWheel>")
        containing_frame.unbind_all("<Shift-MouseWheel>")

    def testMouseUnhook(em):
        containing_frame.bind_all('<4>', yscroll_old, add="+")
        containing_frame.bind_all('<5>', yscroll_old, add="+")
        containing_frame.bind_all("<MouseWheel>", yscroll_old, add="+")
        containing_frame.bind_all("<Shift-MouseWheel>", xscroll_old, add="+")

    def _char_width_in_pixels(font):
        return tkinter.font.Font(font=font).measure('A')  # single character width

    def _char_height_in_pixels(font):
        return tkinter.font.Font(font=font).metrics('linespace')

    def _string_width_in_pixels(font, string):
        return tkinter.font.Font(font=font).measure(string)  # single character width

    def _add_grab(element):
        try:
            if form.Grab is True or element.Grab is True:
                # if something already about to the button, then don't do the grab stuff
                if '<Button-1>' not in element.Widget.bind():
                    element.Widget.bind("<ButtonPress-1>", toplevel_form._StartMoveGrabAnywhere)
                    element.Widget.bind("<ButtonRelease-1>", toplevel_form._StopMove)
                    element.Widget.bind("<B1-Motion>", toplevel_form._OnMotionGrabAnywhere)
                element.ParentRowFrame.bind("<ButtonPress-1>", toplevel_form._StartMoveGrabAnywhere)
                element.ParentRowFrame.bind("<ButtonRelease-1>", toplevel_form._StopMove)
                element.ParentRowFrame.bind("<B1-Motion>", toplevel_form._OnMotionGrabAnywhere)
                if element.Type == ELEM_TYPE_COLUMN:
                    element.TKColFrame.canvas.bind("<ButtonPress-1>", toplevel_form._StartMoveGrabAnywhere)
                    element.TKColFrame.canvas.bind("<ButtonRelease-1>", toplevel_form._StopMove)
                    element.TKColFrame.canvas.bind("<B1-Motion>", toplevel_form._OnMotionGrabAnywhere)
        except Exception as e:
            pass

    def _add_right_click_menu_and_grab(element):
        if element.RightClickMenu == MENU_RIGHT_CLICK_DISABLED:
            return
        if element.Type == ELEM_TYPE_TAB_GROUP:  # unless everything disabled, then need to always set a right click menu for tabgroups
            if toplevel_form.RightClickMenu == MENU_RIGHT_CLICK_DISABLED:
                return
            menu = _MENU_RIGHT_CLICK_TABGROUP_DEFAULT
        else:
            menu = element.RightClickMenu or form.RightClickMenu or toplevel_form.RightClickMenu

        if menu:
            top_menu = tk.Menu(toplevel_form.TKroot, tearoff=toplevel_form.right_click_menu_tearoff, tearoffcommand=element._tearoff_menu_callback)

            if toplevel_form.right_click_menu_background_color not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(bg=toplevel_form.right_click_menu_background_color)
            if toplevel_form.right_click_menu_text_color not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(fg=toplevel_form.right_click_menu_text_color)
            if toplevel_form.right_click_menu_disabled_text_color not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(disabledforeground=toplevel_form.right_click_menu_disabled_text_color)
            if toplevel_form.right_click_menu_font is not None:
                top_menu.config(font=toplevel_form.right_click_menu_font)

            if toplevel_form.right_click_menu_selected_colors[0] not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(activeforeground=toplevel_form.right_click_menu_selected_colors[0])
            if toplevel_form.right_click_menu_selected_colors[1] not in (COLOR_SYSTEM_DEFAULT, None):
                top_menu.config(activebackground=toplevel_form.right_click_menu_selected_colors[1])
            AddMenuItem(top_menu, menu[1], element, right_click_menu=True)
            element.TKRightClickMenu = top_menu
            if toplevel_form.RightClickMenu:  # if the top level has a right click menu, then setup a callback for the Window itself
                if toplevel_form.TKRightClickMenu is None:
                    toplevel_form.TKRightClickMenu = top_menu
                    if (running_mac()):
                        toplevel_form.TKroot.bind('<ButtonRelease-2>', toplevel_form._RightClickMenuCallback)
                    else:
                        toplevel_form.TKroot.bind('<ButtonRelease-3>', toplevel_form._RightClickMenuCallback)
            if (running_mac()):
                element.Widget.bind('<ButtonRelease-2>', element._RightClickMenuCallback)
            else:
                element.Widget.bind('<ButtonRelease-3>', element._RightClickMenuCallback)
                try:
                    if element.Type == ELEM_TYPE_COLUMN:
                        element.TKColFrame.canvas.bind('<ButtonRelease-3>', element._RightClickMenuCallback)
                except:
                    pass
        _add_grab(element)

    def _add_expansion(element, row_should_expand, row_fill_direction):
        expand = True
        if element.expand_x and element.expand_y:
            fill = tk.BOTH
            row_fill_direction = tk.BOTH
            row_should_expand = True
        elif element.expand_x:
            fill = tk.X
            row_fill_direction = tk.X if row_fill_direction == tk.NONE else tk.BOTH if row_fill_direction == tk.Y else tk.X
        elif element.expand_y:
            fill = tk.Y
            row_fill_direction = tk.Y if row_fill_direction == tk.NONE else tk.BOTH if row_fill_direction == tk.X else tk.Y
            row_should_expand = True
        else:
            fill = tk.NONE
            expand = False
        return expand, fill, row_should_expand, row_fill_direction

    #tclversion_detailed = tkinter.Tcl().eval('info patchlevel')

    # --------------------------------------------------------------------------- #
    # ****************  Use FlexForm to build the tkinter window ********** ----- #
    # Building is done row by row.                                                #
    # WARNING - You can't use print in this function. If the user has rerouted   #
    # stdout then there will be an error saying the window isn't finalized        #
    # --------------------------------------------------------------------------- #
    ######################### LOOP THROUGH ROWS #########################
    # *********** -------  Loop through ROWS  ------- ***********#
    for row_num, flex_row in enumerate(form.Rows):
        ######################### LOOP THROUGH ELEMENTS ON ROW #########################
        # *********** -------  Loop through ELEMENTS  ------- ***********#
        # *********** Make TK Row                             ***********#
        tk_row_frame = tk.Frame(containing_frame)
        row_should_expand = False
        row_fill_direction = tk.NONE

        if form.ElementJustification is not None:
            row_justify = form.ElementJustification
        else:
            row_justify = 'l'

        for col_num, element in enumerate(flex_row):
            element.ParentRowFrame = tk_row_frame
            element.element_frame = None  # for elements that have a scrollbar too
            element.ParentForm = toplevel_form  # save the button's parent form object
            if toplevel_form.Font and (element.Font == DEFAULT_FONT or element.Font is None):
                font = toplevel_form.Font
            elif element.Font is not None:
                font = element.Font
            else:
                font = DEFAULT_FONT
            # -------  Determine Auto-Size setting on a cascading basis ------- #
            if element.AutoSizeText is not None:  # if element overide
                auto_size_text = element.AutoSizeText
            elif toplevel_form.AutoSizeText is not None:  # if form override
                auto_size_text = toplevel_form.AutoSizeText
            else:
                auto_size_text = DEFAULT_AUTOSIZE_TEXT
            element_type = element.Type
            # Set foreground color
            text_color = element.TextColor
            elementpad = element.Pad if element.Pad is not None else toplevel_form.ElementPadding
            # element.pad_used = elementpad  # store the value used back into the element
            # Determine Element size
            element_size = element.Size
            if (element_size == (None, None) and element_type not in (
                    ELEM_TYPE_BUTTON, ELEM_TYPE_BUTTONMENU)):  # user did not specify a size
                element_size = toplevel_form.DefaultElementSize
            elif (element_size == (None, None) and element_type in (ELEM_TYPE_BUTTON, ELEM_TYPE_BUTTONMENU)):
                element_size = toplevel_form.DefaultButtonElementSize
            else:
                auto_size_text = False  # if user has specified a size then it shouldn't autosize

            border_depth = toplevel_form.BorderDepth if toplevel_form.BorderDepth is not None else DEFAULT_BORDER_WIDTH
            try:
                if element.BorderWidth is not None:
                    border_depth = element.BorderWidth
            except:
                pass

            # -------------------------  COLUMN placement element  ------------------------- #
            if element_type == ELEM_TYPE_COLUMN:
                element = element  # type: Column
                # ----------------------- SCROLLABLE Column ----------------------
                if element.Scrollable:
                    element.Widget = element.TKColFrame = TkScrollableFrame(tk_row_frame, element.VerticalScrollOnly, element, toplevel_form)  # do not use yet!  not working
                    PackFormIntoFrame(element, element.TKColFrame.TKFrame, toplevel_form)
                    element.TKColFrame.TKFrame.update()
                    if element.Size == (None, None):  # if no size specified, use column width x column height/2
                        element.TKColFrame.canvas.config(width=element.TKColFrame.TKFrame.winfo_reqwidth() // element.size_subsample_width,
                                                         height=element.TKColFrame.TKFrame.winfo_reqheight() // element.size_subsample_height)
                    else:
                        element.TKColFrame.canvas.config(width=element.TKColFrame.TKFrame.winfo_reqwidth() // element.size_subsample_width,
                                                         height=element.TKColFrame.TKFrame.winfo_reqheight() // element.size_subsample_height)
                        if None not in (element.Size[0], element.Size[1]):
                            element.TKColFrame.canvas.config(width=element.Size[0], height=element.Size[1])
                        elif element.Size[1] is not None:
                            element.TKColFrame.canvas.config(height=element.Size[1])
                        elif element.Size[0] is not None:
                            element.TKColFrame.canvas.config(width=element.Size[0])
                    if not element.BackgroundColor in (None, COLOR_SYSTEM_DEFAULT):
                        element.TKColFrame.canvas.config(background=element.BackgroundColor)
                        element.TKColFrame.TKFrame.config(background=element.BackgroundColor, borderwidth=0, highlightthickness=0)
                        element.TKColFrame.config(background=element.BackgroundColor, borderwidth=0,
                                                  highlightthickness=0)
                # ----------------------- PLAIN Column ----------------------
                else:
                    if element.Size != (None, None):
                        element.Widget = element.TKColFrame = TkFixedFrame(tk_row_frame)
                        PackFormIntoFrame(element, element.TKColFrame.TKFrame, toplevel_form)
                        element.TKColFrame.TKFrame.update()
                        if None not in (element.Size[0], element.Size[1]):
                            element.TKColFrame.canvas.config(width=element.Size[0], height=element.Size[1])
                        elif element.Size[1] is not None:
                            element.TKColFrame.canvas.config(height=element.Size[1])
                        elif element.Size[0] is not None:
                            element.TKColFrame.canvas.config(width=element.Size[0])
                        if not element.BackgroundColor in (None, COLOR_SYSTEM_DEFAULT):
                            element.TKColFrame.canvas.config(background=element.BackgroundColor)
                            element.TKColFrame.TKFrame.config(background=element.BackgroundColor, borderwidth=0, highlightthickness=0)
                    else:
                        element.Widget = element.TKColFrame = tk.Frame(tk_row_frame)
                        PackFormIntoFrame(element, element.TKColFrame, toplevel_form)
                        if element.BackgroundColor not in (None, COLOR_SYSTEM_DEFAULT):
                            element.TKColFrame.config(background=element.BackgroundColor, borderwidth=0, highlightthickness=0)

                if element.Justification is None:
                    pass
                elif element.Justification.lower().startswith('l'):
                    row_justify = 'l'
                elif element.Justification.lower().startswith('c'):
                    row_justify = 'c'
                elif element.Justification.lower().startswith('r'):
                    row_justify = 'r'

                # anchor=tk.NW
                # side = tk.LEFT
                # row_justify = element.Justification
                # element.Widget = element.TKColFrame

                expand = True
                if element.expand_x and element.expand_y:
                    fill = tk.BOTH
                    row_fill_direction = tk.BOTH
                    row_should_expand = True
                elif element.expand_x:
                    fill = tk.X
                    row_fill_direction = tk.X
                elif element.expand_y:
                    fill = tk.Y
                    row_fill_direction = tk.Y
                    row_should_expand = True
                else:
                    fill = tk.NONE
                    expand = False

                if element.VerticalAlignment is not None:
                    anchor = tk.CENTER  # Default to center if a bad choice is made

                    if element.VerticalAlignment.lower().startswith('t'):
                        anchor = tk.N
                    if element.VerticalAlignment.lower().startswith('c'):
                        anchor = tk.CENTER
                    if element.VerticalAlignment.lower().startswith('b'):
                        anchor = tk.S
                    element.TKColFrame.pack(side=tk.LEFT, anchor=anchor, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                else:
                    element.TKColFrame.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)

                # element.TKColFrame.pack(side=side, padx=elementpad[0], pady=elementpad[1], expand=True, fill='both')
                if element.visible is False:
                    element._pack_forget_save_settings()
                    # element.TKColFrame.pack_forget()

                _add_right_click_menu_and_grab(element)
                # if element.Grab:
                #     element._grab_anywhere_on()
                # row_should_expand = True
            # -------------------------  Pane placement element  ------------------------- #
            if element_type == ELEM_TYPE_PANE:
                bd = element.BorderDepth if element.BorderDepth is not None else border_depth
                element.PanedWindow = element.Widget = tk.PanedWindow(
                    tk_row_frame,
                    orient=tk.VERTICAL if element.Orientation.startswith('v') else tk.HORIZONTAL,
                    borderwidth=bd,
                    bd=bd,
                )
                if element.Relief is not None:
                    element.PanedWindow.configure(relief=element.Relief)
                element.PanedWindow.configure(handlesize=element.HandleSize)
                if element.ShowHandle:
                    element.PanedWindow.config(showhandle=True)
                if element.Size != (None, None):
                    element.PanedWindow.config(width=element.Size[0], height=element.Size[1])
                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    element.PanedWindow.configure(background=element.BackgroundColor)
                for pane in element.PaneList:
                    pane.Widget = pane.TKColFrame = tk.Frame(element.PanedWindow)
                    pane.ParentPanedWindow = element.PanedWindow
                    PackFormIntoFrame(pane, pane.TKColFrame, toplevel_form)
                    if pane.visible:
                        element.PanedWindow.add(pane.TKColFrame)
                    if pane.BackgroundColor != COLOR_SYSTEM_DEFAULT and pane.BackgroundColor is not None:
                        pane.TKColFrame.configure(
                            background=pane.BackgroundColor,
                            highlightbackground=pane.BackgroundColor,
                            highlightcolor=pane.BackgroundColor
                        )
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element.PanedWindow.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)

                if element.visible is False:
                    element._pack_forget_save_settings()

            # -------------------------  TEXT placement element  ------------------------- #
            elif element_type == ELEM_TYPE_TEXT:
                # auto_size_text = element.AutoSizeText
                element = element  # type: Text
                display_text = element.DisplayText  # text to display
                if auto_size_text is False:
                    width, height = element_size
                else:
                    width, height = None, None

                # ---===--- LABEL widget create and place --- #
                element = element  # type: Text
                bd = element.BorderWidth if element.BorderWidth is not None else border_depth
                stringvar = tk.StringVar()
                element.TKStringVar = stringvar
                stringvar.set(str(display_text))
                if auto_size_text:
                    width = 0
                if element.Justification is not None:
                    justification = element.Justification
                elif toplevel_form.TextJustification is not None:
                    justification = toplevel_form.TextJustification
                else:
                    justification = DEFAULT_TEXT_JUSTIFICATION
                justify = tk.LEFT if justification.startswith('l') else tk.CENTER if justification.startswith('c') else tk.RIGHT
                anchor = tk.NW if justification.startswith('l') else tk.N if justification.startswith('c') else tk.NE
                tktext_label = element.Widget = tk.Label(tk_row_frame, textvariable=stringvar, width=width,
                                                         height=height, justify=justify, bd=bd, font=font)
                # Set wrap-length for text (in PIXELS) == PAIN IN THE ASS
                wraplen = tktext_label.winfo_reqwidth()  # width of widget in Pixels
                if auto_size_text or (not auto_size_text and height == 1):  # if just 1 line high, ensure no wrap happens
                    wraplen = 0
                tktext_label.configure(anchor=anchor, wraplen=wraplen)  # set wrap to width of widget
                if element.Relief is not None:
                    tktext_label.configure(relief=element.Relief)
                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    tktext_label.configure(background=element.BackgroundColor)
                if element.TextColor != COLOR_SYSTEM_DEFAULT and element.TextColor is not None:
                    tktext_label.configure(fg=element.TextColor)
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                tktext_label.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings()
                    # tktext_label.pack_forget()
                element.TKText = tktext_label
                if element.ClickSubmits:
                    tktext_label.bind('<Button-1>', element._TextClickedHandler)
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKText, text=element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)
                if element.Grab:
                    element._grab_anywhere_on()
                element.set_cursor('hand1')
            # -------------------------  BUTTON placement element non-ttk version  ------------------------- #
            elif (element_type == ELEM_TYPE_BUTTON and element.UseTtkButtons is False) or \
                    (element_type == ELEM_TYPE_BUTTON and element.UseTtkButtons is not True and toplevel_form.UseTtkButtons is not True):
                element = element  # type: Button
                element.UseTtkButtons = False  # indicate that ttk button was not used
                stringvar = tk.StringVar()
                element.TKStringVar = stringvar
                element.Location = (row_num, col_num)
                btext = element.ButtonText
                btype = element.BType
                if element.AutoSizeButton is not None:
                    auto_size = element.AutoSizeButton
                else:
                    auto_size = toplevel_form.AutoSizeButtons
                if auto_size is False or element.Size[0] is not None:
                    width, height = element_size
                else:
                    width = 0
                    height = toplevel_form.DefaultButtonElementSize[1]
                if element.ButtonColor != (None, None) and element.ButtonColor != DEFAULT_BUTTON_COLOR:
                    bc = element.ButtonColor
                elif toplevel_form.ButtonColor != (None, None) and toplevel_form.ButtonColor != DEFAULT_BUTTON_COLOR:
                    bc = toplevel_form.ButtonColor
                else:
                    bc = DEFAULT_BUTTON_COLOR

                bd = element.BorderWidth
                pos = -1
                if DEFAULT_USE_BUTTON_SHORTCUTS is True:
                    pos = btext.find(MENU_SHORTCUT_CHARACTER)
                    if pos != -1:
                        if pos < len(MENU_SHORTCUT_CHARACTER) or btext[pos - len(MENU_SHORTCUT_CHARACTER)] != "\\":
                            btext = btext[:pos] + btext[pos + len(MENU_SHORTCUT_CHARACTER):]
                        else:
                            btext = btext.replace('\\'+MENU_SHORTCUT_CHARACTER, MENU_SHORTCUT_CHARACTER)
                            pos = -1
                tkbutton = element.Widget = tk.Button(tk_row_frame, text=btext, width=width, height=height, justify=tk.CENTER, bd=bd, font=font)
                if pos != -1:
                    tkbutton.config(underline=pos)
                try:
                    if btype != BUTTON_TYPE_REALTIME:
                        tkbutton.config( command=element.ButtonCallBack)

                    else:
                        tkbutton.bind('<ButtonRelease-1>', element.ButtonReleaseCallBack)
                        tkbutton.bind('<ButtonPress-1>', element.ButtonPressCallBack)
                    if bc != (None, None) and COLOR_SYSTEM_DEFAULT not in bc:
                        tkbutton.config(foreground=bc[0], background=bc[1])
                    else:
                        if bc[0] != COLOR_SYSTEM_DEFAULT:
                            tkbutton.config(foreground=bc[0])
                        if bc[1] != COLOR_SYSTEM_DEFAULT:
                            tkbutton.config(background=bc[1])
                except Exception as e:
                    _error_popup_with_traceback(
                        'Button has a problem....',
                        'The traceback information will not show the line in your layout with the problem, but it does tell you which window.',
                        'Error {}'.format(e),
                        "Parent Window's Title: {}".format(toplevel_form.Title)
                    )

                if bd == 0 and not running_mac():
                    tkbutton.config(relief=tk.FLAT)

                element.TKButton = tkbutton  # not used yet but save the TK button in case
                if elementpad[0] == 0 or elementpad[1] == 0:
                    tkbutton.config(highlightthickness=0)

                ## -------------- TK Button With Image -------------- ##
                if element.ImageFilename:  # if button has an image on it
                    tkbutton.config(highlightthickness=0)
                    try:
                        photo = tk.PhotoImage(file=element.ImageFilename)
                        if element.ImageSubsample:
                            photo = photo.subsample(element.ImageSubsample)
                        if element.zoom:
                            photo = photo.zoom(element.zoom)
                        if element.ImageSize != (None, None):
                            width, height = element.ImageSize
                        else:
                            width, height = photo.width(), photo.height()
                    except Exception as e:
                        _error_popup_with_traceback(
                            'Button Element error {}'.format(e), 'Image filename: {}'.format(element.ImageFilename),
                            'NOTE: file format must be PNG or GIF!',
                            'Button element key: {}'.format(element.Key),
                            "Parent Window's Title: {}".format(toplevel_form.Title)
                        )
                    tkbutton.config(image=photo, compound=tk.CENTER, width=width, height=height)
                    tkbutton.image = photo
                if element.ImageData:  # if button has an image on it
                    tkbutton.config(highlightthickness=0)
                    try:
                        photo = tk.PhotoImage(data=element.ImageData)
                        if element.ImageSubsample:
                            photo = photo.subsample(element.ImageSubsample)
                        if element.zoom:
                            photo = photo.zoom(element.zoom)
                        if element.ImageSize != (None, None):
                            width, height = element.ImageSize
                        else:
                            width, height = photo.width(), photo.height()
                        tkbutton.config(image=photo, compound=tk.CENTER, width=width, height=height)
                        tkbutton.image = photo
                    except Exception as e:
                        _error_popup_with_traceback(
                            'Button Element error {}'.format(e),
                            'Problem using BASE64 Image data Image Susample',
                            'Buton element key: {}'.format(element.Key),
                            "Parent Window's Title: {}".format(toplevel_form.Title)
                        )
                if width != 0:
                    wraplen = width * _char_width_in_pixels(font)
                    tkbutton.configure(wraplength=wraplen)  # set wrap to width of widget
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)

                tkbutton.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings()
                    # tkbutton.pack_forget()
                if element.BindReturnKey:
                    element.TKButton.bind('<Return>', element._ReturnKeyHandler)
                if element.Focus is True or (toplevel_form.UseDefaultFocus and not toplevel_form.FocusSet):
                    toplevel_form.FocusSet = True
                    element.TKButton.bind('<Return>', element._ReturnKeyHandler)
                    element.TKButton.focus_set()
                    toplevel_form.TKroot.focus_force()
                if element.Disabled is True:
                    element.TKButton['state'] = 'disabled'
                if element.DisabledButtonColor != (None, None) and element.DisabledButtonColor != (COLOR_SYSTEM_DEFAULT, COLOR_SYSTEM_DEFAULT):
                    if element.DisabledButtonColor[0] not in (None, COLOR_SYSTEM_DEFAULT):
                        element.TKButton['disabledforeground'] = element.DisabledButtonColor[0]
                if element.MouseOverColors[1] not in (COLOR_SYSTEM_DEFAULT, None):
                    tkbutton.config(activebackground=element.MouseOverColors[1])
                if element.MouseOverColors[0] not in (COLOR_SYSTEM_DEFAULT, None):
                    tkbutton.config(activeforeground=element.MouseOverColors[0])

                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKButton, text=element.Tooltip,
                                                    timeout=DEFAULT_TOOLTIP_TIME)
                try:
                    if element.HighlightColors[1] != COLOR_SYSTEM_DEFAULT:
                        tkbutton.config(highlightbackground=element.HighlightColors[1])
                    if element.HighlightColors[0] != COLOR_SYSTEM_DEFAULT:
                        tkbutton.config(highlightcolor=element.HighlightColors[0])
                except Exception as e:
                    _error_popup_with_traceback(
                        'Button Element error {}'.format(e),
                         'Button element key: {}'.format(element.Key),
                         'Button text: {}'.format(btext),
                         'Has a bad highlight color {}'.format(element.HighlightColors),
                         "Parent Window's Title: {}".format(toplevel_form.Title)
                    )
                _add_right_click_menu_and_grab(element)

            # -------------------------  BUTTON placement element ttk version ------------------------- #
            elif element_type == ELEM_TYPE_BUTTON:
                element = element  # type: Button
                element.UseTtkButtons = True  # indicate that ttk button was used
                stringvar = tk.StringVar()
                element.TKStringVar = stringvar
                element.Location = (row_num, col_num)
                btext = element.ButtonText
                pos = -1
                if DEFAULT_USE_BUTTON_SHORTCUTS is True:
                    pos = btext.find(MENU_SHORTCUT_CHARACTER)
                    if pos != -1:
                        if pos < len(MENU_SHORTCUT_CHARACTER) or btext[pos - len(MENU_SHORTCUT_CHARACTER)] != "\\":
                            btext = btext[:pos] + btext[pos + len(MENU_SHORTCUT_CHARACTER):]
                        else:
                            btext = btext.replace('\\'+MENU_SHORTCUT_CHARACTER, MENU_SHORTCUT_CHARACTER)
                            pos = -1
                btype = element.BType
                if element.AutoSizeButton is not None:
                    auto_size = element.AutoSizeButton
                else:
                    auto_size = toplevel_form.AutoSizeButtons
                if auto_size is False or element.Size[0] is not None:
                    width, height = element_size
                else:
                    width = 0
                    height = toplevel_form.DefaultButtonElementSize[1]
                if element.ButtonColor != (None, None) and element.ButtonColor != COLOR_SYSTEM_DEFAULT:
                    bc = element.ButtonColor
                elif toplevel_form.ButtonColor != (None, None) and toplevel_form.ButtonColor != COLOR_SYSTEM_DEFAULT:
                    bc = toplevel_form.ButtonColor
                else:
                    bc = DEFAULT_BUTTON_COLOR
                bd = element.BorderWidth
                tkbutton = element.Widget = ttk.Button(tk_row_frame, text=btext, width=width)
                if pos != -1:
                    tkbutton.config(underline=pos)
                if btype != BUTTON_TYPE_REALTIME:
                    tkbutton.config(command=element.ButtonCallBack)
                else:
                    tkbutton.bind('<ButtonRelease-1>', element.ButtonReleaseCallBack)
                    tkbutton.bind('<ButtonPress-1>', element.ButtonPressCallBack)
                style_name = _make_ttk_style_name('.TButton', element, primary_style=True)
                button_style = ttk.Style()
                element.ttk_style = button_style
                _change_ttk_theme(button_style, toplevel_form.TtkTheme)
                button_style.configure(style_name, font=font)

                if bc != (None, None) and COLOR_SYSTEM_DEFAULT not in bc:
                    button_style.configure(style_name, foreground=bc[0], background=bc[1])
                elif bc[0] != COLOR_SYSTEM_DEFAULT:
                    button_style.configure(style_name, foreground=bc[0])
                elif bc[1] != COLOR_SYSTEM_DEFAULT:
                    button_style.configure(style_name, background=bc[1])

                if bd == 0 and not running_mac():
                    button_style.configure(style_name, relief=tk.FLAT)
                    button_style.configure(style_name, borderwidth=0)
                else:
                    button_style.configure(style_name, borderwidth=bd)
                button_style.configure(style_name, justify=tk.CENTER)

                if element.MouseOverColors[1] not in (COLOR_SYSTEM_DEFAULT, None):
                    button_style.map(style_name, background=[('active', element.MouseOverColors[1])])
                if element.MouseOverColors[0] not in (COLOR_SYSTEM_DEFAULT, None):
                    button_style.map(style_name, foreground=[('active', element.MouseOverColors[0])])

                if element.DisabledButtonColor[0] not in (COLOR_SYSTEM_DEFAULT, None):
                    button_style.map(style_name, foreground=[('disabled', element.DisabledButtonColor[0])])
                if element.DisabledButtonColor[1] not in (COLOR_SYSTEM_DEFAULT, None):
                    button_style.map(style_name, background=[('disabled', element.DisabledButtonColor[1])])

                if height > 1:
                    button_style.configure(style_name, padding=height * _char_height_in_pixels(font))  # should this be height instead?
                if width != 0:
                    wraplen = width * _char_width_in_pixels(font) # width of widget in Pixels
                    button_style.configure(style_name, wraplength=wraplen)  # set wrap to width of widget

                ## -------------- TTK Button With Image -------------- ##
                if element.ImageFilename:
                    button_style.configure(style_name, borderwidth=0)
                    photo = tk.PhotoImage(file=element.ImageFilename)
                    if element.ImageSubsample:
                        photo = photo.subsample(element.ImageSubsample)
                    if element.zoom:
                        photo = photo.zoom(element.zoom)
                    if element.ImageSize != (None, None):
                        width, height = element.ImageSize
                    else:
                        width, height = photo.width(), photo.height()
                    button_style.configure(style_name, image=photo, compound=tk.CENTER, width=width, height=height)
                    tkbutton.image = photo

                if element.ImageData:
                    button_style.configure(style_name, borderwidth=0)
                    photo = tk.PhotoImage(data=element.ImageData)
                    if element.ImageSubsample:
                        photo = photo.subsample(element.ImageSubsample)
                    if element.zoom:
                        photo = photo.zoom(element.zoom)
                    if element.ImageSize != (None, None):
                        width, height = element.ImageSize
                    else:
                        width, height = photo.width(), photo.height()
                    button_style.configure(style_name, image=photo, compound=tk.CENTER, width=width, height=height)
                    # tkbutton.configure(image=photo, compound=tk.CENTER, width=width, height=height)
                    tkbutton.image = photo

                element.TKButton = tkbutton  # not used yet but save the TK button in case
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                tkbutton.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings()
                    # tkbutton.pack_forget()
                if element.BindReturnKey:
                    element.TKButton.bind('<Return>', element._ReturnKeyHandler)
                if element.Focus is True or (toplevel_form.UseDefaultFocus and not toplevel_form.FocusSet):
                    toplevel_form.FocusSet = True
                    element.TKButton.bind('<Return>', element._ReturnKeyHandler)
                    element.TKButton.focus_set()
                    toplevel_form.TKroot.focus_force()
                if element.Disabled is True:
                    element.TKButton['state'] = 'disabled'

                tkbutton.configure(style=style_name)  # IMPORTANT!  Apply the style to the button!
                _add_right_click_menu_and_grab(element)

                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(
                        element.TKButton, text=element.Tooltip,
                        timeout=DEFAULT_TOOLTIP_TIME
                    )
            # -------------------------  BUTTONMENU placement element  ------------------------- #
            elif element_type == ELEM_TYPE_BUTTONMENU:
                element = element  # type: ButtonMenu
                element.Location = (row_num, col_num)
                btext = element.ButtonText
                if element.AutoSizeButton is not None:
                    auto_size = element.AutoSizeButton
                else:
                    auto_size = toplevel_form.AutoSizeButtons
                if auto_size is False or element.Size[0] is not None:
                    width, height = element_size
                else:
                    width = 0
                    height = toplevel_form.DefaultButtonElementSize[1]
                if element.ButtonColor != (None, None) and element.ButtonColor != DEFAULT_BUTTON_COLOR:
                    bc = element.ButtonColor
                elif toplevel_form.ButtonColor != (None, None) and toplevel_form.ButtonColor != DEFAULT_BUTTON_COLOR:
                    bc = toplevel_form.ButtonColor
                else:
                    bc = DEFAULT_BUTTON_COLOR
                bd = element.BorderWidth
                if element.ItemFont is None:
                    element.ItemFont = font
                tkbutton = element.Widget = tk.Menubutton(
                    tk_row_frame, text=btext, width=width, height=height, justify=tk.LEFT, bd=bd, font=font
                )
                element.TKButtonMenu = tkbutton
                if bc != (None, None) and bc != COLOR_SYSTEM_DEFAULT and bc[1] != COLOR_SYSTEM_DEFAULT:
                    tkbutton.config(foreground=bc[0], background=bc[1])
                    tkbutton.config(activebackground=bc[0])
                    tkbutton.config(activeforeground=bc[1])
                elif bc[0] != COLOR_SYSTEM_DEFAULT:
                    tkbutton.config(foreground=bc[0])
                    tkbutton.config(activebackground=bc[0])
                if bd == 0 and not running_mac():
                    tkbutton.config(relief=RELIEF_FLAT)
                elif bd != 0:
                    tkbutton.config(relief=RELIEF_RAISED)

                element.TKButton = tkbutton  # not used yet but save the TK button in case
                wraplen = tkbutton.winfo_reqwidth()  # width of widget in Pixels
                if element.ImageFilename:  # if button has an image on it
                    photo = tk.PhotoImage(file=element.ImageFilename)
                    if element.ImageSubsample:
                        photo = photo.subsample(element.ImageSubsample)
                    if element.zoom:
                        photo = photo.zoom(element.zoom)
                    if element.ImageSize != (None, None):
                        width, height = element.ImageSize
                    else:
                        width, height = photo.width(), photo.height()
                    tkbutton.config(image=photo, compound=tk.CENTER, width=width, height=height)
                    tkbutton.image = photo
                if element.ImageData:  # if button has an image on it
                    photo = tk.PhotoImage(data=element.ImageData)
                    if element.ImageSubsample:
                        photo = photo.subsample(element.ImageSubsample)
                    if element.zoom:
                        photo = photo.zoom(element.zoom)
                    if element.ImageSize != (None, None):
                        width, height = element.ImageSize
                    else:
                        width, height = photo.width(), photo.height()
                    tkbutton.config(image=photo, compound=tk.CENTER, width=width, height=height)
                    tkbutton.image = photo
                if width != 0:
                    tkbutton.configure(wraplength=wraplen + 10)  # set wrap to width of widget
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                tkbutton.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)

                menu_def = element.MenuDefinition

                element.TKMenu = top_menu = tk.Menu(tkbutton, tearoff=element.Tearoff, font=element.ItemFont, tearoffcommand=element._tearoff_menu_callback)

                if element.BackgroundColor not in (COLOR_SYSTEM_DEFAULT, None):
                    top_menu.config(bg=element.BackgroundColor)
                    top_menu.config(activeforeground=element.BackgroundColor)
                if element.TextColor not in (COLOR_SYSTEM_DEFAULT, None):
                    top_menu.config(fg=element.TextColor)
                    top_menu.config(activebackground=element.TextColor)
                if element.DisabledTextColor not in (COLOR_SYSTEM_DEFAULT, None):
                    top_menu.config(disabledforeground=element.DisabledTextColor)
                if element.ItemFont is not None:
                    top_menu.config(font=element.ItemFont)

                AddMenuItem(top_menu, menu_def[1], element)
                if elementpad[0] == 0 or elementpad[1] == 0:
                    tkbutton.config(highlightthickness=0)
                tkbutton.configure(menu=top_menu)
                element.TKMenu = top_menu
                if element.visible is False:
                    element._pack_forget_save_settings()
                    # tkbutton.pack_forget()
                if element.Disabled == True:
                    element.TKButton['state'] = 'disabled'
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKButton, text=element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)

            # -------------------------  INPUT placement element  ------------------------- #
            elif element_type == ELEM_TYPE_INPUT_TEXT:
                element = element  # type: InputText
                default_text = element.DefaultText
                element.TKStringVar = tk.StringVar()
                element.TKStringVar.set(default_text)
                show = element.PasswordCharacter if element.PasswordCharacter else ""
                bd = border_depth
                if element.Justification is not None:
                    justification = element.Justification
                else:
                    justification = DEFAULT_TEXT_JUSTIFICATION
                justify = tk.LEFT if justification.startswith('l') else tk.CENTER if justification.startswith('c') else tk.RIGHT
                # anchor = tk.NW if justification == 'left' else tk.N if justification == 'center' else tk.NE
                element.TKEntry = element.Widget = tk.Entry(
                    tk_row_frame, width=element_size[0],
                    textvariable=element.TKStringVar, bd=bd,
                    font=font, show=show, justify=justify
                )
                if element.ChangeSubmits:
                    element.TKEntry.bind('<Key>', element._KeyboardHandler)
                element.TKEntry.bind('<Return>', element._ReturnKeyHandler)

                if element.BackgroundColor not in (None, COLOR_SYSTEM_DEFAULT):
                    element.TKEntry.configure(background=element.BackgroundColor, selectforeground=element.BackgroundColor)

                if text_color not in (None, COLOR_SYSTEM_DEFAULT):
                    element.TKEntry.configure(fg=text_color, selectbackground=text_color)
                    element.TKEntry.config(insertbackground=text_color)
                if element.selected_background_color not in (None, COLOR_SYSTEM_DEFAULT):
                    element.TKEntry.configure(selectbackground=element.selected_background_color)
                if element.selected_text_color not in (None, COLOR_SYSTEM_DEFAULT):
                    element.TKEntry.configure(selectforeground=element.selected_text_color)
                if element.disabled_readonly_background_color not in (None, COLOR_SYSTEM_DEFAULT):
                    element.TKEntry.config(readonlybackground=element.disabled_readonly_background_color)
                if element.disabled_readonly_text_color not in (None, COLOR_SYSTEM_DEFAULT) and element.Disabled:
                    element.TKEntry.config(fg=element.disabled_readonly_text_color)

                element.Widget.config(highlightthickness=0)
                # element.pack_keywords = {'side':tk.LEFT, 'padx':elementpad[0], 'pady':elementpad[1], 'expand':False, 'fill':tk.NONE }
                # element.TKEntry.pack(**element.pack_keywords)
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element.TKEntry.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings()
                    # element.TKEntry.pack_forget()
                if element.Focus is True or (toplevel_form.UseDefaultFocus and not toplevel_form.FocusSet):
                    toplevel_form.FocusSet = True
                    element.TKEntry.focus_set()
                if element.Disabled:
                    element.TKEntry['state'] = 'readonly' if element.UseReadonlyForDisable else 'disabled'
                if element.ReadOnly:
                    element.TKEntry['state'] = 'readonly'

                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKEntry, text=element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)

            # -------------------------  COMBO placement element  ------------------------- #
            elif element_type == ELEM_TYPE_INPUT_COMBO:
                element = element  # type: Combo
                max_line_len = max([len(str(l)) for l in element.Values]) if len(element.Values) else 0
                if auto_size_text is False:
                    width = element_size[0]
                else:
                    width = max_line_len + 1
                element.TKStringVar = tk.StringVar()
                style_name = _make_ttk_style_name('.TCombobox', element, primary_style=True)
                combostyle = ttk.Style()
                element.ttk_style = combostyle
                _change_ttk_theme(combostyle, toplevel_form.TtkTheme)

                # Creates a unique name for each field element(Sure there is a better way to do this)
                # unique_field = _make_ttk_style_name('.TCombobox.field', element)

                # Set individual widget options
                try:
                    if element.TextColor not in (None, COLOR_SYSTEM_DEFAULT):
                        combostyle.configure(style_name, foreground=element.TextColor)
                        combostyle.configure(style_name, selectbackground=element.TextColor)
                        combostyle.configure(style_name, insertcolor=element.TextColor)
                        combostyle.map(style_name, fieldforeground=[('readonly', element.TextColor)])
                    if element.BackgroundColor not in (None, COLOR_SYSTEM_DEFAULT):
                        combostyle.configure(style_name, selectforeground=element.BackgroundColor)
                        combostyle.map(style_name, fieldbackground=[('readonly', element.BackgroundColor)])
                        combostyle.configure(style_name, fieldbackground=element.BackgroundColor)

                    if element.button_arrow_color not in (None, COLOR_SYSTEM_DEFAULT):
                        combostyle.configure(style_name, arrowcolor=element.button_arrow_color)
                    if element.button_background_color not in (None, COLOR_SYSTEM_DEFAULT):
                        combostyle.configure(style_name, background=element.button_background_color)
                    if element.Readonly is True:
                        if element.TextColor not in (None, COLOR_SYSTEM_DEFAULT):
                            combostyle.configure(style_name, selectforeground=element.TextColor)
                        if element.BackgroundColor not in (None, COLOR_SYSTEM_DEFAULT):
                            combostyle.configure(style_name, selectbackground=element.BackgroundColor)
                except Exception as e:
                    _error_popup_with_traceback(
                        'Combo Element error {}'.format(e),
                        'Combo element key: {}'.format(element.Key),
                        'One of your colors is bad. Check the text, background, button background and button arrow colors',
                        "Parent Window's Title: {}".format(toplevel_form.Title)
                    )
                # Strange code that is needed to set the font for the drop-down list
                element._dropdown_newfont = tkinter.font.Font(font=font)
                tk_row_frame.option_add("*TCombobox*Listbox*Font", element._dropdown_newfont)

                element.TKCombo = element.Widget = ttk.Combobox(tk_row_frame, width=width, textvariable=element.TKStringVar, font=font, style=style_name)

                # make tcl call to deal with colors for the drop-down formatting
                try:
                    if element.BackgroundColor not in (None, COLOR_SYSTEM_DEFAULT) and \
                        element.TextColor not in (None, COLOR_SYSTEM_DEFAULT):
                        element.Widget.tk.eval(
                    '[ttk::combobox::PopdownWindow {}].f.l configure -foreground {} -background {} -selectforeground {} -selectbackground {}'.format(element.Widget, element.TextColor, element.BackgroundColor, element.BackgroundColor, element.TextColor))
                except Exception as e:
                    pass # going to let this one slide

                element.TKCombo.bind("<Enter>", lambda event, em=element: testMouseHook2(em))
                element.TKCombo.bind("<Leave>", lambda event, em=element: testMouseUnhook2(em))

                if toplevel_form.UseDefaultFocus and not toplevel_form.FocusSet:
                    toplevel_form.FocusSet = True
                    element.TKCombo.focus_set()

                if element.Size[1] != 1 and element.Size[1] is not None:
                    element.TKCombo.configure(height=element.Size[1])
                element.TKCombo['values'] = element.Values
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element.TKCombo.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings()
                    # element.TKCombo.pack_forget()
                if element.DefaultValue is not None:
                    element.TKCombo.set(element.DefaultValue)
                if element.ChangeSubmits:
                    element.TKCombo.bind('<<ComboboxSelected>>', element._ComboboxSelectHandler)
                if element.BindReturnKey:
                    element.TKCombo.bind('<Return>', element._ComboboxSelectHandler)
                if element.enable_per_char_events:
                    element.TKCombo.bind('<Key>', element._KeyboardHandler)
                if element.Readonly:
                    element.TKCombo['state'] = 'readonly'
                if element.Disabled is True:  # note overrides readonly if disabled
                    element.TKCombo['state'] = 'disabled'
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKCombo, text=element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)

            # -------------------------  OPTIONMENU placement Element (Like ComboBox but different) element  ------------------------- #
            elif element_type == ELEM_TYPE_INPUT_OPTION_MENU:
                element = element  # type: OptionMenu
                max_line_len = max([len(str(l)) for l in element.Values])
                if auto_size_text is False:
                    width = element_size[0]
                else:
                    width = max_line_len
                element.TKStringVar = tk.StringVar()
                if element.DefaultValue:
                    element.TKStringVar.set(element.DefaultValue)
                element.TKOptionMenu = element.Widget = tk.OptionMenu(tk_row_frame, element.TKStringVar, *element.Values)
                element.TKOptionMenu.config(highlightthickness=0, font=font, width=width)
                element.TKOptionMenu['menu'].config(font=font)
                element.TKOptionMenu.config(borderwidth=border_depth)
                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    element.TKOptionMenu.configure(background=element.BackgroundColor)
                    element.TKOptionMenu['menu'].config(background=element.BackgroundColor)
                if element.TextColor != COLOR_SYSTEM_DEFAULT and element.TextColor is not None:
                    element.TKOptionMenu.configure(fg=element.TextColor)
                    element.TKOptionMenu['menu'].config(fg=element.TextColor)
                if element.ChangeSubmits:
                    element.TKStringVar.trace('w', element._OptionMenuSelectHandler)
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element.TKOptionMenu.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings()
                if element.Disabled == True:
                    element.TKOptionMenu['state'] = 'disabled'
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKOptionMenu, text=element.Tooltip,
                                                    timeout=DEFAULT_TOOLTIP_TIME)
            # -------------------------  LISTBOX placement element  ------------------------- #
            elif element_type == ELEM_TYPE_INPUT_LISTBOX:
                element = element  # type: Listbox
                max_line_len = max([len(str(l)) for l in element.Values]) if len(element.Values) else 0
                if auto_size_text is False:
                    width = element_size[0]
                else:
                    width = max_line_len
                element_frame = tk.Frame(tk_row_frame)
                element.element_frame = element_frame

                justification = tk.LEFT
                if element.justification is not None:
                    if element.justification.startswith('l'):
                        justification = tk.LEFT
                    elif element.justification.startswith('r'):
                        justification = tk.RIGHT
                    elif element.justification.startswith('c'):
                        justification = tk.CENTER

                element.TKStringVar = tk.StringVar()
                element.TKListbox = element.Widget = tk.Listbox(element_frame, height=element_size[1], width=width,
                                                                selectmode=element.SelectMode, font=font, exportselection=False)
                # On OLD versions of tkinter the justify option isn't available
                try:
                    element.Widget.config(justify=justification)
                except:
                    pass

                element.Widget.config(highlightthickness=0)
                for index, item in enumerate(element.Values):
                    element.TKListbox.insert(tk.END, item)
                    if element.DefaultValues is not None and item in element.DefaultValues:
                        element.TKListbox.selection_set(index)
                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    element.TKListbox.configure(background=element.BackgroundColor)
                if element.HighlightBackgroundColor is not None and element.HighlightBackgroundColor != COLOR_SYSTEM_DEFAULT:
                    element.TKListbox.config(selectbackground=element.HighlightBackgroundColor)
                if text_color is not None and text_color != COLOR_SYSTEM_DEFAULT:
                    element.TKListbox.configure(fg=text_color)
                if element.HighlightTextColor is not None and element.HighlightTextColor != COLOR_SYSTEM_DEFAULT:
                    element.TKListbox.config(selectforeground=element.HighlightTextColor)
                if element.ChangeSubmits:
                    element.TKListbox.bind('<<ListboxSelect>>', element._ListboxSelectHandler)

                if not element.NoScrollbar:
                    _make_ttk_scrollbar(element, 'v', toplevel_form)
                    element.Widget.configure(yscrollcommand=element.vsb.set)
                    element.vsb.pack(side=tk.RIGHT, fill='y')

                # Horizontal scrollbar
                if element.HorizontalScroll:
                    _make_ttk_scrollbar(element, 'h', toplevel_form)
                    element.hsb.pack(side=tk.BOTTOM, fill='x')
                    element.Widget.configure(xscrollcommand=element.hsb.set)

                if not element.NoScrollbar or element.HorizontalScroll:
                    element.Widget.bind("<Enter>", lambda event, em=element: testMouseHook(em))
                    element.Widget.bind("<Leave>", lambda event, em=element: testMouseUnhook(em))

                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element_frame.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], fill=fill, expand=expand)
                element.TKListbox.pack(side=tk.LEFT, fill=fill, expand=expand)
                if element.visible is False:
                    element._pack_forget_save_settings(alternate_widget=element_frame)
                    # element_frame.pack_forget()
                if element.BindReturnKey:
                    element.TKListbox.bind('<Return>', element._ListboxSelectHandler)
                    element.TKListbox.bind('<Double-Button-1>', element._ListboxSelectHandler)
                if element.Disabled is True:
                    element.TKListbox['state'] = 'disabled'
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKListbox, text=element.Tooltip,
                                                    timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)
            # -------------------------  MULTILINE placement element  ------------------------- #
            elif element_type == ELEM_TYPE_INPUT_MULTILINE:
                element = element  # type: Multiline
                width, height = element_size
                bd = element.BorderWidth
                element.element_frame = element_frame = tk.Frame(tk_row_frame)

                element.TKText = element.Widget = tk.Text(
                    element_frame, width=width, height=height,  bd=bd, font=font, relief=RELIEF_SUNKEN
                )

                if not element.no_scrollbar:
                    _make_ttk_scrollbar(element, 'v', toplevel_form)

                    element.Widget.configure(yscrollcommand=element.vsb.set)
                    element.vsb.pack(side=tk.RIGHT, fill='y')

                # Horizontal scrollbar
                if element.HorizontalScroll:
                    element.TKText.config(wrap='none')
                    _make_ttk_scrollbar(element, 'h', toplevel_form)
                    element.hsb.pack(side=tk.BOTTOM, fill='x')
                    element.Widget.configure(xscrollcommand=element.hsb.set)
                else:
                    element.TKText.config(wrap='word')

                if element.wrap_lines is True:
                    element.TKText.config(wrap='word')
                elif element.wrap_lines is False:
                    element.TKText.config(wrap='none')

                if not element.no_scrollbar or element.HorizontalScroll:

                    element.TKText.bind("<Enter>", lambda event, em=element: testMouseHook(em))
                    element.TKText.bind("<Leave>", lambda event, em=element: testMouseUnhook(em))

                if element.DefaultText:
                    element.TKText.insert(1.0, element.DefaultText)  # set the default text
                element.TKText.config(highlightthickness=0)
                if text_color is not None and text_color != COLOR_SYSTEM_DEFAULT:
                    element.TKText.configure(fg=text_color, selectbackground=text_color)
                    element.TKText.config(insertbackground=text_color)
                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    element.TKText.configure(background=element.BackgroundColor, selectforeground=element.BackgroundColor)
                if element.selected_background_color not in (None, COLOR_SYSTEM_DEFAULT):
                    element.TKText.configure(selectbackground=element.selected_background_color)
                if element.selected_text_color not in (None, COLOR_SYSTEM_DEFAULT):
                    element.TKText.configure(selectforeground=element.selected_text_color)
                element.TKText.tag_configure("center", justify='center')
                element.TKText.tag_configure("left", justify='left')
                element.TKText.tag_configure("right", justify='right')

                if element.Justification.startswith('l'):
                    element.TKText.tag_add("left", 1.0, "end")
                    element.justification_tag = 'left'
                elif element.Justification.startswith('r'):
                    element.TKText.tag_add("right", 1.0, "end")
                    element.justification_tag = 'right'
                elif element.Justification.startswith('c'):
                    element.TKText.tag_add("center", 1.0, "end")
                    element.justification_tag = 'center'
                # if DEFAULT_SCROLLBAR_COLOR not in (None, COLOR_SYSTEM_DEFAULT):               # only works on Linux so not including it
                #     element.TKText.vbar.config(troughcolor=DEFAULT_SCROLLBAR_COLOR)
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)

                element.element_frame.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], fill=fill, expand=expand)
                element.Widget.pack(side=tk.LEFT, fill=fill, expand=expand)

                if element.visible is False:
                    element._pack_forget_save_settings(alternate_widget=element_frame)
                    # element.element_frame.pack_forget()
                else:
                    element.TKText.bind("<Enter>", lambda event, em=element: testMouseHook(em))
                    element.TKText.bind("<Leave>", lambda event, em=element: testMouseUnhook(em))
                if element.ChangeSubmits:
                    element.TKText.bind('<Key>', element._KeyboardHandler)
                if element.EnterSubmits:
                    element.TKText.bind('<Return>', element._ReturnKeyHandler)
                if element.Focus is True or (toplevel_form.UseDefaultFocus and not toplevel_form.FocusSet):
                    toplevel_form.FocusSet = True
                    element.TKText.focus_set()

                if element.Disabled is True:
                    element.TKText['state'] = 'disabled'
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKText, text=element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)

                if element.reroute_cprint:
                    cprint_set_output_destination(toplevel_form, element.Key)

                _add_right_click_menu_and_grab(element)

                if element.reroute_stdout:
                    element.reroute_stdout_to_here()
                if element.reroute_stderr:
                    element.reroute_stderr_to_here()

                # row_should_expand = True
            # -------------------------  CHECKBOX pleacement element  ------------------------- #
            elif element_type == ELEM_TYPE_INPUT_CHECKBOX:
                element = element  # type: Checkbox
                width = 0 if auto_size_text else element_size[0]
                default_value = element.InitialState
                element.TKIntVar = tk.IntVar()
                element.TKIntVar.set(default_value if default_value is not None else 0)

                element.TKCheckbutton = element.Widget = tk.Checkbutton(
                    tk_row_frame, anchor=tk.NW, text=element.Text, width=width,
                    variable=element.TKIntVar, bd=border_depth,
                    font=font
                )
                if element.ChangeSubmits:
                    element.TKCheckbutton.configure(command=element._CheckboxHandler)
                if element.Disabled:
                    element.TKCheckbutton.configure(state='disable')
                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    element.TKCheckbutton.configure(background=element.BackgroundColor)
                    element.TKCheckbutton.configure(selectcolor=element.CheckboxBackgroundColor)  # The background of the checkbox
                    element.TKCheckbutton.configure(activebackground=element.BackgroundColor)
                if text_color is not None and text_color != COLOR_SYSTEM_DEFAULT:
                    element.TKCheckbutton.configure(fg=text_color)
                    element.TKCheckbutton.configure(activeforeground=element.TextColor)

                element.Widget.configure(highlightthickness=element.highlight_thickness)
                if element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    element.TKCheckbutton.config(highlightbackground=element.BackgroundColor)
                if element.TextColor != COLOR_SYSTEM_DEFAULT:
                    element.TKCheckbutton.config(highlightcolor=element.TextColor)
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element.TKCheckbutton.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings()
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKCheckbutton, text=element.Tooltip,
                                                    timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)

            # -------------------------  PROGRESS placement element  ------------------------- #
            elif element_type == ELEM_TYPE_PROGRESS_BAR:
                element = element  # type: ProgressBar
                if element.size_px != (None, None):
                    progress_length, progress_width = element.size_px
                else:
                    width = element_size[0]
                    fnt = tkinter.font.Font()
                    char_width = fnt.measure('A')  # single character width
                    progress_length = width * char_width
                    progress_width = element_size[1]
                direction = element.Orientation
                if element.BarColor != (None, None):  # if element has a bar color, use it
                    bar_color = element.BarColor
                else:
                    bar_color = DEFAULT_PROGRESS_BAR_COLOR
                if element.Orientation.lower().startswith('h'):
                    base_style_name = ".Horizontal.TProgressbar"
                else:
                    base_style_name = ".Vertical.TProgressbar"
                style_name = _make_ttk_style_name(base_style_name, element, primary_style=True)
                element.TKProgressBar = TKProgressBar(
                    tk_row_frame, element.MaxValue, progress_length, progress_width,
                    orientation=direction, BarColor=bar_color,
                    border_width=element.BorderWidth, relief=element.Relief,
                    ttk_theme=toplevel_form.TtkTheme, key=element.Key, style_name=style_name
                )
                element.Widget = element.TKProgressBar.TKProgressBarForReal
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element.TKProgressBar.TKProgressBarForReal.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings(alternate_widget=element.TKProgressBar.TKProgressBarForReal)
                _add_right_click_menu_and_grab(element)

                # -------------------------  RADIO placement element  ------------------------- #
            elif element_type == ELEM_TYPE_INPUT_RADIO:
                element = element  # type: Radio
                width = 0 if auto_size_text else element_size[0]
                default_value = element.InitialState
                ID = element.GroupID
                # see if ID has already been placed
                value = EncodeRadioRowCol(
                    # value to set intvar to if this radio is selected
                    form.ContainerElemementNumber, row_num, col_num
                )
                element.EncodedRadioValue = value
                if ID in toplevel_form.RadioDict:
                    RadVar = toplevel_form.RadioDict[ID]
                else:
                    RadVar = tk.IntVar()
                    toplevel_form.RadioDict[ID] = RadVar
                element.TKIntVar = RadVar  # store the RadVar in Radio object
                if default_value:  # if this radio is the one selected, set RadVar to match
                    element.TKIntVar.set(value)
                element.TKRadio = element.Widget = tk.Radiobutton(tk_row_frame, anchor=tk.NW, text=element.Text,
                                                                  width=width, variable=element.TKIntVar, value=value,
                                                                  bd=border_depth, font=font)
                if element.ChangeSubmits:
                    element.TKRadio.configure(command=element._RadioHandler)
                if not element.BackgroundColor in (None, COLOR_SYSTEM_DEFAULT):
                    element.TKRadio.configure(background=element.BackgroundColor)
                    element.TKRadio.configure(selectcolor=element.CircleBackgroundColor)
                    element.TKRadio.configure(activebackground=element.BackgroundColor)
                if text_color is not None and text_color != COLOR_SYSTEM_DEFAULT:
                    element.TKRadio.configure(fg=text_color)
                    element.TKRadio.configure(activeforeground=text_color)

                element.Widget.configure(highlightthickness=1)
                if element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    element.TKRadio.config(highlightbackground=element.BackgroundColor)
                if element.TextColor != COLOR_SYSTEM_DEFAULT:
                    element.TKRadio.config(highlightcolor=element.TextColor)

                if element.Disabled:
                    element.TKRadio['state'] = 'disabled'
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element.TKRadio.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings()
                    # element.TKRadio.pack_forget()
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKRadio, text=element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)

                # -------------------------  SPIN placement element  ------------------------- #
            elif element_type == ELEM_TYPE_INPUT_SPIN:
                element = element  # type: Spin
                width, height = element_size
                width = 0 if auto_size_text else element_size[0]
                element.TKStringVar = tk.StringVar()
                element.TKSpinBox = element.Widget = tk.Spinbox(
                    tk_row_frame, values=element.Values,
                    textvariable=element.TKStringVar,
                    width=width, bd=border_depth
                )
                if element.DefaultValue is not None:
                    element.TKStringVar.set(element.DefaultValue)
                element.TKSpinBox.configure(font=font)  # set wrap to width of widget
                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    element.TKSpinBox.configure(background=element.BackgroundColor)
                    element.TKSpinBox.configure(buttonbackground=element.BackgroundColor)
                if text_color  not in (None, COLOR_SYSTEM_DEFAULT):
                    element.TKSpinBox.configure(fg=text_color)
                    element.TKSpinBox.config(insertbackground=text_color)
                element.Widget.config(highlightthickness=0)
                if element.wrap is True:
                    element.Widget.configure(wrap=True)
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element.TKSpinBox.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings()
                if element.ChangeSubmits:
                    element.TKSpinBox.configure(command=element._SpinboxSelectHandler)
                if element.Readonly:
                    element.TKSpinBox['state'] = 'readonly'
                if element.Disabled is True:  # note overrides readonly if disabled
                    element.TKSpinBox['state'] = 'disabled'
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKSpinBox, text=element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)
                if element.BindReturnKey:
                    element.TKSpinBox.bind('<Return>', element._SpinboxSelectHandler)
                _add_right_click_menu_and_grab(element)
                # -------------------------  IMAGE placement element  ------------------------- #
            elif element_type == ELEM_TYPE_IMAGE:
                element = element  # type: Image
                try:
                    if element.Filename is not None:
                        photo = tk.PhotoImage(file=element.Filename)
                    elif element.Data is not None:
                        photo = tk.PhotoImage(data=element.Data)
                    else:
                        photo = None
                    if photo is not None:
                        if element.ImageSubsample:
                            photo = photo.subsample(element.ImageSubsample)
                        if element.zoom:
                            photo = photo.zoom(element.zoom)
                        # print('*ERROR laying out form.... Image Element has no image specified*')
                except Exception as e:
                    photo = None
                    _error_popup_with_traceback('Your Window has an Image Element with a problem',
                                                'The traceback will show you the Window with the problem layout',
                                                'Look in this Window\'s layout for an Image element that has a key of {}'.format(element.Key),
                                                'The error occuring is:', e)

                element.tktext_label = element.Widget = tk.Label(tk_row_frame, bd=0)

                if photo is not None:
                    if element_size == (None, None) or element_size is None or element_size == toplevel_form.DefaultElementSize:
                        width, height = photo.width(), photo.height()
                    else:
                        width, height = element_size
                    element.tktext_label.config(image=photo, width=width, height=height)

                if not element.BackgroundColor in (None, COLOR_SYSTEM_DEFAULT):
                    element.tktext_label.config(background=element.BackgroundColor)

                element.tktext_label.image = photo
                # tktext_label.configure(anchor=tk.NW, image=photo)
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element.tktext_label.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)

                if element.visible is False:
                    element._pack_forget_save_settings()
                    # element.tktext_label.pack_forget()
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.tktext_label, text=element.Tooltip,
                                                    timeout=DEFAULT_TOOLTIP_TIME)
                if element.EnableEvents and element.tktext_label is not None:
                    element.tktext_label.bind('<ButtonPress-1>', element._ClickHandler)

                _add_right_click_menu_and_grab(element)

                # -------------------------  Canvas placement element  ------------------------- #
            elif element_type == ELEM_TYPE_CANVAS:
                element = element  # type: Canvas
                width, height = element_size
                if element._TKCanvas is None:
                    element._TKCanvas = tk.Canvas(tk_row_frame, width=width, height=height, bd=border_depth)
                else:
                    element._TKCanvas.master = tk_row_frame
                element.Widget = element._TKCanvas

                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    element._TKCanvas.configure(background=element.BackgroundColor, highlightthickness=0)
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element._TKCanvas.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings()
                    # element._TKCanvas.pack_forget()
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element._TKCanvas, text=element.Tooltip,
                                                    timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)

                # -------------------------  Graph placement element  ------------------------- #
            elif element_type == ELEM_TYPE_GRAPH:
                element = element  # type: Graph
                width, height = element_size

                element._TKCanvas2 = element.Widget = tk.Canvas(
                    tk_row_frame, width=width, height=height, bd=border_depth
                )
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element._TKCanvas2.pack(side=tk.LEFT, expand=expand, fill=fill)
                element._TKCanvas2.addtag_all('mytag')
                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    element._TKCanvas2.configure(background=element.BackgroundColor, highlightthickness=0)
                    # element._TKCanvas.configure(background=element.BackgroundColor, highlightthickness=0)
                element._TKCanvas2.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings()
                    # element._TKCanvas2.pack_forget()
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element._TKCanvas2, text=element.Tooltip,
                                                    timeout=DEFAULT_TOOLTIP_TIME)
                if element.ChangeSubmits:
                    element._TKCanvas2.bind('<ButtonRelease-1>', element.ButtonReleaseCallBack)
                    element._TKCanvas2.bind('<ButtonPress-1>', element.ButtonPressCallBack)
                if element.DragSubmits:
                    element._TKCanvas2.bind('<Motion>', element.MotionCallBack)
                _add_right_click_menu_and_grab(element)
            # -------------------------  MENU placement element  ------------------------- #
            elif element_type == ELEM_TYPE_MENUBAR:
                element = element  # type: MenuBar
                menu_def = element.MenuDefinition
                element.TKMenu = element.Widget = tk.Menu(toplevel_form.TKroot, tearoff=element.Tearoff,
                                                          tearoffcommand=element._tearoff_menu_callback)  # create the menubar
                menubar = element.TKMenu
                if font is not None:  # if a font is used, make sure it's saved in the element
                    element.Font = font
                for menu_entry in menu_def:
                    baritem = tk.Menu(menubar, tearoff=element.Tearoff, tearoffcommand=element._tearoff_menu_callback)
                    if element.BackgroundColor not in (COLOR_SYSTEM_DEFAULT, None):
                        baritem.config(bg=element.BackgroundColor)
                        baritem.config(activeforeground=element.BackgroundColor)
                    if element.TextColor not in (COLOR_SYSTEM_DEFAULT, None):
                        baritem.config(fg=element.TextColor)
                        baritem.config(activebackground=element.TextColor)
                    if element.DisabledTextColor not in (COLOR_SYSTEM_DEFAULT, None):
                        baritem.config(disabledforeground=element.DisabledTextColor)
                    if font is not None:
                        baritem.config(font=font)
                    pos = menu_entry[0].find(MENU_SHORTCUT_CHARACTER)
                    # print(pos)
                    if pos != -1:
                        if pos == 0 or menu_entry[0][pos - len(MENU_SHORTCUT_CHARACTER)] != "\\":
                            menu_entry[0] = menu_entry[0][:pos] + menu_entry[0][pos + 1:]
                    if menu_entry[0][0] == MENU_DISABLED_CHARACTER:
                        menubar.add_cascade(label=menu_entry[0][len(MENU_DISABLED_CHARACTER):], menu=baritem,
                                            underline=pos - 1)
                        menubar.entryconfig(menu_entry[0][len(MENU_DISABLED_CHARACTER):], state='disabled')
                    else:
                        menubar.add_cascade(label=menu_entry[0], menu=baritem, underline=pos)

                    if len(menu_entry) > 1:
                        AddMenuItem(baritem, menu_entry[1], element)
                toplevel_form.TKroot.configure(menu=element.TKMenu)
            # -------------------------  Frame placement element  ------------------------- #
            elif element_type == ELEM_TYPE_FRAME:
                element = element  # type: Frame
                labeled_frame = element.Widget = tk.LabelFrame(tk_row_frame, text=element.Title, relief=element.Relief)
                element.TKFrame = labeled_frame
                PackFormIntoFrame(element, labeled_frame, toplevel_form)
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                if element.VerticalAlignment is not None:
                    anchor = tk.CENTER  # Default to center if a bad choice is made
                    if element.VerticalAlignment.lower().startswith('t'):
                        anchor = tk.N
                    if element.VerticalAlignment.lower().startswith('c'):
                        anchor = tk.CENTER
                    if element.VerticalAlignment.lower().startswith('b'):
                        anchor = tk.S
                    labeled_frame.pack(side=tk.LEFT, anchor=anchor, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                else:
                    labeled_frame.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)

                if element.Size != (None, None):
                    labeled_frame.config(width=element.Size[0], height=element.Size[1])
                    labeled_frame.pack_propagate(0)
                if not element.visible:
                    element._pack_forget_save_settings()
                    # labeled_frame.pack_forget()
                if element.BackgroundColor != COLOR_SYSTEM_DEFAULT and element.BackgroundColor is not None:
                    labeled_frame.configure(
                        background=element.BackgroundColor,
                        highlightbackground=element.BackgroundColor,
                        highlightcolor=element.BackgroundColor
                    )
                if element.TextColor != COLOR_SYSTEM_DEFAULT and element.TextColor is not None:
                    labeled_frame.configure(foreground=element.TextColor)
                if font is not None:
                    labeled_frame.configure(font=font)
                if element.TitleLocation is not None:
                    labeled_frame.configure(labelanchor=element.TitleLocation)
                if element.BorderWidth is not None:
                    labeled_frame.configure(borderwidth=element.BorderWidth)
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(labeled_frame, text=element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)
                # row_should_expand=True
            # -------------------------  Tab placement element  ------------------------- #
            elif element_type == ELEM_TYPE_TAB:
                element = element  # type: Tab
                form = form   # type: TabGroup
                element.TKFrame = element.Widget = tk.Frame(form.TKNotebook)
                PackFormIntoFrame(element, element.TKFrame, toplevel_form)
                state = 'normal'
                if element.Disabled:
                    state = 'disabled'
                if element.visible is False:
                    state = 'hidden'
                # this code will add an image to the tab. Use it when adding the image on a tab enhancement
                try:
                    if element.Filename is not None:
                        photo = tk.PhotoImage(file=element.Filename)
                    elif element.Data is not None:
                        photo = tk.PhotoImage(data=element.Data)
                    else:
                        photo = None

                    if element.ImageSubsample and photo is not None:
                        photo = photo.subsample(element.ImageSubsample)
                    if element.zoom and photo is not None:
                        photo = photo.zoom(element.zoom)
                        # print('*ERROR laying out form.... Image Element has no image specified*')
                except Exception as e:
                    photo = None
                    _error_popup_with_traceback(
                        'Your Window has an Tab Element with an IMAGE problem',
                         'The traceback will show you the Window with the problem layout',
                         'Look in this Window\'s layout for an Image element that has a key of {}'.format(element.Key),
                         'The error occuring is:', e
                    )

                element.photo = photo
                if photo is not None:
                    if element_size == (None, None) or element_size is None or element_size == toplevel_form.DefaultElementSize:
                        width, height = photo.width(), photo.height()
                    else:
                        width, height = element_size
                    element.tktext_label = tk.Label(tk_row_frame, image=photo, width=width, height=height, bd=0)
                else:
                    element.tktext_label = tk.Label(tk_row_frame, bd=0)
                if photo is not None:
                    form.TKNotebook.add(element.TKFrame, text=element.Title, compound=tk.LEFT, state=state,image=photo)

                form.TKNotebook.add(element.TKFrame, text=element.Title, state=state)

                element.ParentNotebook = form.TKNotebook
                element.TabID = form.TabCount
                # has a list of the tabs in the notebook and their associated key
                form.tab_index_to_key[element.TabID] = element.key
                form.TabCount += 1
                if element.BackgroundColor not in (COLOR_SYSTEM_DEFAULT, None):
                    element.TKFrame.configure(background=element.BackgroundColor, highlightbackground=element.BackgroundColor, highlightcolor=element.BackgroundColor)

                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKFrame, text=element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)

            # -------------------------  TabGroup placement element  ------------------------- #
            elif element_type == ELEM_TYPE_TAB_GROUP:
                element = element  # type: TabGroup
                # custom_style = str(element.Key) + 'customtab.TNotebook'
                custom_style = _make_ttk_style_name('.TNotebook', element, primary_style=True)
                style = ttk.Style()
                _change_ttk_theme(style, toplevel_form.TtkTheme)

                if element.TabLocation is not None:
                    position_dict = {'left': 'w', 'right': 'e', 'top': 'n', 'bottom': 's', 'lefttop': 'wn',
                                     'leftbottom': 'ws', 'righttop': 'en', 'rightbottom': 'es', 'bottomleft': 'sw',
                                     'bottomright': 'se', 'topleft': 'nw', 'topright': 'ne'}
                    try:
                        tab_position = position_dict[element.TabLocation]
                    except:
                        tab_position = position_dict['top']
                    style.configure(custom_style, tabposition=tab_position)

                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    style.configure(custom_style, background=element.BackgroundColor)

                # FINALLY the proper styling to get tab colors!
                if element.SelectedTitleColor is not None and element.SelectedTitleColor != COLOR_SYSTEM_DEFAULT:
                    style.map(custom_style + '.Tab', foreground=[("selected", element.SelectedTitleColor)])
                if element.SelectedBackgroundColor is not None and element.SelectedBackgroundColor != COLOR_SYSTEM_DEFAULT:
                    style.map(custom_style + '.Tab', background=[("selected", element.SelectedBackgroundColor)])
                if element.TabBackgroundColor is not None and element.TabBackgroundColor != COLOR_SYSTEM_DEFAULT:
                    style.configure(custom_style + '.Tab', background=element.TabBackgroundColor)
                if element.TextColor is not None and element.TextColor != COLOR_SYSTEM_DEFAULT:
                    style.configure(custom_style + '.Tab', foreground=element.TextColor)
                if element.BorderWidth is not None:
                    style.configure(custom_style, borderwidth=element.BorderWidth)
                if element.TabBorderWidth is not None:
                    style.configure(custom_style + '.Tab', borderwidth=element.TabBorderWidth)       # if ever want to get rid of border around the TABS themselves
                if element.FocusColor not in (None, COLOR_SYSTEM_DEFAULT):
                    style.configure(custom_style + '.Tab', focuscolor=element.FocusColor)

                style.configure(custom_style + '.Tab', font=font)
                element.Style = style
                element.StyleName = custom_style
                element.TKNotebook = element.Widget = ttk.Notebook(tk_row_frame, style=custom_style)

                PackFormIntoFrame(element, toplevel_form.TKroot, toplevel_form)

                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element.TKNotebook.pack(anchor=tk.SW, side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], fill=fill, expand=expand)

                if element.ChangeSubmits:
                    element.TKNotebook.bind('<<NotebookTabChanged>>', element._TabGroupSelectHandler)
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKNotebook, text=element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)
                if element.Size != (None, None):
                    element.TKNotebook.configure(width=element.Size[0], height=element.Size[1])
                _add_right_click_menu_and_grab(element)
                if element.visible is False:
                    element._pack_forget_save_settings()

            # -------------------  SLIDER placement element  ------------------------- #
            elif element_type == ELEM_TYPE_INPUT_SLIDER:
                element = element  # type: Slider
                slider_length = element_size[0] * _char_width_in_pixels(font)
                slider_width = element_size[1]
                element.TKIntVar = tk.IntVar()
                element.TKIntVar.set(element.DefaultValue)
                if element.Orientation.startswith('v'):
                    range_from = element.Range[1]
                    range_to = element.Range[0]
                    slider_length += DEFAULT_MARGINS[1] * (element_size[0] * 2)  # add in the padding
                else:
                    range_from = element.Range[0]
                    range_to = element.Range[1]
                tkscale = element.Widget = tk.Scale(tk_row_frame, orient=element.Orientation,
                                                        variable=element.TKIntVar,
                                                        from_=range_from, to_=range_to, resolution=element.Resolution,
                                                        length=slider_length, width=slider_width,
                                                        bd=element.BorderWidth,
                                                        relief=element.Relief, font=font,
                                                        tickinterval=element.TickInterval)
                tkscale.config(highlightthickness=0)
                if element.ChangeSubmits:
                    tkscale.config(command=element._SliderChangedHandler)
                if element.BackgroundColor not in (None, COLOR_SYSTEM_DEFAULT):
                    tkscale.configure(background=element.BackgroundColor)
                if element.TroughColor != COLOR_SYSTEM_DEFAULT:
                    tkscale.config(troughcolor=element.TroughColor)
                if element.DisableNumericDisplay:
                    tkscale.config(showvalue=0)
                if text_color not in (None, COLOR_SYSTEM_DEFAULT):
                    tkscale.configure(fg=text_color)
                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                tkscale.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings()
                    # tkscale.pack_forget()
                element.TKScale = tkscale
                if element.Disabled == True:
                    element.TKScale['state'] = 'disabled'
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKScale, text=element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)

            # -------------------------  TABLE placement element  ------------------------- #
            elif element_type == ELEM_TYPE_TABLE:
                element = element  # type: Table
                element.element_frame = frame = tk.Frame(tk_row_frame)
                element.table_frame = frame
                height = element.NumRows
                if element.Justification.startswith('l'):
                    anchor = tk.W
                elif element.Justification.startswith('r'):
                    anchor = tk.E
                else:
                    anchor = tk.CENTER
                column_widths = {}
                # create column width list
                for row in element.Values:
                    for i, col in enumerate(row):
                        col_width = min(len(str(col)), element.MaxColumnWidth)
                        try:
                            if col_width > column_widths[i]:
                                column_widths[i] = col_width
                        except:
                            column_widths[i] = col_width

                if element.ColumnsToDisplay is None:
                    displaycolumns = element.ColumnHeadings if element.ColumnHeadings is not None else element.Values[0]
                else:
                    displaycolumns = []
                    for i, should_display in enumerate(element.ColumnsToDisplay):
                        if should_display:
                            if element.ColumnHeadings is not None:
                                displaycolumns.append(element.ColumnHeadings[i])
                            else:
                                displaycolumns.append(str(i))

                column_headings = element.ColumnHeadings if element.ColumnHeadings is not None else displaycolumns
                if element.DisplayRowNumbers:  # if display row number, tack on the numbers to front of columns
                    displaycolumns = [element.RowHeaderText, ] + displaycolumns
                    if column_headings is not None:
                        column_headings = [element.RowHeaderText, ] + element.ColumnHeadings
                    else:
                        column_headings = [element.RowHeaderText, ] + displaycolumns
                element.TKTreeview = element.Widget = ttk.Treeview(frame, columns=column_headings,
                                                                   displaycolumns=displaycolumns, show='headings',
                                                                   height=height,
                                                                   selectmode=element.SelectMode, )
                treeview = element.TKTreeview
                if element.DisplayRowNumbers:
                    treeview.heading(element.RowHeaderText, text=element.RowHeaderText)  # make a dummy heading
                    row_number_header_width =_string_width_in_pixels(element.HeaderFont, element.RowHeaderText) + 10
                    row_number_width = _string_width_in_pixels(font, str(len(element.Values))) + 10
                    row_number_width = max(row_number_header_width, row_number_width)
                    treeview.column(element.RowHeaderText, width=row_number_width, minwidth=10, anchor=anchor, stretch=0)

                headings = element.ColumnHeadings if element.ColumnHeadings is not None else element.Values[0]
                for i, heading in enumerate(headings):
                    heading = str(heading)
                    treeview.heading(heading, text=heading)
                    if element.AutoSizeColumns:
                        col_width = column_widths.get(i, len(heading))      # in case more headings than there are columns of data
                        width = max(col_width * _char_width_in_pixels(font), len(heading)*_char_width_in_pixels(element.HeaderFont))
                    else:
                        try:
                            width = element.ColumnWidths[i] * _char_width_in_pixels(font)
                        except:
                            width = element.DefaultColumnWidth * _char_width_in_pixels(font)
                    if element.cols_justification is not None:
                        try:
                            if element.cols_justification[i].startswith('l'):
                                col_anchor = tk.W
                            elif element.cols_justification[i].startswith('r'):
                                col_anchor = tk.E
                            elif element.cols_justification[i].startswith('c'):
                                col_anchor = tk.CENTER
                            else:
                                col_anchor = anchor
                        except:             # likely didn't specify enough entries (must be one per col)
                            col_anchor = anchor
                    else:
                        col_anchor = anchor
                    treeview.column(heading, width=width, minwidth=10, anchor=col_anchor, stretch=element.expand_x)
                # Insert values into the tree
                for i, value in enumerate(element.Values):
                    if element.DisplayRowNumbers:
                        value = [i + element.StartingRowNumber] + value
                    id = treeview.insert('', 'end', text=value, iid=i + 1, values=value, tag=i)
                    element.tree_ids.append(id)
                if element.AlternatingRowColor not in (None, COLOR_SYSTEM_DEFAULT):  # alternating colors
                    for row in range(0, len(element.Values), 2):
                        treeview.tag_configure(row, background=element.AlternatingRowColor)
                if element.RowColors is not None:  # individual row colors
                    for row_def in element.RowColors:
                        if len(row_def) == 2:  # only background is specified
                            treeview.tag_configure(row_def[0], background=row_def[1])
                        else:
                            treeview.tag_configure(row_def[0], background=row_def[2], foreground=row_def[1])
                # ------ Do Styling of Colors -----
                # style_name = str(element.Key) + 'customtable.Treeview'
                style_name = _make_ttk_style_name( '.Treeview', element, primary_style=True)
                element.table_ttk_style_name = style_name
                table_style = ttk.Style()
                element.ttk_style = table_style

                _change_ttk_theme(table_style, toplevel_form.TtkTheme)

                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    table_style.configure(style_name, background=element.BackgroundColor, fieldbackground=element.BackgroundColor, )
                    if element.SelectedRowColors[1] is not None:
                        table_style.map(style_name, background=_fixed_map(table_style, style_name, 'background', element.SelectedRowColors))
                if element.TextColor is not None and element.TextColor != COLOR_SYSTEM_DEFAULT:
                    table_style.configure(style_name, foreground=element.TextColor)
                    if element.SelectedRowColors[0] is not None:
                        table_style.map(style_name, foreground=_fixed_map(table_style, style_name, 'foreground', element.SelectedRowColors))
                if element.RowHeight is not None:
                    table_style.configure(style_name, rowheight=element.RowHeight)
                else:
                    table_style.configure(style_name, rowheight=_char_height_in_pixels(font))
                if element.HeaderTextColor is not None and element.HeaderTextColor != COLOR_SYSTEM_DEFAULT:
                    table_style.configure(style_name + '.Heading', foreground=element.HeaderTextColor)
                if element.HeaderBackgroundColor is not None and element.HeaderBackgroundColor != COLOR_SYSTEM_DEFAULT:
                    table_style.configure(style_name + '.Heading', background=element.HeaderBackgroundColor)
                if element.HeaderFont is not None:
                    table_style.configure(style_name + '.Heading', font=element.HeaderFont)
                else:
                    table_style.configure(style_name + '.Heading', font=font)
                if element.HeaderBorderWidth is not None:
                    table_style.configure(style_name + '.Heading', borderwidth=element.HeaderBorderWidth)
                if element.HeaderRelief is not None:
                    table_style.configure(style_name + '.Heading', relief=element.HeaderRelief)
                table_style.configure(style_name, font=font)
                if element.BorderWidth is not None:
                    table_style.configure(style_name, borderwidth=element.BorderWidth)

                if element.HeaderBackgroundColor not in (None, COLOR_SYSTEM_DEFAULT) and  element.HeaderTextColor not in  (None, COLOR_SYSTEM_DEFAULT):
                    table_style.map(
                        style_name + ".Heading", background=[(
                            'pressed', '!focus', element.HeaderBackgroundColor),
                            ('active', element.HeaderTextColor),])
                    table_style.map(
                        style_name + ".Heading", foreground=[(
                            'pressed', '!focus', element.HeaderTextColor),
                             ('active', element.HeaderBackgroundColor),])

                treeview.configure(style=style_name)

                if element.enable_click_events is True:
                    treeview.bind('<ButtonRelease-1>', element._table_clicked)
                if element.right_click_selects:
                    if running_mac():
                        treeview.bind('<Button-2>', element._table_clicked)
                    else:
                        treeview.bind('<Button-3>', element._table_clicked)
                treeview.bind("<<TreeviewSelect>>", element._treeview_selected)
                if element.BindReturnKey:
                    treeview.bind('<Return>', element._treeview_double_click)
                    treeview.bind('<Double-Button-1>', element._treeview_double_click)

                if not element.HideVerticalScroll:
                    _make_ttk_scrollbar(element, 'v', toplevel_form)

                    element.Widget.configure(yscrollcommand=element.vsb.set)
                    element.vsb.pack(side=tk.RIGHT, fill='y')

                # Horizontal scrollbar
                if not element.VerticalScrollOnly:
                    _make_ttk_scrollbar(element, 'h', toplevel_form)
                    element.hsb.pack(side=tk.BOTTOM, fill='x')
                    element.Widget.configure(xscrollcommand=element.hsb.set)

                if not element.HideVerticalScroll or not element.VerticalScrollOnly:
                    element.Widget.bind("<Enter>", lambda event, em=element: testMouseHook(em))
                    element.Widget.bind("<Leave>", lambda event, em=element: testMouseUnhook(em))

                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element.TKTreeview.pack(side=tk.LEFT, padx=0, pady=0, expand=expand, fill=fill)
                frame.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings(alternate_widget=element.element_frame)
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKTreeview, text=element.Tooltip,
                                                    timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)

                if tclversion_detailed == '8.6.9' and ENABLE_TREEVIEW_869_PATCH:
                    table_style.map(
                        style_name,
                        foreground=_fixed_map(table_style, style_name, 'foreground', element.SelectedRowColors),
                        background=_fixed_map(table_style, style_name, 'background', element.SelectedRowColors)
                    )
            # -------------------------  Tree placement element  ------------------------- #
            elif element_type == ELEM_TYPE_TREE:
                element = element  # type: Tree
                element.element_frame = element_frame = tk.Frame(tk_row_frame)

                height = element.NumRows
                if element.Justification.startswith('l'):  # justification
                    anchor = tk.W
                elif element.Justification.startswith('r'):
                    anchor = tk.E
                else:
                    anchor = tk.CENTER

                if element.ColumnsToDisplay is None:  # Which cols to display
                    displaycolumns = element.ColumnHeadings
                else:
                    displaycolumns = []
                    for i, should_display in enumerate(element.ColumnsToDisplay):
                        if should_display:
                            displaycolumns.append(element.ColumnHeadings[i])
                column_headings = element.ColumnHeadings
                # ------------- GET THE TREEVIEW WIDGET -------------
                element.TKTreeview = element.Widget = ttk.Treeview(
                    element_frame, columns=column_headings,
                    displaycolumns=displaycolumns,
                    show='tree headings' if column_headings is not None else 'tree',
                    height=height,
                    selectmode=element.SelectMode
                )
                treeview = element.TKTreeview
                max_widths = {}
                for key, node in element.TreeData.tree_dict.items():
                    for i, value in enumerate(node.values):
                        max_width = max_widths.get(i, 0)
                        if len(str(value)) > max_width:
                            max_widths[i] = len(str(value))

                if element.ColumnHeadings is not None:
                    for i, heading in enumerate(element.ColumnHeadings): # Configure cols + headings
                        treeview.heading(heading, text=heading)
                        if element.AutoSizeColumns:
                            max_width = max_widths.get(i, 0)
                            max_width = max(max_width, len(heading))
                            width = min(element.MaxColumnWidth, max_width+1)
                        else:
                            try:
                                width = element.ColumnWidths[i]
                            except:
                                width = element.DefaultColumnWidth
                        treeview.column(heading, width=width * _char_width_in_pixels(font) + 10, anchor=anchor)

                def add_treeview_data(node):
                    """
                    :param node:
                    :type node:

                    """
                    if node.key != '':
                        if node.icon:
                            if node.icon not in element.image_dict:
                                if type(node.icon) is bytes:
                                    photo = tk.PhotoImage(data=node.icon)
                                else:
                                    photo = tk.PhotoImage(file=node.icon)
                                element.image_dict[node.icon] = photo
                            else:
                                photo = element.image_dict.get(node.icon)

                            node.photo = photo
                            try:
                                id = treeview.insert(element.KeyToID[node.parent], 'end', iid=None, text=node.text, values=node.values, open=element.ShowExpanded, image=node.photo)
                                element.IdToKey[id] = node.key
                                element.KeyToID[node.key] = id
                            except Exception as e:
                                print('Error inserting image into tree', e)
                        else:
                            id = treeview.insert(element.KeyToID[node.parent], 'end', iid=None, text=node.text, values=node.values, open=element.ShowExpanded)
                            element.IdToKey[id] = node.key
                            element.KeyToID[node.key] = id

                    for node in node.children:
                        add_treeview_data(node)

                add_treeview_data(element.TreeData.root_node)
                treeview.column('#0', width=element.Col0Width * _char_width_in_pixels(font), anchor=tk.W)
                treeview.heading('#0', text=element.col0_heading)

                # ----- configure colors -----
                # style_name = str(element.Key) + '.Treeview'
                style_name = _make_ttk_style_name('.Treeview', element, primary_style=True)
                tree_style = ttk.Style()
                _change_ttk_theme(tree_style, toplevel_form.TtkTheme)

                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    tree_style.configure(style_name, background=element.BackgroundColor, fieldbackground=element.BackgroundColor)
                    if element.SelectedRowColors[1] is not None:
                        tree_style.map(style_name, background=_fixed_map(tree_style, style_name, 'background', element.SelectedRowColors))
                if element.TextColor is not None and element.TextColor != COLOR_SYSTEM_DEFAULT:
                    tree_style.configure(style_name, foreground=element.TextColor)
                    if element.SelectedRowColors[0] is not None:
                        tree_style.map(style_name, foreground=_fixed_map(tree_style, style_name, 'foreground', element.SelectedRowColors))
                if element.HeaderTextColor is not None and element.HeaderTextColor != COLOR_SYSTEM_DEFAULT:
                    tree_style.configure(style_name + '.Heading', foreground=element.HeaderTextColor)
                if element.HeaderBackgroundColor is not None and element.HeaderBackgroundColor != COLOR_SYSTEM_DEFAULT:
                    tree_style.configure(style_name + '.Heading', background=element.HeaderBackgroundColor)
                if element.HeaderFont is not None:
                    tree_style.configure(style_name + '.Heading', font=element.HeaderFont)
                else:
                    tree_style.configure(style_name + '.Heading', font=font)
                if element.HeaderBorderWidth is not None:
                    tree_style.configure(style_name + '.Heading', borderwidth=element.HeaderBorderWidth)
                if element.HeaderRelief is not None:
                    tree_style.configure(style_name + '.Heading', relief=element.HeaderRelief)
                tree_style.configure(style_name, font=font)
                if element.RowHeight:
                    tree_style.configure(style_name, rowheight=element.RowHeight)
                else:
                    tree_style.configure(style_name, rowheight=_char_height_in_pixels(font))
                if element.BorderWidth is not None:
                    tree_style.configure(style_name, borderwidth=element.BorderWidth)

                treeview.configure(style=style_name)  # IMPORTANT! Be sure and set the style name for this widget

                if not element.HideVerticalScroll:
                    _make_ttk_scrollbar(element, 'v', toplevel_form)

                    element.Widget.configure(yscrollcommand=element.vsb.set)
                    element.vsb.pack(side=tk.RIGHT, fill='y')

                # Horizontal scrollbar
                if not element.VerticalScrollOnly:
                    # element.Widget.config(wrap='none')
                    _make_ttk_scrollbar(element, 'h', toplevel_form)
                    element.hsb.pack(side=tk.BOTTOM, fill='x')
                    element.Widget.configure(xscrollcommand=element.hsb.set)

                if not element.HideVerticalScroll or not element.VerticalScrollOnly:
                    element.Widget.bind("<Enter>", lambda event, em=element: testMouseHook(em))
                    element.Widget.bind("<Leave>", lambda event, em=element: testMouseUnhook(em))

                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)
                element.TKTreeview.pack(side=tk.LEFT, padx=0, pady=0, expand=expand, fill=fill)
                element_frame.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], expand=expand, fill=fill)
                if element.visible is False:
                    element._pack_forget_save_settings(alternate_widget=element.element_frame) # seems like it should be the frame if following other elements conventions
                treeview.bind("<<TreeviewSelect>>", element._treeview_selected)
                if element.Tooltip is not None:  # tooltip
                    element.TooltipObject = ToolTip(element.TKTreeview, text=element.Tooltip,
                                                    timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)

                if tclversion_detailed == '8.6.9' and ENABLE_TREEVIEW_869_PATCH:
                    tree_style.map(style_name,
                                   foreground=_fixed_map(tree_style, style_name, 'foreground', element.SelectedRowColors),
                                   background=_fixed_map(tree_style, style_name, 'background', element.SelectedRowColors))

            # -------------------------  Separator placement element  ------------------------- #
            elif element_type == ELEM_TYPE_SEPARATOR:
                element = element  # type: VerticalSeparator
                # style_name = str(element.Key) + "Line.TSeparator"
                style_name = _make_ttk_style_name(".Line.TSeparator", element, primary_style=True)
                style = ttk.Style()

                _change_ttk_theme(style, toplevel_form.TtkTheme)

                if element.color not in (None, COLOR_SYSTEM_DEFAULT):
                    style.configure(style_name, background=element.color)
                separator = element.Widget = ttk.Separator(tk_row_frame, orient=element.Orientation, )

                expand, fill, row_should_expand, row_fill_direction = _add_expansion(element, row_should_expand, row_fill_direction)

                if element.Orientation.startswith('h'):
                    separator.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], fill=tk.X, expand=True)
                else:
                    separator.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], fill=tk.Y, expand=False)
                element.Widget.configure(style=style_name)  # IMPORTANT!  Apply the style
            # -------------------------  SizeGrip placement element  ------------------------- #
            elif element_type == ELEM_TYPE_SIZEGRIP:
                element = element  # type: Sizegrip
                style_name = "Sizegrip.TSizegrip"
                style = ttk.Style()

                _change_ttk_theme(style, toplevel_form.TtkTheme)

                size_grip = element.Widget = ttk.Sizegrip(tk_row_frame)
                toplevel_form.sizegrip_widget = size_grip
                # if no size is specified, then use the background color for the window
                if element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    style.configure(style_name, background=element.BackgroundColor)
                else:
                    style.configure(style_name, background=toplevel_form.TKroot['bg'])
                size_grip.configure(style=style_name)

                size_grip.pack(side=tk.BOTTOM, anchor='se', padx=elementpad[0], pady=elementpad[1], fill=tk.X, expand=True)
                # tricky part of sizegrip... it shouldn't cause the row to expand, but should expand and should add X axis if
                # not already filling in that direction.  Otherwise, leaves things alone!
                # row_should_expand = True
                row_fill_direction = tk.BOTH if row_fill_direction in (tk.Y, tk.BOTH) else tk.X
            # -------------------------  StatusBar placement element  ------------------------- #
            elif element_type == ELEM_TYPE_STATUSBAR:
                # auto_size_text = element.AutoSizeText
                display_text = element.DisplayText  # text to display
                if auto_size_text is False:
                    width, height = element_size
                else:
                    lines = display_text.split('\n')
                    max_line_len = max([len(l) for l in lines])
                    num_lines = len(lines)
                    if max_line_len > element_size[0]:  # if text exceeds element size, the will have to wrap
                        width = element_size[0]
                    else:
                        width = max_line_len
                    height = num_lines

                # ---===--- LABEL widget create and place --- #
                stringvar = tk.StringVar()
                element.TKStringVar = stringvar
                stringvar.set(display_text)
                if auto_size_text:
                    width = 0
                if element.Justification is not None:
                    justification = element.Justification
                elif toplevel_form.TextJustification is not None:
                    justification = toplevel_form.TextJustification
                else:
                    justification = DEFAULT_TEXT_JUSTIFICATION
                justify = tk.LEFT if justification.startswith('l') else tk.CENTER if justification.startswith('c') else tk.RIGHT
                anchor = tk.NW if justification.startswith('l') else tk.N if justification.startswith('c') else tk.NE
                # tktext_label = tk.Label(tk_row_frame, textvariable=stringvar, width=width, height=height,
                #                         justify=justify, bd=border_depth, font=font)
                tktext_label = element.Widget = tk.Label(tk_row_frame, textvariable=stringvar, width=width,
                                                         height=height,
                                                         justify=justify, bd=border_depth, font=font)
                # Set wrap-length for text (in PIXELS) == PAIN IN THE ASS
                wraplen = tktext_label.winfo_reqwidth() + 40  # width of widget in Pixels
                if not auto_size_text and height == 1:
                    wraplen = 0

                tktext_label.configure(anchor=anchor, wraplen=wraplen)  # set wrap to width of widget
                if element.Relief is not None:
                    tktext_label.configure(relief=element.Relief)
                if element.BackgroundColor is not None and element.BackgroundColor != COLOR_SYSTEM_DEFAULT:
                    tktext_label.configure(background=element.BackgroundColor)
                if element.TextColor != COLOR_SYSTEM_DEFAULT and element.TextColor is not None:
                    tktext_label.configure(fg=element.TextColor)
                tktext_label.pack(side=tk.LEFT, padx=elementpad[0], pady=elementpad[1], fill=tk.X, expand=True)
                row_fill_direction = tk.X
                if element.visible is False:
                    element._pack_forget_save_settings()
                element.TKText = tktext_label
                if element.ClickSubmits:
                    tktext_label.bind('<Button-1>', element._TextClickedHandler)
                if element.Tooltip is not None:
                    element.TooltipObject = ToolTip(element.TKText, text=element.Tooltip, timeout=DEFAULT_TOOLTIP_TIME)
                _add_right_click_menu_and_grab(element)

        anchor = 'nw'

        if row_justify.lower().startswith('c'):
            anchor = 'n'
            side = tk.LEFT
        elif row_justify.lower().startswith('r'):
            anchor = 'ne'
            side = tk.RIGHT
        elif row_justify.lower().startswith('l'):
            anchor = 'nw'
            side = tk.LEFT

        tk_row_frame.pack(side=tk.TOP, anchor=anchor, padx=0, pady=0, expand=row_should_expand, fill=row_fill_direction)
        if form.BackgroundColor is not None and form.BackgroundColor != COLOR_SYSTEM_DEFAULT:
            tk_row_frame.configure(background=form.BackgroundColor)

    return


def _get_hidden_master_root():
    """Creates the hidden master root window

    This window is never visible and represents the overall application.
    """
    # if one is already made, then skip making another
    if Window.hidden_master_root is None:
        Window._IncrementOpenCount()
        Window.hidden_master_root = tk.Tk()
        Window.hidden_master_root.attributes('-alpha', 0)  # HIDE this window
        try:
            Window.hidden_master_root.wm_overrideredirect(True)
        except Exception as e:
            if not running_mac():
                print('* Error performing wm_overrideredirect while hiding the hidden master root*', e)
        Window.hidden_master_root.withdraw()
    return Window.hidden_master_root


def _no_titlebar_setup(window):
    """Does the operations required to turn off the title bar for the window

    The Raspberry Pi required the settings to be make after the window's creation.
    Calling twice seems to have had better overall results so that's what's currently done.
    The MAC has been the problem with this feature.  It's been a chronic problem on the Mac.
    :param window:          window to turn off the titlebar if indicated in the settings
    :type window:           Window
    """
    try:
        if window.NoTitleBar:
            if running_linux():
                # window.TKroot.wm_attributes("-type", 'splash')
                window.TKroot.wm_attributes("-type", 'dock')
            else:
                window.TKroot.wm_overrideredirect(True)
                # Special case for Mac. Need to clear flag again if not tkinter version 8.6.10+
                if _mac_should_apply_notitlebar_patch():
                    print('* Applying Mac no_titlebar patch *')
                    window.TKroot.wm_overrideredirect(False)
    except Exception as e:
        warnings.warn('** Problem setting no titlebar {} **'.format(e), UserWarning)


def _convert_window_to_tk(window):
    """
    :type window: (Window)
    """
    master = window.TKroot
    master.title(window.Title)
    InitializeResults(window)

    PackFormIntoFrame(window, master, window)

    window.TKroot.configure(padx=window.Margins[0], pady=window.Margins[1])

    # ....................................... DONE creating and laying out window ..........................#
    if window._Size != (None, None):
        master.geometry("%sx%s" % (window._Size[0], window._Size[1]))

    screen_width = master.winfo_screenwidth()  # get window info to move to middle of screen
    screen_height = master.winfo_screenheight()

    if window.Location != (None, None):
        x, y = window.Location
    elif DEFAULT_WINDOW_LOCATION != (None, None):
        x, y = DEFAULT_WINDOW_LOCATION
    else:
        master.update_idletasks()  # don't forget to do updates or values are bad
        win_width = master.winfo_width()
        win_height = master.winfo_height()
        x = screen_width / 2 - win_width / 2
        y = screen_height / 2 - win_height / 2
        if y + win_height > screen_height:
            y = screen_height - win_height
        if x + win_width > screen_width:
            x = screen_width - win_width

    if window.RelativeLoction != (None, None):
        x += window.RelativeLoction[0]
        y += window.RelativeLoction[1]

    move_string = '+%i+%i' % (int(x), int(y))
    master.geometry(move_string)
    window.config_last_location = (int(x), (int(y)))
    window.TKroot.x = int(x)
    window.TKroot.y = int(y)
    window.starting_window_position = (int(x), (int(y)))
    master.update_idletasks()  # don't forget
    master.geometry(move_string)
    master.update_idletasks()  # don't forget

    _no_titlebar_setup(window)

    return


# ----====----====----====----====----==== STARTUP TK ====----====----====----====----====----#
def StartupTK(window):
    """NOTE: **Not** user callable function

    Creates the window (for real) lays out all the elements, etc.
    It is a HUGE set of things it does.  It is the basic 'porting layer' that
    will change depending on the GUI framework is running on top of.

    :param window: you window object
    :type window:  (Window)
    """
    window = window  # type: Window
    ow = Window.NumOpenWindows
    if ENABLE_TK_WINDOWS:
        root = tk.Tk()
    elif not ow and not window.ForceTopLevel:
        # If first window being created, make a throwaway, hidden master root.
        # This stops one user window from becoming the child of another.
        # All windows are children of this hidden window.
        _get_hidden_master_root()
        root = tk.Toplevel(class_=window.Title)
    else:
        root = tk.Toplevel(class_=window.Title)
    if window.DebuggerEnabled:
        root.bind('<Cancel>', window._callback_main_debugger_window_create_keystroke)
        root.bind('<Pause>', window._callback_popout_window_create_keystroke)

    # If location is None, then there's no need to hide the window.
    # Let it build where it is going to end up being.
    if DEFAULT_HIDE_WINDOW_WHEN_CREATING is True and window.Location is not None:
        try:
            if not running_mac() or \
                    (running_mac() and not window.NoTitleBar) or \
                    (running_mac() and window.NoTitleBar and not _mac_should_apply_notitlebar_patch()):

                root.attributes('-alpha', 0)  # hide window while building it. makes for smoother 'paint'
        except Exception as e:
            print('*** Exception setting alpha channel to zero while creating window ***', e)

    if window.BackgroundColor is not None and window.BackgroundColor != COLOR_SYSTEM_DEFAULT:
        root.configure(background=window.BackgroundColor)
    Window._IncrementOpenCount()

    window.TKroot = root

    window._create_thread_queue()

    # For the Raspberry Pi
    if not running_mac():
        _no_titlebar_setup(window)

    if not window.Resizable:
        root.resizable(False, False)

    if window.DisableMinimize:
        root.attributes("-toolwindow", 1)

    if window.KeepOnTop:
        root.wm_attributes("-topmost", 1)

    if window.TransparentColor is not None:
        window.SetTransparentColor(window.TransparentColor)

    if window.scaling is not None:
        root.tk.call('tk', 'scaling', window.scaling)

    _convert_window_to_tk(window)

    # Make moveable window
    if (window.GrabAnywhere is not False and not (
            window.NonBlocking and window.GrabAnywhere is not True)):
        if not (ENABLE_MAC_DISABLE_GRAB_ANYWHERE_WITH_TITLEBAR and running_mac() and not window.NoTitleBar):
            root.bind("<ButtonPress-1>", window._StartMoveGrabAnywhere)
            root.bind("<ButtonRelease-1>", window._StopMove)
            root.bind("<B1-Motion>", window._OnMotionGrabAnywhere)
    if (window.GrabAnywhereUsingControlKey is not False and not (
            window.NonBlocking and window.GrabAnywhereUsingControlKey is not True)):
        root.bind("<Control-Button-1>", window._StartMoveUsingControlKey)
        root.bind("<Control-ButtonRelease-1>", window._StopMove)
        root.bind("<Control-B1-Motion>", window._OnMotionUsingControlKey)
        # also enable movement using Control + Arrow key
        root.bind("<Control-Left>", window._move_callback)
        root.bind("<Control-Right>", window._move_callback)
        root.bind("<Control-Up>", window._move_callback)
        root.bind("<Control-Down>", window._move_callback)

    window.set_icon(window.WindowIcon)
    try:
        alpha_channel = 1 if window.AlphaChannel is None else window.AlphaChannel
        root.attributes('-alpha', alpha_channel)  # Make window visible again
    except Exception as e:
        print('**** Error setting Alpha Channel to {} after window was created ****'.format(alpha_channel), e)
        # pass

    if window.ReturnKeyboardEvents and not window.NonBlocking:
        root.bind("<KeyRelease>", window._KeyboardCallback)
        root.bind("<MouseWheel>", window._MouseWheelCallback)
        root.bind("<Button-4>", window._MouseWheelCallback)
        root.bind("<Button-5>", window._MouseWheelCallback)
    elif window.ReturnKeyboardEvents:
        root.bind("<Key>", window._KeyboardCallback)
        root.bind("<MouseWheel>", window._MouseWheelCallback)
        root.bind("<Button-4>", window._MouseWheelCallback)
        root.bind("<Button-5>", window._MouseWheelCallback)

    DEFAULT_WINDOW_SNAPSHOT_KEY_CODE = main_global_get_screen_snapshot_symcode()

    if DEFAULT_WINDOW_SNAPSHOT_KEY_CODE:
        # print('**** BINDING THE SNAPSHOT!', DEFAULT_WINDOW_SNAPSHOT_KEY_CODE, DEFAULT_WINDOW_SNAPSHOT_KEY)
        window.bind(DEFAULT_WINDOW_SNAPSHOT_KEY_CODE, DEFAULT_WINDOW_SNAPSHOT_KEY, propagate=False)
        # window.bind('<Win_L><F12>', DEFAULT_WINDOW_SNAPSHOT_KEY, )

    if window.NoTitleBar:
        window.TKroot.focus_force()

    if window.AutoClose:
        # if the window is being finalized, then don't start the autoclose timer
        if not window.finalize_in_progress:
            window._start_autoclose_timer()
            # duration = DEFAULT_AUTOCLOSE_TIME if window.AutoCloseDuration is None else window.AutoCloseDuration
            # window.TKAfterID = root.after(int(duration * 1000), window._AutoCloseAlarmCallback)

    if window.Timeout != None:
        window.TKAfterID = root.after(int(window.Timeout), window._TimeoutAlarmCallback)
    if window.NonBlocking:
        window.TKroot.protocol("WM_DESTROY_WINDOW", window._OnClosingCallback)
        window.TKroot.protocol("WM_DELETE_WINDOW", window._OnClosingCallback)
        window.TKroot.bind("<Configure>", window._config_callback)

    else:  # it's a blocking form
        # print('..... CALLING MainLoop')
        window.CurrentlyRunningMainloop = True
        window.TKroot.protocol("WM_DESTROY_WINDOW", window._OnClosingCallback)
        window.TKroot.protocol("WM_DELETE_WINDOW", window._OnClosingCallback)

        if window.modal or DEFAULT_MODAL_WINDOWS_FORCED:
            window.make_modal()

        # if window.enable_window_config_events:
        # ALWAYS enable config callbacks
        window.TKroot.bind("<Configure>", window._config_callback)

        # ----------------------------------- tkinter mainloop call -----------------------------------
        Window._window_running_mainloop = window
        Window._root_running_mainloop = window.TKroot
        window.TKroot.mainloop()
        window.CurrentlyRunningMainloop = False
        window.TimerCancelled = True
        # print('..... BACK from MainLoop')
        if not window.FormRemainedOpen:
            Window._DecrementOpenCount()
            # _my_windows.Decrement()
        if window.RootNeedsDestroying:
            try:
                window.TKroot.destroy()
            except:
                pass
            window.RootNeedsDestroying = False
    return


def _set_icon_for_tkinter_window(root, icon=None, pngbase64=None):
    """At the moment, this function is only used
        by the `get_filename` or folder with the `no_window` option set

    Changes the icon that is shown on the title bar and on the task bar.
    NOTE: The file type is **IMPORTANT** and depends on the OS!

    Can pass in:
    * filename which must be a .ICO file for Windows, PNG file for Linux
    * bytes object
    * BASE64 encoded file held in a variable

    :param root:      The window being modified
    :type root:       (tk.Tk or tk.TopLevel)
    :param icon:      Filename or bytes object
    :type icon:       (str | bytes)
    :param pngbase64: Base64 encoded image
    :type pngbase64:  (bytes)
    """

    if type(icon) is bytes or pngbase64 is not None:
        wicon = tkinter.PhotoImage(data=icon if icon is not None else pngbase64)
        try:
            root.tk.call('wm', 'iconphoto', root._w, wicon)
        except:
            wicon = tkinter.PhotoImage(data=DEFAULT_BASE64_ICON)
            try:
                root.tk.call('wm', 'iconphoto', root._w, wicon)
            except Exception as e:
                print('Set icon exception', e)
                pass
        return

    wicon = icon
    try:
        root.iconbitmap(icon)
    except  Exception as e:
        try:
            wicon = tkinter.PhotoImage(file=icon)
            root.tk.call('wm', 'iconphoto', root._w, wicon)
        except  Exception as e:
            try:
                wicon = tkinter.PhotoImage(data=DEFAULT_BASE64_ICON)
                try:
                    root.tk.call('wm', 'iconphoto', root._w, wicon)
                except Exception as e:
                    print('Set icon exception', e)
                    pass
            except:
                print('Set icon exception', e)
                pass


# ===================================================#
# Helper function for determining how to wrap text   #
# ===================================================#

def _GetNumLinesNeeded(text, max_line_width):
    if max_line_width == 0:
        return 1
    lines = text.split('\n')
    num_lines = len(lines)
    max_line_len = max([len(l) for l in lines])
    lines_used = []
    for L in lines:
        lines_used.append(len(L) // max_line_width + (len(L) % max_line_width > 0))
    total_lines_needed = sum(lines_used)
    return total_lines_needed


# ==============================  PROGRESS METER ========================================== #

def convert_args_to_single_string(*args):
    """
    :param *args:
    :type *args:
    """
    max_line_total, width_used, total_lines, = 0, 0, 0
    single_line_message = ''
    # loop through args and built a SINGLE string from them
    for message in args:
        # fancy code to check if string and convert if not is not need. Just always convert to string :-)
        message = str(message)
        longest_line_len = max([len(l) for l in message.split('\n')])
        width_used = max(longest_line_len, width_used)
        max_line_total = max(max_line_total, width_used)
        lines_needed = _GetNumLinesNeeded(message, width_used)
        total_lines += lines_needed
        single_line_message += message + '\n'

    return single_line_message, width_used, total_lines


METER_REASON_CANCELLED = 'cancelled'
METER_REASON_CLOSED = 'closed'
METER_REASON_REACHED_MAX = 'finished'
METER_OK = True
METER_STOPPED = False


class _QuickMeter(object):
    active_meters = {}
    exit_reasons = {}

    def __init__(self, title, current_value, max_value, key, *args, orientation='v', bar_color=(None, None), button_color=(None, None),
                 size=DEFAULT_PROGRESS_BAR_SIZE, border_width=None, grab_anywhere=False, no_titlebar=False, keep_on_top=None, no_button=False):
        """
        :param title:         text to display in element
        :type title:          (str)
        :param current_value: current value
        :type current_value:  (int)
        :param max_value:     max value of progress meter
        :type max_value:      (int)
        :param key:           Used with window.find_element and with return values to uniquely identify this element
        :type key:            str | int | tuple | object
        :param *args:         stuff to output
        :type *args:          (Any)
        :param orientation:   'horizontal' or 'vertical' ('h' or 'v' work) (Default value = 'vertical' / 'v')
        :type orientation:    (str)
        :param bar_color:     The 2 colors that make up a progress bar. Either a tuple of 2 strings or a string. Tuple - (bar, background). A string with 1 color changes the background of the bar only. A string with 2 colors separated by "on" like "red on blue" specifies a red bar on a blue background.
        :type bar_color:      (str, str) | str
        :param button_color:  button color (foreground, background)
        :type button_color:   (str, str) | str
        :param size:          (w,h) w=characters-wide, h=rows-high (Default value = DEFAULT_PROGRESS_BAR_SIZE)
        :type size:           (int, int)
        :param border_width:  width of border around element
        :type border_width:   (int)
        :param grab_anywhere: If True: can grab anywhere to move the window (Default = False)
        :type grab_anywhere:  (bool)
        :param no_titlebar:   If True: window will be created without a titlebar
        :type no_titlebar:    (bool)
        :param keep_on_top:   If True the window will remain above all current windows
        :type keep_on_top:    (bool)
        :param no_button:     If True: window will be created without a cancel button
        :type no_button:      (bool)
        """
        self.start_time = datetime.datetime.utcnow()
        self.key = key
        self.orientation = orientation
        self.bar_color = bar_color
        self.size = size
        self.grab_anywhere = grab_anywhere
        self.button_color = button_color
        self.border_width = border_width
        self.no_titlebar = no_titlebar
        self.title = title
        self.current_value = current_value
        self.max_value = max_value
        self.close_reason = None
        self.keep_on_top = keep_on_top
        self.no_button = no_button
        self.window = self.BuildWindow(*args)

    def BuildWindow(self, *args):
        layout = []
        if self.orientation.lower().startswith('h'):
            col = []
            col += [[T(''.join(map(lambda x: str(x) + '\n', args)),
                       key='-OPTMSG-')]]  ### convert all *args into one string that can be updated
            col += [[T('', size=(30, 10), key='-STATS-')],
                    [ProgressBar(max_value=self.max_value, orientation='h', key='-PROG-', size=self.size,
                                 bar_color=self.bar_color)]]
            if not self.no_button:
                col += [[Cancel(button_color=self.button_color), Stretch()]]
            layout = [Column(col)]
        else:
            col = [[ProgressBar(max_value=self.max_value, orientation='v', key='-PROG-', size=self.size,
                                bar_color=self.bar_color)]]
            col2 = []
            col2 += [[T(''.join(map(lambda x: str(x) + '\n', args)),
                        key='-OPTMSG-')]]  ### convert all *args into one string that can be updated
            col2 += [[T('', size=(30, 10), key='-STATS-')]]
            if not self.no_button:
                col2 += [[Cancel(button_color=self.button_color), Stretch()]]

            layout = [Column(col), Column(col2)]
        self.window = Window(
            self.title, grab_anywhere=self.grab_anywhere,
            border_depth=self.border_width, no_titlebar=self.no_titlebar,
            disable_close=True, keep_on_top=self.keep_on_top
        )
        self.window.Layout([layout]).Finalize()

        return self.window

    def UpdateMeter(self, current_value, max_value, *args):  ### support for *args when updating
        """Update Meter"""
        self.current_value = current_value
        self.max_value = max_value
        self.window.Element('-PROG-').UpdateBar(self.current_value, self.max_value)
        self.window.Element('-STATS-').Update('\n'.join(self.ComputeProgressStats()))
        self.window.Element('-OPTMSG-').Update(
            value=''.join(map(lambda x: str(x) + '\n', args)))  ###  update the string with the args
        event, values = self.window.read(timeout=0)
        if event in ('Cancel', None) or current_value >= max_value:
            exit_reason = METER_REASON_CANCELLED if event in ('Cancel', None) else METER_REASON_REACHED_MAX if current_value >= max_value else METER_STOPPED
            self.window.close()
            del (_QuickMeter.active_meters[self.key])
            _QuickMeter.exit_reasons[self.key] = exit_reason
            return _QuickMeter.exit_reasons[self.key]
        return METER_OK

    def ComputeProgressStats(self):
        utc = datetime.datetime.utcnow()
        time_delta = utc - self.start_time
        total_seconds = time_delta.total_seconds()
        if not total_seconds:
            total_seconds = 1
        try:
            time_per_item = total_seconds / self.current_value
        except:
            time_per_item = 1
        seconds_remaining = (self.max_value - self.current_value) * time_per_item
        time_remaining = str(datetime.timedelta(seconds=seconds_remaining))
        time_remaining_short = (time_remaining).split(".")[0]
        time_delta_short = str(time_delta).split(".")[0]
        total_time = time_delta + datetime.timedelta(seconds=seconds_remaining)
        total_time_short = str(total_time).split(".")[0]
        self.stat_messages = [
            '{} of {}'.format(self.current_value, self.max_value),
            '{} %'.format(100 * self.current_value // self.max_value),
            '',
            ' {:6.2f} Iterations per Second'.format(self.current_value / total_seconds),
            ' {:6.2f} Seconds per Iteration'.format(total_seconds / (self.current_value if self.current_value else 1)),
            '',
            '{} Elapsed Time'.format(time_delta_short),
            '{} Time Remaining'.format(time_remaining_short),
            '{} Estimated Total Time'.format(total_time_short)]
        return self.stat_messages


def one_line_progress_meter(title, current_value, max_value, *args, key='OK for 1 meter', orientation='v', bar_color=(None, None), button_color=None,
                            size=DEFAULT_PROGRESS_BAR_SIZE, border_width=None, grab_anywhere=False, no_titlebar=False, keep_on_top=None, no_button=False):
    """
    :param title:         text to display in titlebar of window
    :type title:          (str)
    :param current_value: current value
    :type current_value:  (int)
    :param max_value:     max value of progress meter
    :type max_value:      (int)
    :param *args:         stuff to output as text in the window along with the meter
    :type *args:          (Any)
    :param key:           Used to differentiate between multiple meters. Used to cancel meter early. Now optional as there is a default value for single meters
    :type key:            str | int | tuple | object
    :param orientation:   'horizontal' or 'vertical' ('h' or 'v' work) (Default value = 'vertical' / 'v')
    :type orientation:    (str)
    :param bar_color:     The 2 colors that make up a progress bar. Either a tuple of 2 strings or a string. Tuple - (bar, background). A string with 1 color changes the background of the bar only. A string with 2 colors separated by "on" like "red on blue" specifies a red bar on a blue background.
    :type bar_color:      (str, str) | str
    :param button_color:  button color (foreground, background)
    :type button_color:   (str, str) | str
    :param size:          (w,h) w=characters-wide, h=rows-high (Default value = DEFAULT_PROGRESS_BAR_SIZE)
    :type size:           (int, int)
    :param border_width:  width of border around element
    :type border_width:   (int)
    :param grab_anywhere: If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:  (bool)
    :param no_titlebar:   If True: no titlebar will be shown on the window
    :type no_titlebar:    (bool)
    :param keep_on_top:   If True the window will remain above all current windows
    :type keep_on_top:    (bool)
    :param no_button:     If True: window will be created without a cancel button
    :type no_button:      (bool)
    :return:              True if updated successfully. False if user closed the meter with the X or Cancel button
    :rtype:               (bool)
    """
    if key not in _QuickMeter.active_meters:
        meter = _QuickMeter(title, current_value, max_value, key, *args, orientation=orientation, bar_color=bar_color, button_color=button_color, size=size,
                            border_width=border_width, grab_anywhere=grab_anywhere, no_titlebar=no_titlebar, keep_on_top=keep_on_top, no_button=no_button)
        _QuickMeter.active_meters[key] = meter
        _QuickMeter.exit_reasons[key] = None

    else:
        meter = _QuickMeter.active_meters[key]

    rc = meter.UpdateMeter(current_value, max_value, *args)  ### pass the *args to to UpdateMeter function
    OneLineProgressMeter.exit_reasons = getattr(OneLineProgressMeter, 'exit_reasons', _QuickMeter.exit_reasons)
    exit_reason = OneLineProgressMeter.exit_reasons.get(key)

    return METER_OK if exit_reason in (None, METER_REASON_REACHED_MAX) else METER_STOPPED


def one_line_progress_meter_cancel(key='OK for 1 meter'):
    """Cancels and closes a previously created one-line progress meter window

    :param key: Key used when meter was created
    :type key:  (Any)
    :return:    None
    :rtype:     None
    """
    try:
        meter = _QuickMeter.active_meters[key]
        meter.window.Close()
        del (_QuickMeter.active_meters[key])
        _QuickMeter.exit_reasons[key] = METER_REASON_CANCELLED
    except:  # meter is already deleted
        return


def rgb_to_hex(rgb):
    if isinstance(rgb, int):
        return '#%06X' % rgb
    elif isinstance(rgb, (list, tuple)):
        return '#%02X%02X%02X' % (rgb[0], rgb[1], rgb[2])
    else:
        raise ValueError()


def hex_to_rgb(value):
    value = value.strip("#")
    return tuple(int(value[i:i+2], 16) for i in (0, 2, 4))


def hilo(a, b, c):
    if c < b: b, c = c, b
    if b < a: a, b = b, a
    if c < b: b, c = c, b
    return a + c

def complement_color(r, g, b):
    k = hilo(r, g, b)
    return tuple(k - u for u in (r, g, b))

def get_complimentary_hex(color):
    """
    :param color: color string, like "#RRGGBB"
    :type color:  (str)
    :return:      color string, like "#RRGGBB"
    :rtype:       (str)
    """
    rgb = hex_to_rgb(color)
    if rgb in ((0,0,0), (0xFF,0xFF,0xFF), (0,0xFF,0xFF), (0xFF,0,0xFF), (0xFF,0xFF,0)):
        return rgb_to_hex((~rgb[0] & 0xFF, ~rgb[1] & 0xFF, ~rgb[2] & 0xFF))
    return rgb_to_hex(complement_color(rgb[0], rgb[1], rgb[2]))


# ========================  EasyPrint           =====#
# ===================================================#
class _DebugWin():
    debug_window = None

    def __init__(self, size=(None, None), location=(None, None), relative_location=(None, None), font=None, no_titlebar=False, no_button=False,
                 grab_anywhere=False, keep_on_top=None, do_not_reroute_stdout=True, echo_stdout=False, resizable=True, blocking=False):
        """

        :param size:                  (w,h) w=characters-wide, h=rows-high
        :type size:                   (int, int)
        :param location:              Location of upper left corner of the window
        :type location:               (int, int)
        :param relative_location:     (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
        :type relative_location:      (int, int)
        :param font:                  specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
        :type font:                   (str or (str, int[, str]) or None)
        :param no_titlebar:           If True no titlebar will be shown
        :type no_titlebar:            (bool)
        :param no_button:             show button
        :type no_button:              (bool)
        :param grab_anywhere:         If True: can grab anywhere to move the window (Default = False)
        :type grab_anywhere:          (bool)
        :param location:              Location of upper left corner of the window
        :type location:               (int, int)
        :param do_not_reroute_stdout: bool value
        :type do_not_reroute_stdout:  (bool)
        :param echo_stdout:           If True stdout is sent to both the console and the debug window
        :type echo_stdout:            (bool)
        :param resizable:             if True, makes the window resizble
        :type resizable:              (bool)
        :param blocking:              if True, makes the window block instead of returning immediately
        :type blocking:               (bool)
        """
        # Show a form that's a running counter
        self.size = size
        self.location = location
        self.relative_location = relative_location
        self.font = font
        self.no_titlebar = no_titlebar
        self.no_button = no_button
        self.grab_anywhere = grab_anywhere
        self.keep_on_top = keep_on_top
        self.do_not_reroute_stdout = do_not_reroute_stdout
        self.echo_stdout = echo_stdout
        self.resizable = resizable
        self.blocking = blocking

        win_size = size if size != (None, None) else DEFAULT_DEBUG_WINDOW_SIZE
        self.output_element = Multiline(size=win_size, autoscroll=True, auto_refresh=True, reroute_stdout=False if do_not_reroute_stdout else True,
                                        echo_stdout_stderr=self.echo_stdout, reroute_stderr=False if do_not_reroute_stdout else True, expand_x=True, expand_y=True, autoscroll_only_at_bottom=True,
                                        key='-MULTILINE-')
        if no_button:
            self.layout = [[self.output_element]]
        else:
            if blocking:
                self.quit_button = Button('Quit', key='Quit')
            else:
                self.quit_button = DummyButton('Quit', key='Quit')
            self.layout = [[self.output_element],
                           [pin(self.quit_button), pin(B('Pause', key='-PAUSE-')), Stretch()]]

        self.layout[-1] += [Sizegrip()]

        self.window = Window('Debug Window', self.layout, no_titlebar=no_titlebar, auto_size_text=True, location=location, relative_location=relative_location,
                             font=font or ('Courier New', 10), grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, finalize=True, resizable=resizable)
        return

    def reopen_window(self):
        if self.window is None or (self.window is not None and self.window.is_closed()):
            self.__init__(size=self.size, location=self.location, relative_location=self.relative_location, font=self.font, no_titlebar=self.no_titlebar,
                          no_button=self.no_button, grab_anywhere=self.grab_anywhere, keep_on_top=self.keep_on_top,
                          do_not_reroute_stdout=self.do_not_reroute_stdout, resizable=self.resizable, echo_stdout=self.echo_stdout)

    def Print(self, *args, end=None, sep=None, text_color=None, background_color=None, erase_all=False, font=None, blocking=None):
        global SUPPRESS_WIDGET_NOT_FINALIZED_WARNINGS
        suppress = SUPPRESS_WIDGET_NOT_FINALIZED_WARNINGS
        SUPPRESS_WIDGET_NOT_FINALIZED_WARNINGS = True
        sepchar = sep if sep is not None else ' '
        endchar = end if end is not None else '\n'
        self.reopen_window()  # if needed, open the window again

        timeout = 0 if not blocking else None
        if erase_all:
            self.output_element.update('')

        if self.do_not_reroute_stdout:
            end_str = str(end) if end is not None else '\n'
            sep_str = str(sep) if sep is not None else ' '

            outstring = ''
            num_args = len(args)
            for i, arg in enumerate(args):
                outstring += str(arg)
                if i != num_args - 1:
                    outstring += sep_str
            outstring += end_str
            try:
                self.output_element.update(outstring, append=True, text_color_for_value=text_color, background_color_for_value=background_color, font_for_value=font)
            except:
                self.window = None
                self.reopen_window()
                self.output_element.update(outstring, append=True, text_color_for_value=text_color, background_color_for_value=background_color, font_for_value=font)

        else:
            print(*args, sep=sepchar, end=endchar)
        # Changing the button type depending on the blocking parameter.
        #  If blocking, then the "Quit" button should become a normal button.
        if blocking and not self.no_button:
            self.quit_button.BType = BUTTON_TYPE_READ_FORM
            try:  # The window may be closed by user at any time
                self.quit_button.update(text='Click to continue...')
            except:
                self.window = None
        elif not self.no_button:
            self.quit_button.BType = BUTTON_TYPE_CLOSES_WIN_ONLY
            try:  # The window may be closed by user at any time
                self.quit_button.update(text='Quit')
            except:
                self.window = None

        try:  # The window may be closed by user at any time
            if blocking and not self.no_button:
                self.window['-PAUSE-'].update(visible=False)
            elif not self.no_button:
                self.window['-PAUSE-'].update(visible=True)
        except:
            self.window = None

        self.reopen_window()  # if needed, open the window again

        paused = None
        while True:
            event, values = self.window.read(timeout=timeout)

            if event == WIN_CLOSED:
                self.Close()
                break
            elif blocking and event == 'Quit':
                break
            elif not paused and event == TIMEOUT_EVENT and not blocking:
                break
            elif event == '-PAUSE-':
                if blocking or self.no_button:
                    continue
                if paused:
                    self.window['-PAUSE-'].update(text='Pause')
                    self.quit_button.update(visible=True)
                    break
                paused = True
                self.window['-PAUSE-'].update(text='Resume')
                self.quit_button.update(visible=False)
                timeout = None

        SUPPRESS_WIDGET_NOT_FINALIZED_WARNINGS = suppress

    def Close(self):
        if self.window.XFound:  # increment the number of open windows to get around a bug with debug windows
            Window._IncrementOpenCount()
        self.window.close()
        self.window = None


def easy_print(*args, size=(None, None), end=None, sep=None, location=(None, None), relative_location=(None, None), font=None, no_titlebar=False,
               no_button=False, grab_anywhere=False, keep_on_top=None, do_not_reroute_stdout=True, echo_stdout=False, text_color=None, background_color=None, colors=None, c=None,
               erase_all=False, resizable=True, blocking=None, wait=None):
    """Works like a `print` statement but with windowing options

    Routes output to the debug window.

    In addition to the normal text and background colors, you can use a "colors" tuple/string
    The "colors" or "c" parameter defines both the text and background in a single parm.
    It can be a tuple or a single single. Both text and background colors need to be specified
    colors - (str, str) | str.  A combined text/background color definition in a single parameter
    c - (str, str) - Colors tuple has format (foreground, backgrouned)
    c - str - can also be a string of the format "foreground on background"  ("white on red")

    :param *args:                 stuff to output
    :type *args:                  (Any)
    :param size:                  (w,h) w=characters-wide, h=rows-high
    :type size:                   (int, int)
    :param end:                   end character
    :type end:                    (str)
    :param sep:                   separator character
    :type sep:                    (str)
    :param location:              Location of upper left corner of the window
    :type location:               (int, int)
    :param relative_location:     (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:      (int, int)
    :param font:                  specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                   (str or (str, int[, str]) or None)
    :param no_titlebar:           If True no titlebar will be shown
    :type no_titlebar:            (bool)
    :param no_button:             don't show button
    :type no_button:              (bool)
    :param grab_anywhere:         If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:          (bool)
    :param background_color:      color of background
    :type background_color:       (str)
    :param text_color:            color of the text
    :type text_color:             (str)
    :param keep_on_top:           If True the window will remain above all current windows
    :type keep_on_top:            (bool)
    :param location:              Location of upper left corner of the window
    :type location:               (int, int)
    :param do_not_reroute_stdout: do not reroute stdout and stderr. If False, both stdout and stderr will reroute to here
    :type do_not_reroute_stdout:  (bool)
    :param echo_stdout:           If True stdout is sent to both the console and the debug window
    :type echo_stdout:            (bool)
    :param colors:                Either a tuple or a string that has both the text and background colors
    :type colors:                 (str) or (str, str)
    :param c:                     Either a tuple or a string that has both the text and background colors
    :type c:                      (str) or (str, str)
    :param resizable:             if True, the user can resize the debug window. Default is True
    :type resizable:              (bool)
    :param erase_all:             If True when erase the output before printing
    :type erase_all:              (bool)
    :param blocking:              if True, makes the window block instead of returning immediately. The "Quit" button changers to "More"
    :type blocking:               (bool | None)
    :param wait:                  Same as the "blocking" parm. It's an alias.  if True, makes the window block instead of returning immediately. The "Quit" button changes to "Click to Continue..."
    :type wait:                   (bool | None)
    :return:
    :rtype:
    """
    blocking = blocking or wait
    if _DebugWin.debug_window is None:
        _DebugWin.debug_window = _DebugWin(size=size, location=location, relative_location=relative_location, font=font, no_titlebar=no_titlebar,
                                           no_button=no_button, grab_anywhere=grab_anywhere, keep_on_top=keep_on_top,
                                           do_not_reroute_stdout=do_not_reroute_stdout, echo_stdout=echo_stdout, resizable=resizable, blocking=blocking)
    txt_color, bg_color = _parse_colors_parm(c or colors)
    _DebugWin.debug_window.Print(*args, end=end, sep=sep, text_color=text_color or txt_color, background_color=background_color or bg_color,
                                 erase_all=erase_all, font=font, blocking=blocking)


def easy_print_close():
    """Closes a previously opened easy print window

    :return:
    :rtype:
    """
    if _DebugWin.debug_window is not None:
        _DebugWin.debug_window.Close()
        _DebugWin.debug_window = None


#                            d8b          888
#                            Y8P          888
#                                         888
#   .d8888b 88888b.  888d888 888 88888b.  888888
#  d88P"    888 "88b 888P"   888 888 "88b 888
#  888      888  888 888     888 888  888 888
#  Y88b.    888 d88P 888     888 888  888 Y88b.
#   "Y8888P 88888P"  888     888 888  888  "Y888
#           888
#           888
#           888


CPRINT_DESTINATION_WINDOW = None
CPRINT_DESTINATION_MULTILINE_ELMENT_KEY = None


def cprint_set_output_destination(window, multiline_key):
    """Sets up the color print (cprint) output destination

    :param window:        The window that the cprint call will route the output to
    :type window:         (Window)
    :param multiline_key: Key for the Multiline Element where output will be sent
    :type multiline_key:  (Any)
    :return:              None
    :rtype:               None
    """
    global CPRINT_DESTINATION_WINDOW, CPRINT_DESTINATION_MULTILINE_ELMENT_KEY

    CPRINT_DESTINATION_WINDOW = window
    CPRINT_DESTINATION_MULTILINE_ELMENT_KEY = multiline_key


def cprint(*args, end=None, sep=' ', text_color=None, font=None, t=None, background_color=None, b=None, colors=None, c=None, window=None, key=None,
           justification=None, autoscroll=True, erase_all=False):
    """Color print to a multiline element in a window of your choice

    Must have EITHER called cprint_set_output_destination prior to making this call so that the
    window and element key can be saved and used here to route the output, OR used the window
    and key parameters to the cprint function to specicy these items.

    args is a variable number of things you want to print.

    end - The end char to use just like print uses
    sep - The separation character like print uses
    text_color - The color of the text
            key - overrides the previously defined Multiline key
    window - overrides the previously defined window to output to
    background_color - The color of the background
    colors -(str, str) | str.  A combined text/background color definition in a single parameter

    There are also "aliases" for text_color, background_color and colors (t, b, c):
     t - An alias for color of the text (makes for shorter calls)
     b - An alias for the background_color parameter
     c - (str, str) - "shorthand" way of specifying color. (foreground, backgrouned)
     c - str - can also be a string of the format "foreground on background"  ("white on red")

    With the aliases it's possible to write the same print but in more compact ways:
    cprint('This will print white text on red background', c=('white', 'red'))
    cprint('This will print white text on red background', c='white on red')
    cprint('This will print white text on red background', text_color='white', background_color='red')
    cprint('This will print white text on red background', t='white', b='red')

    :param *args:            stuff to output
    :type *args:             (Any)
    :param text_color:       Color of the text
    :type text_color:        (str)
    :param font:             specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike for the value being updated
    :type font:              (str or (str, int[, str]) or None)
    :param background_color: The background color of the line
    :type background_color:  (str)
    :param colors:           Either a tuple or a string that has both the text and background colors "text on background" or just the text color
    :type colors:            (str) or (str, str)
    :param t:                Color of the text
    :type t:                 (str)
    :param b:                The background color of the line
    :type b:                 (str)
    :param c:                Either a tuple or a string.  Same as the color parm
    :type c:                 (str) or (str, str)
    :param end:              end character
    :type end:               (str)
    :param sep:              separator character
    :type sep:               (str)
    :param key:              key of multiline to output to (if you want to override the one previously set)
    :type key:               (Any)
    :param window:           Window containing the multiline to output to (if you want to override the one previously set)
    :type window:            (Window)
    :param justification:    text justification. left, right, center. Can use single characters l, r, c. Sets only for this value, not entire element
    :type justification:     (str)
    :param autoscroll:       If True the contents of the element will automatically scroll as more data added to the end
    :type autoscroll:        (bool)
    :param erase_all         If True the contents of the element will be cleared before printing happens
    :type erase_all          (bool)
    """

    destination_key = CPRINT_DESTINATION_MULTILINE_ELMENT_KEY if key is None else key
    destination_window = window or CPRINT_DESTINATION_WINDOW

    if (destination_window is None and window is None) or (destination_key is None and key is None):
        print('** Warning ** Attempting to perform a cprint without a valid window & key',
              'Will instead print on Console',
              'You can specify window and key in this cprint call, or set ahead of time with cprint_set_output_destination')
        print(*args)
        return

    kw_text_color = text_color or t
    kw_background_color = background_color or b
    dual_color = colors or c
    try:
        if isinstance(dual_color, tuple):
            kw_text_color = dual_color[0]
            kw_background_color = dual_color[1]
        elif isinstance(dual_color, str):
            if ' on ' in dual_color:  # if has "on" in the string, then have both text and background
                kw_text_color = dual_color.split(' on ')[0]
                kw_background_color = dual_color.split(' on ')[1]
            else:  # if no "on" then assume the color string is just the text color
                kw_text_color = dual_color
    except Exception as e:
        print('* cprint warning * you messed up with color formatting', e)

    mline = destination_window.find_element(destination_key, silent_on_error=True)  # type: Multiline
    try:
        # mline = destination_window[destination_key]     # type: Multiline
        if erase_all is True:
            mline.update('')
        if end is None:
            mline.print(*args, text_color=kw_text_color, background_color=kw_background_color, end='', sep=sep, justification=justification, font=font,
                        autoscroll=autoscroll)
            mline.print('', justification=justification, autoscroll=autoscroll)
        else:
            mline.print(*args, text_color=kw_text_color, background_color=kw_background_color, end=end, sep=sep, justification=justification, font=font,
                        autoscroll=autoscroll)
    except Exception as e:
        print('** cprint error trying to print to the multiline. Printing to console instead **', e)
        print(*args, end=end, sep=sep)


# ------------------------------------------------------------------------------------------------ #
# A print-like call that can be used to output to a multiline element as if it's an Output element #
# ------------------------------------------------------------------------------------------------ #

def _print_to_element(multiline_element, *args, end=None, sep=None, text_color=None, background_color=None, autoscroll=None, justification=None, font=None):
    """Print like Python normally prints except route the output
        to a multiline element and also add colors if desired

    :param multiline_element: The multiline element to be output to
    :type multiline_element:  (Multiline)
    :param args:              The arguments to print
    :type args:               List[Any]
    :param end:               The end char to use just like print uses
    :type end:                (str)
    :param sep:               The separation character like print uses
    :type sep:                (str)
    :param text_color:        color of the text
    :type text_color:         (str)
    :param background_color:  The background color of the line
    :type background_color:   (str)
    :param autoscroll:        If True (the default), the element will scroll to bottom after updating
    :type autoscroll:         (bool)
    :param font:              specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike for the value being updated
    :type font:               str | (str, int)
    """
    end_str = str(end) if end is not None else '\n'
    sep_str = str(sep) if sep is not None else ' '

    outstring = ''
    num_args = len(args)
    for i, arg in enumerate(args):
        outstring += str(arg)
        if i != num_args - 1:
            outstring += sep_str
    outstring += end_str

    multiline_element.update(outstring, append=True, text_color_for_value=text_color, background_color_for_value=background_color, autoscroll=autoscroll,
                             justification=justification, font_for_value=font)

    try:  # if the element is set to autorefresh, then refresh the parent window
        if multiline_element.AutoRefresh:
            multiline_element.ParentForm.refresh()
    except:
        pass


def _parse_colors_parm(colors):
    """Parse a colors parameter into its separate colors

    Some functions accept a dual colors string/tuple.
    This function parses the parameter into the component colors.

    :param colors: Either a tuple or a string that has both the text and background colors
    :type colors:  (str) or (str, str)
    :return:       tuple with the individual text and background colors
    :rtype:        (str, str)
    """
    if colors is None:
        return None, None
    dual_color = colors
    kw_text_color = kw_background_color = None
    try:
        if isinstance(dual_color, tuple):
            kw_text_color = dual_color[0]
            kw_background_color = dual_color[1]
        elif isinstance(dual_color, str):
            if ' on ' in dual_color:  # if has "on" in the string, then have both text and background
                kw_text_color = dual_color.split(' on ')[0]
                kw_background_color = dual_color.split(' on ')[1]
            else:  # if no "on" then assume the color string is just the text color
                kw_text_color = dual_color
    except Exception as e:
        print('* warning * you messed up with color formatting', e)

    return kw_text_color, kw_background_color


# ============================== set_global_icon ====#
# Sets the icon to be used by default                #
# ===================================================#
def set_global_icon(icon):
    """Sets the icon which will be used any time a window is created
        if an icon is not provided when the window is created

    :param icon: Either a Base64 byte string or a filename
    :type icon:  bytes | str
    """
    Window._user_defined_icon = icon


# ============================== set_options ========#
# Sets the icon to be used by default                #
# ===================================================#
def set_options(icon=None, button_color=None, element_size=(None, None), button_element_size=(None, None),
                margins=(None, None),
                element_padding=(None, None), auto_size_text=None, auto_size_buttons=None, font=None, border_width=None,
                slider_border_width=None, slider_relief=None, slider_orientation=None,
                autoclose_time=None, message_box_line_width=None,
                progress_meter_border_depth=None, progress_meter_style=None,
                progress_meter_relief=None, progress_meter_color=None, progress_meter_size=None,
                text_justification=None, background_color=None, element_background_color=None,
                text_element_background_color=None, input_elements_background_color=None, input_text_color=None,
                scrollbar_color=None, text_color=None, element_text_color=None, debug_win_size=(None, None),
                window_location=(None, None), error_button_color=(None, None), tooltip_time=None, tooltip_font=None, use_ttk_buttons=None, ttk_theme=None,
                suppress_error_popups=None, suppress_raise_key_errors=None, suppress_key_guessing=None,warn_button_key_duplicates=False, enable_treeview_869_patch=None,
                enable_mac_notitlebar_patch=None, use_custom_titlebar=None, titlebar_background_color=None, titlebar_text_color=None, titlebar_font=None,
                titlebar_icon=None, user_settings_path=None, freesimplegui_settings_path=None, freesimplegui_settings_filename=None, keep_on_top=None, dpi_awareness=None, scaling=None, disable_modal_windows=None, force_modal_windows=None, tooltip_offset=(None, None),
                sbar_trough_color=None, sbar_background_color=None, sbar_arrow_color=None, sbar_width=None, sbar_arrow_width=None, sbar_frame_color=None, sbar_relief=None, alpha_channel=None,
                hide_window_when_creating=None, use_button_shortcuts=None, watermark_text=None, win_app_id=None):
    """
    :param icon:                            Can be either a filename or Base64 value. For Windows if filename, it MUST be ICO format. For Linux, must NOT be ICO. Most portable is to use a Base64 of a PNG file. This works universally across all OS's
    :type icon:                             bytes | str
    :param button_color:                    Color of the button (text, background)
    :type button_color:                     (str, str) | str
    :param element_size:                    element size (width, height) in characters
    :type element_size:                     (int, int)
    :param button_element_size:             Size of button
    :type button_element_size:              (int, int)
    :param margins:                         (left/right, top/bottom) tkinter margins around outsize. Amount of pixels to leave inside the window's frame around the edges before your elements are shown.
    :type margins:                          (int, int)
    :param element_padding:                 Default amount of padding to put around elements in window (left/right, top/bottom) or ((left, right), (top, bottom))
    :type element_padding:                  (int, int) or ((int, int),(int,int))
    :param auto_size_text:                  True if the Widget should be shrunk to exactly fit the number of chars to show
    :type auto_size_text:                   bool
    :param auto_size_buttons:               True if Buttons in this Window should be sized to exactly fit the text on this.
    :type auto_size_buttons:                (bool)
    :param font:                            specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                             (str or (str, int[, str]) or None)
    :param border_width:                    width of border around element
    :type border_width:                     (int)
    :param slider_border_width:             Width of the border around sliders
    :type slider_border_width:              (int)
    :param slider_relief:                   Type of relief to use for sliders
    :type slider_relief:                    (str)
    :param slider_orientation:              ???
    :type slider_orientation:               ???
    :param autoclose_time:                  ???
    :type autoclose_time:                   ???
    :param message_box_line_width:          ???
    :type message_box_line_width:           ???
    :param progress_meter_border_depth:     ???
    :type progress_meter_border_depth:      ???
    :param progress_meter_style:            You can no longer set a progress bar style. All ttk styles must be the same for the window
    :type progress_meter_style:             ???
    :param progress_meter_relief:
    :type progress_meter_relief:            ???
    :param progress_meter_color:            ???
    :type progress_meter_color:             ???
    :param progress_meter_size:             ???
    :type progress_meter_size:              ???
    :param text_justification:              Default text justification for all Text Elements in window
    :type text_justification:               'left' | 'right' | 'center'
    :param background_color:                color of background
    :type background_color:                 (str)
    :param element_background_color:        element background color
    :type element_background_color:         (str)
    :param text_element_background_color:   text element background color
    :type text_element_background_color:    (str)
    :param input_elements_background_color: Default color to use for the background of input elements
    :type input_elements_background_color:  (str)
    :param input_text_color:                Default color to use for the text for Input elements
    :type input_text_color:                 (str)
    :param scrollbar_color:                 Default color to use for the slider trough
    :type scrollbar_color:                  (str)
    :param text_color:                      color of the text
    :type text_color:                       (str)
    :param element_text_color:              Default color to use for Text elements
    :type element_text_color:               (str)
    :param debug_win_size:                  window size
    :type debug_win_size:                   (int, int)
    :param window_location:                 Default location to place windows. Not setting will center windows on the display
    :type window_location:                  (int, int) | None
    :param error_button_color:              (Default = (None))
    :type error_button_color:               ???
    :param tooltip_time:                    time in milliseconds to wait before showing a tooltip. Default is 400ms
    :type tooltip_time:                     (int)
    :param tooltip_font:                    font to use for all tooltips
    :type tooltip_font:                     str or Tuple[str, int] or Tuple[str, int, str]
    :param use_ttk_buttons:                 if True will cause all buttons to be ttk buttons
    :type use_ttk_buttons:                  (bool)
    :param ttk_theme:                       Theme to use with ttk widgets.  Choices (on Windows) include - 'default', 'winnative', 'clam', 'alt', 'classic', 'vista', 'xpnative'
    :type ttk_theme:                        (str)
    :param suppress_error_popups:           If True then error popups will not be shown if generated internally to FreeSimpleGUI
    :type suppress_error_popups:            (bool)
    :param suppress_raise_key_errors:       If True then key errors won't be raised (you'll still get popup error)
    :type suppress_raise_key_errors:        (bool)
    :param suppress_key_guessing:           If True then key errors won't try and find closest matches for you
    :type suppress_key_guessing:            (bool)
    :param warn_button_key_duplicates:      If True then duplicate Button Keys generate warnings (not recommended as they're expected)
    :type warn_button_key_duplicates:       (bool)
    :param enable_treeview_869_patch:       If True, then will use the treeview color patch for tk 8.6.9
    :type enable_treeview_869_patch:        (bool)
    :param enable_mac_notitlebar_patch:     If True then Windows with no titlebar use an alternative technique when tkinter version < 8.6.10
    :type enable_mac_notitlebar_patch:      (bool)
    :param use_custom_titlebar:             If True then a custom titlebar is used instead of the normal system titlebar
    :type use_custom_titlebar:              (bool)
    :param titlebar_background_color:       If custom titlebar indicated by use_custom_titlebar, then use this as background color
    :type titlebar_background_color:        str | None
    :param titlebar_text_color:             If custom titlebar indicated by use_custom_titlebar, then use this as text color
    :type titlebar_text_color:              str | None
    :param titlebar_font:                   If custom titlebar indicated by use_custom_titlebar, then use this as title font
    :type titlebar_font:                    (str or (str, int[, str]) or None) | None
    :param titlebar_icon:                   If custom titlebar indicated by use_custom_titlebar, then use this as the icon (file or base64 bytes)
    :type titlebar_icon:                    bytes | str
    :param user_settings_path:              default path for user_settings API calls. Expanded with os.path.expanduser so can contain ~ to represent user
    :type user_settings_path:               (str)
    :param freesimplegui_settings_path:       default path for the global FreeSimpleGUI user_settings
    :type freesimplegui_settings_path:        (str)
    :param freesimplegui_settings_filename:   default filename for the global FreeSimpleGUI user_settings
    :type freesimplegui_settings_filename:    (str)
    :param keep_on_top:                     If True then all windows will automatically be set to keep_on_top=True
    :type keep_on_top:                      (bool)
    :param dpi_awareness:                   If True then will turn on DPI awareness (Windows only at the moment)
    :type dpi_awareness:                    (bool)
    :param scaling:                         Sets the default scaling for all windows including popups, etc.
    :type scaling:                          (float)
    :param disable_modal_windows:           If True then all windows, including popups, will not be modal windows (unless they've been set to FORCED using another option)
    :type disable_modal_windows:            (bool)
    :param force_modal_windows:             If True then all windows will be modal (the disable option will be ignored... all windows will be forced to be modal)
    :type force_modal_windows:              (bool)
    :param tooltip_offset:                  Offset to use for tooltips as a tuple. These values will be added to the mouse location when the widget was entered.
    :type tooltip_offset:                   ((None, None) | (int, int))
    :param sbar_trough_color:               Scrollbar color of the trough
    :type sbar_trough_color:                (str)
    :param sbar_background_color:           Scrollbar color of the background of the arrow buttons at the ends AND the color of the "thumb" (the thing you grab and slide). Switches to arrow color when mouse is over
    :type sbar_background_color:            (str)
    :param sbar_arrow_color:                Scrollbar color of the arrow at the ends of the scrollbar (it looks like a button). Switches to background color when mouse is over
    :type sbar_arrow_color:                 (str)
    :param sbar_width:                      Scrollbar width in pixels
    :type sbar_width:                       (int)
    :param sbar_arrow_width:                Scrollbar width of the arrow on the scrollbar. It will potentially impact the overall width of the scrollbar
    :type sbar_arrow_width:                 (int)
    :param sbar_frame_color:                Scrollbar Color of frame around scrollbar (available only on some ttk themes)
    :type sbar_frame_color:                 (str)
    :param sbar_relief:                     Scrollbar relief that will be used for the "thumb" of the scrollbar (the thing you grab that slides). Should be a constant that is defined at starting with "RELIEF_" - RELIEF_RAISED, RELIEF_SUNKEN, RELIEF_FLAT, RELIEF_RIDGE, RELIEF_GROOVE, RELIEF_SOLID
    :type sbar_relief:                      (str)
    :param alpha_channel:                   Default alpha channel to be used on all windows
    :type alpha_channel:                    (float)
    :param hide_window_when_creating:       If True then alpha will be set to 0 while a window is made and moved to location indicated
    :type hide_window_when_creating:        (bool)
    :param use_button_shortcuts:            If True then Shortcut Char will be used with Buttons
    :type use_button_shortcuts:             (bool)
    :param watermark_text:                  Set the text that will be used if a window is watermarked
    :type watermark_text:                   (str)
    :param win_app_id:                      For Windows only. Sets string that's passed to Windows to control combining icons on taskbar. Default is " mycompany.myproduct.subproduct.version". Windows with same ID combine on taskbar. Change before creating a window to set that window's ID.
    :type win_app_id:                       (str)
    :return:                                None
    :rtype:                                 None
    """

    global DEFAULT_ELEMENT_SIZE
    global DEFAULT_BUTTON_ELEMENT_SIZE
    global DEFAULT_MARGINS  # Margins for each LEFT/RIGHT margin is first term
    global DEFAULT_ELEMENT_PADDING  # Padding between elements (row, col) in pixels
    global DEFAULT_AUTOSIZE_TEXT
    global DEFAULT_AUTOSIZE_BUTTONS
    global DEFAULT_FONT
    global DEFAULT_BORDER_WIDTH
    global DEFAULT_AUTOCLOSE_TIME
    global DEFAULT_BUTTON_COLOR
    global MESSAGE_BOX_LINE_WIDTH
    global DEFAULT_PROGRESS_BAR_BORDER_WIDTH
    global DEFAULT_PROGRESS_BAR_STYLE
    global DEFAULT_PROGRESS_BAR_RELIEF
    global DEFAULT_PROGRESS_BAR_COLOR
    global DEFAULT_PROGRESS_BAR_SIZE
    global DEFAULT_TEXT_JUSTIFICATION
    global DEFAULT_DEBUG_WINDOW_SIZE
    global DEFAULT_SLIDER_BORDER_WIDTH
    global DEFAULT_SLIDER_RELIEF
    global DEFAULT_SLIDER_ORIENTATION
    global DEFAULT_BACKGROUND_COLOR
    global DEFAULT_INPUT_ELEMENTS_COLOR
    global DEFAULT_ELEMENT_BACKGROUND_COLOR
    global DEFAULT_TEXT_ELEMENT_BACKGROUND_COLOR
    global DEFAULT_SCROLLBAR_COLOR
    global DEFAULT_TEXT_COLOR
    global DEFAULT_WINDOW_LOCATION
    global DEFAULT_ELEMENT_TEXT_COLOR
    global DEFAULT_INPUT_TEXT_COLOR
    global DEFAULT_TOOLTIP_TIME
    global DEFAULT_ERROR_BUTTON_COLOR
    global DEFAULT_TTK_THEME
    global USE_TTK_BUTTONS
    global TOOLTIP_FONT
    global SUPPRESS_ERROR_POPUPS
    global SUPPRESS_RAISE_KEY_ERRORS
    global SUPPRESS_KEY_GUESSING
    global WARN_DUPLICATE_BUTTON_KEY_ERRORS
    global ENABLE_TREEVIEW_869_PATCH
    global ENABLE_MAC_NOTITLEBAR_PATCH
    global USE_CUSTOM_TITLEBAR
    global CUSTOM_TITLEBAR_BACKGROUND_COLOR
    global CUSTOM_TITLEBAR_TEXT_COLOR
    global CUSTOM_TITLEBAR_ICON
    global CUSTOM_TITLEBAR_FONT
    global DEFAULT_USER_SETTINGS_PATH
    global DEFAULT_USER_SETTINGS_FREESIMPLEGUI_PATH
    global DEFAULT_USER_SETTINGS_FREESIMPLEGUI_FILENAME
    global DEFAULT_KEEP_ON_TOP
    global DEFAULT_SCALING
    global DEFAULT_MODAL_WINDOWS_ENABLED
    global DEFAULT_MODAL_WINDOWS_FORCED
    global DEFAULT_TOOLTIP_OFFSET
    global DEFAULT_ALPHA_CHANNEL
    global _freesimplegui_user_settings
    global ttk_part_overrides_from_options
    global DEFAULT_HIDE_WINDOW_WHEN_CREATING
    global DEFAULT_USE_BUTTON_SHORTCUTS
    # global _my_windows

    if icon:
        Window._user_defined_icon = icon

    if button_color != None:
        if button_color == COLOR_SYSTEM_DEFAULT:
            DEFAULT_BUTTON_COLOR = (COLOR_SYSTEM_DEFAULT, COLOR_SYSTEM_DEFAULT)
        else:
            DEFAULT_BUTTON_COLOR = button_color

    if element_size != (None, None):
        DEFAULT_ELEMENT_SIZE = element_size

    if button_element_size != (None, None):
        DEFAULT_BUTTON_ELEMENT_SIZE = button_element_size

    if margins != (None, None):
        DEFAULT_MARGINS = margins

    if element_padding != (None, None):
        DEFAULT_ELEMENT_PADDING = element_padding

    if auto_size_text != None:
        DEFAULT_AUTOSIZE_TEXT = auto_size_text

    if auto_size_buttons != None:
        DEFAULT_AUTOSIZE_BUTTONS = auto_size_buttons

    if font != None:
        DEFAULT_FONT = font

    if border_width != None:
        DEFAULT_BORDER_WIDTH = border_width

    if autoclose_time != None:
        DEFAULT_AUTOCLOSE_TIME = autoclose_time

    if message_box_line_width != None:
        MESSAGE_BOX_LINE_WIDTH = message_box_line_width

    if progress_meter_border_depth != None:
        DEFAULT_PROGRESS_BAR_BORDER_WIDTH = progress_meter_border_depth

    if progress_meter_style != None:
        warnings.warn('You can no longer set a progress bar style. All ttk styles must be the same for the window', UserWarning)

    if progress_meter_relief != None:
        DEFAULT_PROGRESS_BAR_RELIEF = progress_meter_relief

    if progress_meter_color != None:
        DEFAULT_PROGRESS_BAR_COLOR = progress_meter_color

    if progress_meter_size != None:
        DEFAULT_PROGRESS_BAR_SIZE = progress_meter_size

    if slider_border_width != None:
        DEFAULT_SLIDER_BORDER_WIDTH = slider_border_width

    if slider_orientation != None:
        DEFAULT_SLIDER_ORIENTATION = slider_orientation

    if slider_relief != None:
        DEFAULT_SLIDER_RELIEF = slider_relief

    if text_justification != None:
        DEFAULT_TEXT_JUSTIFICATION = text_justification

    if background_color != None:
        DEFAULT_BACKGROUND_COLOR = background_color

    if text_element_background_color != None:
        DEFAULT_TEXT_ELEMENT_BACKGROUND_COLOR = text_element_background_color

    if input_elements_background_color != None:
        DEFAULT_INPUT_ELEMENTS_COLOR = input_elements_background_color

    if element_background_color != None:
        DEFAULT_ELEMENT_BACKGROUND_COLOR = element_background_color

    if window_location != (None, None):
        DEFAULT_WINDOW_LOCATION = window_location

    if debug_win_size != (None, None):
        DEFAULT_DEBUG_WINDOW_SIZE = debug_win_size

    if text_color != None:
        DEFAULT_TEXT_COLOR = text_color

    if scrollbar_color != None:
        DEFAULT_SCROLLBAR_COLOR = scrollbar_color

    if element_text_color != None:
        DEFAULT_ELEMENT_TEXT_COLOR = element_text_color

    if input_text_color is not None:
        DEFAULT_INPUT_TEXT_COLOR = input_text_color

    if tooltip_time is not None:
        DEFAULT_TOOLTIP_TIME = tooltip_time

    if error_button_color != (None, None):
        DEFAULT_ERROR_BUTTON_COLOR = error_button_color

    if ttk_theme is not None:
        DEFAULT_TTK_THEME = ttk_theme

    if use_ttk_buttons is not None:
        USE_TTK_BUTTONS = use_ttk_buttons

    if tooltip_font is not None:
        TOOLTIP_FONT = tooltip_font

    if suppress_error_popups is not None:
        SUPPRESS_ERROR_POPUPS = suppress_error_popups

    if suppress_raise_key_errors is not None:
        SUPPRESS_RAISE_KEY_ERRORS = suppress_raise_key_errors

    if suppress_key_guessing is not None:
        SUPPRESS_KEY_GUESSING = suppress_key_guessing

    if warn_button_key_duplicates is not None:
        WARN_DUPLICATE_BUTTON_KEY_ERRORS = warn_button_key_duplicates

    if enable_treeview_869_patch is not None:
        ENABLE_TREEVIEW_869_PATCH = enable_treeview_869_patch

    if enable_mac_notitlebar_patch is not None:
        ENABLE_MAC_NOTITLEBAR_PATCH = enable_mac_notitlebar_patch

    if use_custom_titlebar is not None:
        USE_CUSTOM_TITLEBAR = use_custom_titlebar

    if titlebar_background_color is not None:
        CUSTOM_TITLEBAR_BACKGROUND_COLOR = titlebar_background_color

    if titlebar_text_color is not None:
        CUSTOM_TITLEBAR_TEXT_COLOR = titlebar_text_color

    if titlebar_font is not None:
        CUSTOM_TITLEBAR_FONT = titlebar_font

    if titlebar_icon is not None:
        CUSTOM_TITLEBAR_ICON = titlebar_icon

    if user_settings_path is not None:
        DEFAULT_USER_SETTINGS_PATH = user_settings_path

    if freesimplegui_settings_path is not None:
        DEFAULT_USER_SETTINGS_FREESIMPLEGUI_PATH = freesimplegui_settings_path

    if freesimplegui_settings_filename is not None:
        DEFAULT_USER_SETTINGS_FREESIMPLEGUI_FILENAME = freesimplegui_settings_filename

    if freesimplegui_settings_filename is not None or freesimplegui_settings_filename is not None:
        _freesimplegui_user_settings = UserSettings(
            filename=DEFAULT_USER_SETTINGS_FREESIMPLEGUI_FILENAME,
            path=DEFAULT_USER_SETTINGS_FREESIMPLEGUI_PATH
        )

    if keep_on_top is not None:
        DEFAULT_KEEP_ON_TOP = keep_on_top

    if dpi_awareness is True:
        if running_windows():
            if platform.release() == "7":
                ctypes.windll.user32.SetProcessDPIAware()
            elif platform.release() == "8" or platform.release() == "10":
                ctypes.windll.shcore.SetProcessDpiAwareness(1)

    if scaling is not None:
        DEFAULT_SCALING = scaling

    if disable_modal_windows is not None:
        DEFAULT_MODAL_WINDOWS_ENABLED = not disable_modal_windows

    if force_modal_windows is not None:
        DEFAULT_MODAL_WINDOWS_FORCED = force_modal_windows

    if tooltip_offset != (None, None):
        DEFAULT_TOOLTIP_OFFSET = tooltip_offset

    if alpha_channel is not None:
        DEFAULT_ALPHA_CHANNEL = alpha_channel

    # ---------------- ttk scrollbar section ----------------
    if sbar_background_color is not None:
        ttk_part_overrides_from_options.sbar_background_color = sbar_background_color

    if sbar_trough_color is not None:
        ttk_part_overrides_from_options.sbar_trough_color = sbar_trough_color

    if sbar_arrow_color is not None:
        ttk_part_overrides_from_options.sbar_arrow_color = sbar_arrow_color

    if sbar_frame_color is not None:
        ttk_part_overrides_from_options.sbar_frame_color = sbar_frame_color

    if sbar_relief is not None:
        ttk_part_overrides_from_options.sbar_relief = sbar_relief

    if sbar_arrow_width is not None:
        ttk_part_overrides_from_options.sbar_arrow_width = sbar_arrow_width

    if sbar_width is not None:
        ttk_part_overrides_from_options.sbar_width = sbar_width

    if hide_window_when_creating is not None:
        DEFAULT_HIDE_WINDOW_WHEN_CREATING = hide_window_when_creating

    if use_button_shortcuts is not None:
        DEFAULT_USE_BUTTON_SHORTCUTS = use_button_shortcuts

    if watermark_text is not None:
        Window._watermark_user_text = watermark_text

    if win_app_id is not None:
        # Enables the correct application icon to be shown on the Windows taskbar
        if running_windows():
            try:
                ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(win_app_id)
            except Exception as e:
                print('Error setting App ID', e)

    return True

# ----------------------------------------------------------------- #

# .########.##.....##.########.##.....##.########..######.
# ....##....##.....##.##.......###...###.##.......##....##
# ....##....##.....##.##.......####.####.##.......##......
# ....##....#########.######...##.###.##.######....######.
# ....##....##.....##.##.......##.....##.##.............##
# ....##....##.....##.##.......##.....##.##.......##....##
# ....##....##.....##.########.##.....##.########..######.

# ----------------------------------------------------------------- #

# The official Theme code

#################### ChangeLookAndFeel #######################
# Predefined settings that will change the colors and styles #
# of the elements.                                           #
##############################################################
LOOK_AND_FEEL_TABLE = {
    "SystemDefault": {"BACKGROUND": COLOR_SYSTEM_DEFAULT, "TEXT": COLOR_SYSTEM_DEFAULT, "INPUT": COLOR_SYSTEM_DEFAULT, "TEXT_INPUT": COLOR_SYSTEM_DEFAULT,
                      "SCROLL": COLOR_SYSTEM_DEFAULT, "BUTTON": OFFICIAL_FREESIMPLEGUI_BUTTON_COLOR, "PROGRESS": COLOR_SYSTEM_DEFAULT, "BORDER": 1,
                      "SLIDER_DEPTH": 1, "PROGRESS_DEPTH": 0, },
    "SystemDefaultForReal": {"BACKGROUND": COLOR_SYSTEM_DEFAULT, "TEXT": COLOR_SYSTEM_DEFAULT, "INPUT": COLOR_SYSTEM_DEFAULT,
                             "TEXT_INPUT": COLOR_SYSTEM_DEFAULT, "SCROLL": COLOR_SYSTEM_DEFAULT, "BUTTON": COLOR_SYSTEM_DEFAULT,
                             "PROGRESS": COLOR_SYSTEM_DEFAULT, "BORDER": 1, "SLIDER_DEPTH": 1, "PROGRESS_DEPTH": 0, },
    "SystemDefault1": {"BACKGROUND": COLOR_SYSTEM_DEFAULT, "TEXT": COLOR_SYSTEM_DEFAULT, "INPUT": COLOR_SYSTEM_DEFAULT, "TEXT_INPUT": COLOR_SYSTEM_DEFAULT,
                       "SCROLL": COLOR_SYSTEM_DEFAULT, "BUTTON": COLOR_SYSTEM_DEFAULT, "PROGRESS": COLOR_SYSTEM_DEFAULT, "BORDER": 1, "SLIDER_DEPTH": 1,
                       "PROGRESS_DEPTH": 0, },
    "Material1": {"BACKGROUND": "#E3F2FD", "TEXT": "#000000", "INPUT": "#86A8FF", "TEXT_INPUT": "#000000", "SCROLL": "#86A8FF",
                  "BUTTON": ("#FFFFFF", "#5079D3"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 0, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "ACCENT1": "#FF0266", "ACCENT2": "#FF5C93", "ACCENT3": "#C5003C", },
    "Material2": {"BACKGROUND": "#FAFAFA", "TEXT": "#000000", "INPUT": "#004EA1", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#5EA7FF",
                  "BUTTON": ("#FFFFFF", "#0079D3"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 0, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "ACCENT1": "#FF0266", "ACCENT2": "#FF5C93", "ACCENT3": "#C5003C", },
    "Reddit": {"BACKGROUND": "#ffffff", "TEXT": "#1a1a1b", "INPUT": "#dae0e6", "TEXT_INPUT": "#222222", "SCROLL": "#a5a4a4", "BUTTON": ("#FFFFFF", "#0079d3"),
               "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, "ACCENT1": "#ff5414", "ACCENT2": "#33a8ff",
               "ACCENT3": "#dbf0ff", },
    "Topanga": {"BACKGROUND": "#282923", "TEXT": "#E7DB74", "INPUT": "#393a32", "TEXT_INPUT": "#E7C855", "SCROLL": "#E7C855", "BUTTON": ("#E7C855", "#284B5A"),
                "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, "ACCENT1": "#c15226", "ACCENT2": "#7a4d5f",
                "ACCENT3": "#889743", },
    "GreenTan": {"BACKGROUND": "#9FB8AD", "TEXT": '#000000', "INPUT": "#F7F3EC", "TEXT_INPUT": "#000000", "SCROLL": "#F7F3EC", "BUTTON": ("#FFFFFF", "#475841"),
                 "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "Dark": {"BACKGROUND": "#404040", "TEXT": "#FFFFFF", "INPUT": "#4D4D4D", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#707070", "BUTTON": ("#FFFFFF", "#004F00"),
             "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightGreen": {"BACKGROUND": "#B7CECE", "TEXT": "#000000", "INPUT": "#FDFFF7", "TEXT_INPUT": "#000000", "SCROLL": "#FDFFF7",
                   "BUTTON": ("#FFFFFF", "#658268"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "ACCENT1": "#76506d",
                   "ACCENT2": "#5148f1", "ACCENT3": "#0a1c84", "PROGRESS_DEPTH": 0, },
    "Dark2": {"BACKGROUND": "#404040", "TEXT": "#FFFFFF", "INPUT": "#FFFFFF", "TEXT_INPUT": "#000000", "SCROLL": "#707070", "BUTTON": ("#FFFFFF", "#004F00"),
              "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "Black": {"BACKGROUND": "#000000", "TEXT": "#FFFFFF", "INPUT": "#4D4D4D", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#707070", "BUTTON": ("#000000", "#FFFFFF"),
              "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "Black2": {"BACKGROUND": "#000000", "TEXT": "#FFFFFF", "INPUT": "#000000", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#FFFFFF", "BUTTON": ("#000000", "#FFFFFF"),
              "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "Tan": {"BACKGROUND": "#fdf6e3", "TEXT": "#268bd1", "INPUT": "#eee8d5", "TEXT_INPUT": "#6c71c3", "SCROLL": "#eee8d5", "BUTTON": ("#FFFFFF", "#063542"),
            "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "TanBlue": {"BACKGROUND": "#e5dece", "TEXT": "#063289", "INPUT": "#f9f8f4", "TEXT_INPUT": "#242834", "SCROLL": "#eee8d5", "BUTTON": ("#FFFFFF", "#063289"),
                "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkTanBlue": {"BACKGROUND": "#242834", "TEXT": "#dfe6f8", "INPUT": "#97755c", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#a9afbb",
                    "BUTTON": ("#FFFFFF", "#063289"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkAmber": {"BACKGROUND": "#2c2825", "TEXT": "#fdcb52", "INPUT": "#705e52", "TEXT_INPUT": "#fdcb52", "SCROLL": "#705e52",
                  "BUTTON": ("#000000", "#fdcb52"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkBlue": {"BACKGROUND": "#1a2835", "TEXT": "#d1ecff", "INPUT": "#335267", "TEXT_INPUT": "#acc2d0", "SCROLL": "#1b6497", "BUTTON": ("#000000", "#fafaf8"),
                 "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "Reds": {"BACKGROUND": "#280001", "TEXT": "#FFFFFF", "INPUT": "#d8d584", "TEXT_INPUT": "#000000", "SCROLL": "#763e00", "BUTTON": ("#000000", "#daad28"),
             "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "Green": {"BACKGROUND": "#82a459", "TEXT": "#000000", "INPUT": "#d8d584", "TEXT_INPUT": "#000000", "SCROLL": "#e3ecf3", "BUTTON": ("#FFFFFF", "#517239"),
              "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "BluePurple": {"BACKGROUND": "#A5CADD", "TEXT": "#6E266E", "INPUT": "#E0F5FF", "TEXT_INPUT": "#000000", "SCROLL": "#E0F5FF",
                   "BUTTON": ("#FFFFFF", "#303952"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "Purple": {"BACKGROUND": "#B0AAC2", "TEXT": "#000000", "INPUT": "#F2EFE8", "SCROLL": "#F2EFE8", "TEXT_INPUT": "#000000", "BUTTON": ("#000000", "#C2D4D8"),
               "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "BlueMono": {"BACKGROUND": "#AAB6D3", "TEXT": "#000000", "INPUT": "#F1F4FC", "SCROLL": "#F1F4FC", "TEXT_INPUT": "#000000", "BUTTON": ("#FFFFFF", "#7186C7"),
                 "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "GreenMono": {"BACKGROUND": "#A8C1B4", "TEXT": "#000000", "INPUT": "#DDE0DE", "SCROLL": "#E3E3E3", "TEXT_INPUT": "#000000",
                  "BUTTON": ("#FFFFFF", "#6D9F85"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "BrownBlue": {"BACKGROUND": "#64778d", "TEXT": "#FFFFFF", "INPUT": "#f0f3f7", "SCROLL": "#A6B2BE", "TEXT_INPUT": "#000000",
                  "BUTTON": ("#FFFFFF", "#283b5b"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "BrightColors": {"BACKGROUND": "#b4ffb4", "TEXT": "#000000", "INPUT": "#ffff64", "SCROLL": "#ffb482", "TEXT_INPUT": "#000000",
                     "BUTTON": ("#000000", "#ffa0dc"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "NeutralBlue": {"BACKGROUND": "#92aa9d", "TEXT": "#000000", "INPUT": "#fcfff6", "SCROLL": "#fcfff6", "TEXT_INPUT": "#000000",
                    "BUTTON": ("#000000", "#d0dbbd"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "Kayak": {"BACKGROUND": "#a7ad7f", "TEXT": "#000000", "INPUT": "#e6d3a8", "SCROLL": "#e6d3a8", "TEXT_INPUT": "#000000", "BUTTON": ("#FFFFFF", "#5d907d"),
              "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "SandyBeach": {"BACKGROUND": "#efeccb", "TEXT": "#012f2f", "INPUT": "#e6d3a8", "SCROLL": "#e6d3a8", "TEXT_INPUT": "#012f2f",
                   "BUTTON": ("#FFFFFF", "#046380"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "TealMono": {"BACKGROUND": "#a8cfdd", "TEXT": "#000000", "INPUT": "#dfedf2", "SCROLL": "#dfedf2", "TEXT_INPUT": "#000000", "BUTTON": ("#FFFFFF", "#183440"),
                 "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "Default": {"BACKGROUND": COLOR_SYSTEM_DEFAULT, "TEXT": COLOR_SYSTEM_DEFAULT, "INPUT": COLOR_SYSTEM_DEFAULT, "TEXT_INPUT": COLOR_SYSTEM_DEFAULT,
                "SCROLL": COLOR_SYSTEM_DEFAULT, "BUTTON": OFFICIAL_FREESIMPLEGUI_BUTTON_COLOR, "PROGRESS": COLOR_SYSTEM_DEFAULT, "BORDER": 1, "SLIDER_DEPTH": 1,
                "PROGRESS_DEPTH": 0, },
    "Default1": {"BACKGROUND": COLOR_SYSTEM_DEFAULT, "TEXT": COLOR_SYSTEM_DEFAULT, "INPUT": COLOR_SYSTEM_DEFAULT, "TEXT_INPUT": COLOR_SYSTEM_DEFAULT,
                 "SCROLL": COLOR_SYSTEM_DEFAULT, "BUTTON": COLOR_SYSTEM_DEFAULT, "PROGRESS": COLOR_SYSTEM_DEFAULT, "BORDER": 1, "SLIDER_DEPTH": 1,
                 "PROGRESS_DEPTH": 0, },
    "DefaultNoMoreNagging": {"BACKGROUND": COLOR_SYSTEM_DEFAULT, "TEXT": COLOR_SYSTEM_DEFAULT, "INPUT": COLOR_SYSTEM_DEFAULT,
                             "TEXT_INPUT": COLOR_SYSTEM_DEFAULT, "SCROLL": COLOR_SYSTEM_DEFAULT, "BUTTON": OFFICIAL_FREESIMPLEGUI_BUTTON_COLOR,
                             "PROGRESS": COLOR_SYSTEM_DEFAULT, "BORDER": 1, "SLIDER_DEPTH": 1, "PROGRESS_DEPTH": 0, },
    "GrayGrayGray": {"BACKGROUND": COLOR_SYSTEM_DEFAULT, "TEXT": COLOR_SYSTEM_DEFAULT, "INPUT": COLOR_SYSTEM_DEFAULT, "TEXT_INPUT": COLOR_SYSTEM_DEFAULT,
                     "SCROLL": COLOR_SYSTEM_DEFAULT, "BUTTON": COLOR_SYSTEM_DEFAULT, "PROGRESS": COLOR_SYSTEM_DEFAULT, "BORDER": 1, "SLIDER_DEPTH": 1,
                     "PROGRESS_DEPTH": 0, },
    "LightBlue": {"BACKGROUND": "#E3F2FD", "TEXT": "#000000", "INPUT": "#86A8FF", "TEXT_INPUT": "#000000", "SCROLL": "#86A8FF",
                  "BUTTON": ("#FFFFFF", "#5079D3"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 0, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "ACCENT1": "#FF0266", "ACCENT2": "#FF5C93", "ACCENT3": "#C5003C", },
    "LightGrey": {"BACKGROUND": "#FAFAFA", "TEXT": "#000000", "INPUT": "#004EA1", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#5EA7FF",
                  "BUTTON": ("#FFFFFF", "#0079D3"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 0, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "ACCENT1": "#FF0266", "ACCENT2": "#FF5C93", "ACCENT3": "#C5003C", },
    "LightGrey1": {"BACKGROUND": "#ffffff", "TEXT": "#1a1a1b", "INPUT": "#dae0e6", "TEXT_INPUT": "#222222", "SCROLL": "#a5a4a4",
                   "BUTTON": ("#FFFFFF", "#0079d3"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "ACCENT1": "#ff5414", "ACCENT2": "#33a8ff", "ACCENT3": "#dbf0ff", },
    "DarkBrown": {"BACKGROUND": "#282923", "TEXT": "#E7DB74", "INPUT": "#393a32", "TEXT_INPUT": "#E7C855", "SCROLL": "#E7C855",
                  "BUTTON": ("#E7C855", "#284B5A"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "ACCENT1": "#c15226", "ACCENT2": "#7a4d5f", "ACCENT3": "#889743", },
    "LightGreen1": {"BACKGROUND": "#9FB8AD", "TEXT": "#000000", "INPUT": "#F7F3EC", "TEXT_INPUT": "#000000", "SCROLL": "#F7F3EC",
                    "BUTTON": ("#FFFFFF", "#475841"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkGrey": {"BACKGROUND": "#404040", "TEXT": "#FFFFFF", "INPUT": "#4D4D4D", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#707070", "BUTTON": ("#FFFFFF", "#004F00"),
                 "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightGreen2": {"BACKGROUND": "#B7CECE", "TEXT": "#000000", "INPUT": "#FDFFF7", "TEXT_INPUT": "#000000", "SCROLL": "#FDFFF7",
                    "BUTTON": ("#FFFFFF", "#658268"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "ACCENT1": "#76506d",
                    "ACCENT2": "#5148f1", "ACCENT3": "#0a1c84", "PROGRESS_DEPTH": 0, },
    "DarkGrey1": {"BACKGROUND": "#404040", "TEXT": "#FFFFFF", "INPUT": "#FFFFFF", "TEXT_INPUT": "#000000", "SCROLL": "#707070",
                  "BUTTON": ("#FFFFFF", "#004F00"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkBlack": {"BACKGROUND": "#000000", "TEXT": "#FFFFFF", "INPUT": "#4D4D4D", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#707070",
                  "BUTTON": ("#000000", "#FFFFFF"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightBrown": {"BACKGROUND": "#fdf6e3", "TEXT": "#268bd1", "INPUT": "#eee8d5", "TEXT_INPUT": "#6c71c3", "SCROLL": "#eee8d5",
                   "BUTTON": ("#FFFFFF", "#063542"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightBrown1": {"BACKGROUND": "#e5dece", "TEXT": "#063289", "INPUT": "#f9f8f4", "TEXT_INPUT": "#242834", "SCROLL": "#eee8d5",
                    "BUTTON": ("#FFFFFF", "#063289"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkBlue1": {"BACKGROUND": "#242834", "TEXT": "#dfe6f8", "INPUT": "#97755c", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#a9afbb",
                  "BUTTON": ("#FFFFFF", "#063289"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkBrown1": {"BACKGROUND": "#2c2825", "TEXT": "#fdcb52", "INPUT": "#705e52", "TEXT_INPUT": "#fdcb52", "SCROLL": "#705e52",
                   "BUTTON": ("#000000", "#fdcb52"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkBlue2": {"BACKGROUND": "#1a2835", "TEXT": "#d1ecff", "INPUT": "#335267", "TEXT_INPUT": "#acc2d0", "SCROLL": "#1b6497",
                  "BUTTON": ("#000000", "#fafaf8"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkBrown2": {"BACKGROUND": "#280001", "TEXT": "#FFFFFF", "INPUT": "#d8d584", "TEXT_INPUT": "#000000", "SCROLL": "#763e00",
                   "BUTTON": ("#000000", "#daad28"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkGreen": {"BACKGROUND": "#82a459", "TEXT": "#000000", "INPUT": "#d8d584", "TEXT_INPUT": "#000000", "SCROLL": "#e3ecf3",
                  "BUTTON": ("#FFFFFF", "#517239"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightBlue1": {"BACKGROUND": "#A5CADD", "TEXT": "#6E266E", "INPUT": "#E0F5FF", "TEXT_INPUT": "#000000", "SCROLL": "#E0F5FF",
                   "BUTTON": ("#FFFFFF", "#303952"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightPurple": {"BACKGROUND": "#B0AAC2", "TEXT": "#000000", "INPUT": "#F2EFE8", "SCROLL": "#F2EFE8", "TEXT_INPUT": "#000000",
                    "BUTTON": ("#000000", "#C2D4D8"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightBlue2": {"BACKGROUND": "#AAB6D3", "TEXT": "#000000", "INPUT": "#F1F4FC", "SCROLL": "#F1F4FC", "TEXT_INPUT": "#000000",
                   "BUTTON": ("#FFFFFF", "#7186C7"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightGreen3": {"BACKGROUND": "#A8C1B4", "TEXT": "#000000", "INPUT": "#DDE0DE", "SCROLL": "#E3E3E3", "TEXT_INPUT": "#000000",
                    "BUTTON": ("#FFFFFF", "#6D9F85"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkBlue3": {"BACKGROUND": "#64778d", "TEXT": "#FFFFFF", "INPUT": "#f0f3f7", "SCROLL": "#A6B2BE", "TEXT_INPUT": "#000000",
                  "BUTTON": ("#FFFFFF", "#283b5b"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightGreen4": {"BACKGROUND": "#b4ffb4", "TEXT": "#000000", "INPUT": "#ffff64", "SCROLL": "#ffb482", "TEXT_INPUT": "#000000",
                    "BUTTON": ("#000000", "#ffa0dc"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightGreen5": {"BACKGROUND": "#92aa9d", "TEXT": "#000000", "INPUT": "#fcfff6", "SCROLL": "#fcfff6", "TEXT_INPUT": "#000000",
                    "BUTTON": ("#000000", "#d0dbbd"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightBrown2": {"BACKGROUND": "#a7ad7f", "TEXT": "#000000", "INPUT": "#e6d3a8", "SCROLL": "#e6d3a8", "TEXT_INPUT": "#000000",
                    "BUTTON": ("#FFFFFF", "#5d907d"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightBrown3": {"BACKGROUND": "#efeccb", "TEXT": "#012f2f", "INPUT": "#e6d3a8", "SCROLL": "#e6d3a8", "TEXT_INPUT": "#012f2f",
                    "BUTTON": ("#FFFFFF", "#046380"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightBlue3": {"BACKGROUND": "#a8cfdd", "TEXT": "#000000", "INPUT": "#dfedf2", "SCROLL": "#dfedf2", "TEXT_INPUT": "#000000",
                   "BUTTON": ("#FFFFFF", "#183440"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "LightBrown4": {"BACKGROUND": "#d7c79e", "TEXT": "#a35638", "INPUT": "#9dab86", "TEXT_INPUT": "#000000", "SCROLL": "#a35638",
                    "BUTTON": ("#FFFFFF", "#a35638"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#a35638", "#9dab86", "#e08f62", "#d7c79e"], },
    "DarkTeal": {"BACKGROUND": "#003f5c", "TEXT": "#fb5b5a", "INPUT": "#bc4873", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#bc4873", "BUTTON": ("#FFFFFF", "#fb5b5a"),
                 "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                 "COLOR_LIST": ["#003f5c", "#472b62", "#bc4873", "#fb5b5a"], },
    "DarkPurple": {"BACKGROUND": "#472b62", "TEXT": "#fb5b5a", "INPUT": "#bc4873", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#bc4873",
                   "BUTTON": ("#FFFFFF", "#472b62"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#003f5c", "#472b62", "#bc4873", "#fb5b5a"], },
    "LightGreen6": {"BACKGROUND": "#eafbea", "TEXT": "#1f6650", "INPUT": "#6f9a8d", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#1f6650",
                    "BUTTON": ("#FFFFFF", "#1f6650"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#1f6650", "#6f9a8d", "#ea5e5e", "#eafbea"], },
    "DarkGrey2": {"BACKGROUND": "#2b2b28", "TEXT": "#f8f8f8", "INPUT": "#f1d6ab", "TEXT_INPUT": "#000000", "SCROLL": "#f1d6ab",
                  "BUTTON": ("#2b2b28", "#e3b04b"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#2b2b28", "#e3b04b", "#f1d6ab", "#f8f8f8"], },
    "LightBrown6": {"BACKGROUND": "#f9b282", "TEXT": "#8f4426", "INPUT": "#de6b35", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#8f4426",
                    "BUTTON": ("#FFFFFF", "#8f4426"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#8f4426", "#de6b35", "#64ccda", "#f9b282"], },
    "DarkTeal1": {"BACKGROUND": "#396362", "TEXT": "#ffe7d1", "INPUT": "#f6c89f", "TEXT_INPUT": "#000000", "SCROLL": "#f6c89f",
                  "BUTTON": ("#ffe7d1", "#4b8e8d"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#396362", "#4b8e8d", "#f6c89f", "#ffe7d1"], },
    "LightBrown7": {"BACKGROUND": "#f6c89f", "TEXT": "#396362", "INPUT": "#4b8e8d", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#396362",
                    "BUTTON": ("#FFFFFF", "#396362"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#396362", "#4b8e8d", "#f6c89f", "#ffe7d1"], },
    "DarkPurple1": {"BACKGROUND": "#0c093c", "TEXT": "#fad6d6", "INPUT": "#eea5f6", "TEXT_INPUT": "#000000", "SCROLL": "#eea5f6",
                    "BUTTON": ("#FFFFFF", "#df42d1"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#0c093c", "#df42d1", "#eea5f6", "#fad6d6"], },
    "DarkGrey3": {"BACKGROUND": "#211717", "TEXT": "#dfddc7", "INPUT": "#f58b54", "TEXT_INPUT": "#000000", "SCROLL": "#f58b54",
                  "BUTTON": ("#dfddc7", "#a34a28"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#211717", "#a34a28", "#f58b54", "#dfddc7"], },
    "LightBrown8": {"BACKGROUND": "#dfddc7", "TEXT": "#211717", "INPUT": "#a34a28", "TEXT_INPUT": "#dfddc7", "SCROLL": "#211717",
                    "BUTTON": ("#dfddc7", "#a34a28"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#211717", "#a34a28", "#f58b54", "#dfddc7"], },
    "DarkBlue4": {"BACKGROUND": "#494ca2", "TEXT": "#e3e7f1", "INPUT": "#c6cbef", "TEXT_INPUT": "#000000", "SCROLL": "#c6cbef",
                  "BUTTON": ("#FFFFFF", "#8186d5"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#494ca2", "#8186d5", "#c6cbef", "#e3e7f1"], },
    "LightBlue4": {"BACKGROUND": "#5c94bd", "TEXT": "#470938", "INPUT": "#1a3e59", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#470938",
                   "BUTTON": ("#FFFFFF", "#470938"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#470938", "#1a3e59", "#5c94bd", "#f2d6eb"], },
    "DarkTeal2": {"BACKGROUND": "#394a6d", "TEXT": "#c0ffb3", "INPUT": "#52de97", "TEXT_INPUT": "#000000", "SCROLL": "#52de97",
                  "BUTTON": ("#c0ffb3", "#394a6d"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#394a6d", "#3c9d9b", "#52de97", "#c0ffb3"], },
    "DarkTeal3": {"BACKGROUND": "#3c9d9b", "TEXT": "#c0ffb3", "INPUT": "#52de97", "TEXT_INPUT": "#000000", "SCROLL": "#52de97",
                  "BUTTON": ("#c0ffb3", "#394a6d"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#394a6d", "#3c9d9b", "#52de97", "#c0ffb3"], },
    "DarkPurple5": {"BACKGROUND": "#730068", "TEXT": "#f6f078", "INPUT": "#01d28e", "TEXT_INPUT": "#000000", "SCROLL": "#01d28e",
                    "BUTTON": ("#f6f078", "#730068"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#730068", "#434982", "#01d28e", "#f6f078"], },
    "DarkPurple2": {"BACKGROUND": "#202060", "TEXT": "#b030b0", "INPUT": "#602080", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#602080",
                    "BUTTON": ("#FFFFFF", "#202040"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#202040", "#202060", "#602080", "#b030b0"], },
    "DarkBlue5": {"BACKGROUND": "#000272", "TEXT": "#ff6363", "INPUT": "#a32f80", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#a32f80",
                  "BUTTON": ("#FFFFFF", "#341677"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#000272", "#341677", "#a32f80", "#ff6363"], },
    "LightGrey2": {"BACKGROUND": "#f6f6f6", "TEXT": "#420000", "INPUT": "#d4d7dd", "TEXT_INPUT": "#420000", "SCROLL": "#420000",
                   "BUTTON": ("#420000", "#d4d7dd"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#420000", "#d4d7dd", "#eae9e9", "#f6f6f6"], },
    "LightGrey3": {"BACKGROUND": "#eae9e9", "TEXT": "#420000", "INPUT": "#d4d7dd", "TEXT_INPUT": "#420000", "SCROLL": "#420000",
                   "BUTTON": ("#420000", "#d4d7dd"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#420000", "#d4d7dd", "#eae9e9", "#f6f6f6"], },
    "DarkBlue6": {"BACKGROUND": "#01024e", "TEXT": "#ff6464", "INPUT": "#8b4367", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#8b4367",
                  "BUTTON": ("#FFFFFF", "#543864"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#01024e", "#543864", "#8b4367", "#ff6464"], },
    "DarkBlue7": {"BACKGROUND": "#241663", "TEXT": "#eae7af", "INPUT": "#a72693", "TEXT_INPUT": "#eae7af", "SCROLL": "#a72693",
                  "BUTTON": ("#eae7af", "#160f30"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#160f30", "#241663", "#a72693", "#eae7af"], },
    "LightBrown9": {"BACKGROUND": "#f6d365", "TEXT": "#3a1f5d", "INPUT": "#c83660", "TEXT_INPUT": "#f6d365", "SCROLL": "#3a1f5d",
                    "BUTTON": ("#f6d365", "#c83660"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#3a1f5d", "#c83660", "#e15249", "#f6d365"], },
    "DarkPurple3": {"BACKGROUND": "#6e2142", "TEXT": "#ffd692", "INPUT": "#e16363", "TEXT_INPUT": "#ffd692", "SCROLL": "#e16363",
                    "BUTTON": ("#ffd692", "#943855"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#6e2142", "#943855", "#e16363", "#ffd692"], },
    "LightBrown10": {"BACKGROUND": "#ffd692", "TEXT": "#6e2142", "INPUT": "#943855", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#6e2142",
                     "BUTTON": ("#FFFFFF", "#6e2142"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                     "COLOR_LIST": ["#6e2142", "#943855", "#e16363", "#ffd692"], },
    "DarkPurple4": {"BACKGROUND": "#200f21", "TEXT": "#f638dc", "INPUT": "#5a3d5c", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#5a3d5c",
                    "BUTTON": ("#FFFFFF", "#382039"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#200f21", "#382039", "#5a3d5c", "#f638dc"], },
    "LightBlue5": {"BACKGROUND": "#b2fcff", "TEXT": "#3e64ff", "INPUT": "#5edfff", "TEXT_INPUT": "#000000", "SCROLL": "#3e64ff",
                   "BUTTON": ("#FFFFFF", "#3e64ff"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#3e64ff", "#5edfff", "#b2fcff", "#ecfcff"], },
    "DarkTeal4": {"BACKGROUND": "#464159", "TEXT": "#c7f0db", "INPUT": "#8bbabb", "TEXT_INPUT": "#000000", "SCROLL": "#8bbabb",
                  "BUTTON": ("#FFFFFF", "#6c7b95"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#464159", "#6c7b95", "#8bbabb", "#c7f0db"], },
    "LightTeal": {"BACKGROUND": "#c7f0db", "TEXT": "#464159", "INPUT": "#6c7b95", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#464159",
                  "BUTTON": ("#FFFFFF", "#464159"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#464159", "#6c7b95", "#8bbabb", "#c7f0db"], },
    "DarkTeal5": {"BACKGROUND": "#8bbabb", "TEXT": "#464159", "INPUT": "#6c7b95", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#464159",
                  "BUTTON": ("#c7f0db", "#6c7b95"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#464159", "#6c7b95", "#8bbabb", "#c7f0db"], },
    "LightGrey4": {"BACKGROUND": "#faf5ef", "TEXT": "#672f2f", "INPUT": "#99b19c", "TEXT_INPUT": "#672f2f", "SCROLL": "#672f2f",
                   "BUTTON": ("#672f2f", "#99b19c"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#672f2f", "#99b19c", "#d7d1c9", "#faf5ef"], },
    "LightGreen7": {"BACKGROUND": "#99b19c", "TEXT": "#faf5ef", "INPUT": "#d7d1c9", "TEXT_INPUT": "#000000", "SCROLL": "#d7d1c9",
                    "BUTTON": ("#FFFFFF", "#99b19c"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#672f2f", "#99b19c", "#d7d1c9", "#faf5ef"], },
    "LightGrey5": {"BACKGROUND": "#d7d1c9", "TEXT": "#672f2f", "INPUT": "#99b19c", "TEXT_INPUT": "#672f2f", "SCROLL": "#672f2f",
                   "BUTTON": ("#FFFFFF", "#672f2f"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#672f2f", "#99b19c", "#d7d1c9", "#faf5ef"], },
    "DarkBrown3": {"BACKGROUND": "#a0855b", "TEXT": "#f9f6f2", "INPUT": "#f1d6ab", "TEXT_INPUT": "#000000", "SCROLL": "#f1d6ab",
                   "BUTTON": ("#FFFFFF", "#38470b"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#38470b", "#a0855b", "#f1d6ab", "#f9f6f2"], },
    "LightBrown11": {"BACKGROUND": "#f1d6ab", "TEXT": "#38470b", "INPUT": "#a0855b", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#38470b",
                     "BUTTON": ("#f9f6f2", "#a0855b"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                     "COLOR_LIST": ["#38470b", "#a0855b", "#f1d6ab", "#f9f6f2"], },
    "DarkRed": {"BACKGROUND": "#83142c", "TEXT": "#f9d276", "INPUT": "#ad1d45", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#ad1d45", "BUTTON": ("#f9d276", "#ad1d45"),
                "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                "COLOR_LIST": ["#44000d", "#83142c", "#ad1d45", "#f9d276"], },
    "DarkTeal6": {"BACKGROUND": "#204969", "TEXT": "#fff7f7", "INPUT": "#dadada", "TEXT_INPUT": "#000000", "SCROLL": "#dadada",
                  "BUTTON": ("#000000", "#fff7f7"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#204969", "#08ffc8", "#dadada", "#fff7f7"], },
    "DarkBrown4": {"BACKGROUND": "#252525", "TEXT": "#ff0000", "INPUT": "#af0404", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#af0404",
                   "BUTTON": ("#FFFFFF", "#252525"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#252525", "#414141", "#af0404", "#ff0000"], },
    "LightYellow": {"BACKGROUND": "#f4ff61", "TEXT": "#27aa80", "INPUT": "#32ff6a", "TEXT_INPUT": "#000000", "SCROLL": "#27aa80",
                    "BUTTON": ("#f4ff61", "#27aa80"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#27aa80", "#32ff6a", "#a8ff3e", "#f4ff61"], },
    "DarkGreen1": {"BACKGROUND": "#2b580c", "TEXT": "#fdef96", "INPUT": "#f7b71d", "TEXT_INPUT": "#000000", "SCROLL": "#f7b71d",
                   "BUTTON": ("#fdef96", "#2b580c"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#2b580c", "#afa939", "#f7b71d", "#fdef96"], },
    "LightGreen8": {"BACKGROUND": "#c8dad3", "TEXT": "#63707e", "INPUT": "#93b5b3", "TEXT_INPUT": "#000000", "SCROLL": "#63707e",
                    "BUTTON": ("#FFFFFF", "#63707e"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#63707e", "#93b5b3", "#c8dad3", "#f2f6f5"], },
    "DarkTeal7": {"BACKGROUND": "#248ea9", "TEXT": "#fafdcb", "INPUT": "#aee7e8", "TEXT_INPUT": "#000000", "SCROLL": "#aee7e8",
                  "BUTTON": ("#000000", "#fafdcb"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#248ea9", "#28c3d4", "#aee7e8", "#fafdcb"], },
    "DarkBlue8": {"BACKGROUND": "#454d66", "TEXT": "#d9d872", "INPUT": "#58b368", "TEXT_INPUT": "#000000", "SCROLL": "#58b368",
                  "BUTTON": ("#000000", "#009975"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#009975", "#454d66", "#58b368", "#d9d872"], },
    "DarkBlue9": {"BACKGROUND": "#263859", "TEXT": "#ff6768", "INPUT": "#6b778d", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#6b778d",
                  "BUTTON": ("#ff6768", "#263859"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#17223b", "#263859", "#6b778d", "#ff6768"], },
    "DarkBlue10": {"BACKGROUND": "#0028ff", "TEXT": "#f1f4df", "INPUT": "#10eaf0", "TEXT_INPUT": "#000000", "SCROLL": "#10eaf0",
                   "BUTTON": ("#f1f4df", "#24009c"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#24009c", "#0028ff", "#10eaf0", "#f1f4df"], },
    "DarkBlue11": {"BACKGROUND": "#6384b3", "TEXT": "#e6f0b6", "INPUT": "#b8e9c0", "TEXT_INPUT": "#000000", "SCROLL": "#b8e9c0",
                   "BUTTON": ("#e6f0b6", "#684949"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#684949", "#6384b3", "#b8e9c0", "#e6f0b6"], },
    "DarkTeal8": {"BACKGROUND": "#71a0a5", "TEXT": "#212121", "INPUT": "#665c84", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#212121",
                  "BUTTON": ("#fab95b", "#665c84"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#212121", "#665c84", "#71a0a5", "#fab95b"], },
    "DarkRed1": {"BACKGROUND": "#c10000", "TEXT": "#eeeeee", "INPUT": "#dedede", "TEXT_INPUT": "#000000", "SCROLL": "#dedede", "BUTTON": ("#c10000", "#eeeeee"),
                 "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                 "COLOR_LIST": ["#c10000", "#ff4949", "#dedede", "#eeeeee"], },
    "LightBrown5": {"BACKGROUND": "#fff591", "TEXT": "#e41749", "INPUT": "#f5587b", "TEXT_INPUT": "#000000", "SCROLL": "#e41749",
                    "BUTTON": ("#fff591", "#e41749"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#e41749", "#f5587b", "#ff8a5c", "#fff591"], },
    "LightGreen9": {"BACKGROUND": "#f1edb3", "TEXT": "#3b503d", "INPUT": "#4a746e", "TEXT_INPUT": "#f1edb3", "SCROLL": "#3b503d",
                    "BUTTON": ("#f1edb3", "#3b503d"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#3b503d", "#4a746e", "#c8cf94", "#f1edb3"], "DESCRIPTION": ["Green", "Turquoise", "Yellow"], },
    "DarkGreen2": {"BACKGROUND": "#3b503d", "TEXT": "#f1edb3", "INPUT": "#c8cf94", "TEXT_INPUT": "#000000", "SCROLL": "#c8cf94",
                   "BUTTON": ("#f1edb3", "#3b503d"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#3b503d", "#4a746e", "#c8cf94", "#f1edb3"], "DESCRIPTION": ["Green", "Turquoise", "Yellow"], },
    "LightGray1": {"BACKGROUND": "#f2f2f2", "TEXT": "#222831", "INPUT": "#393e46", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#222831",
                   "BUTTON": ("#f2f2f2", "#222831"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#222831", "#393e46", "#f96d00", "#f2f2f2"], "DESCRIPTION": ["#000000", "Grey", "Orange", "Grey", "Autumn"], },
    "DarkGrey4": {"BACKGROUND": "#52524e", "TEXT": "#e9e9e5", "INPUT": "#d4d6c8", "TEXT_INPUT": "#000000", "SCROLL": "#d4d6c8",
                  "BUTTON": ("#FFFFFF", "#9a9b94"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#52524e", "#9a9b94", "#d4d6c8", "#e9e9e5"], "DESCRIPTION": ["Grey", "Pastel", "Winter"], },
    "DarkBlue12": {"BACKGROUND": "#324e7b", "TEXT": "#f8f8f8", "INPUT": "#86a6df", "TEXT_INPUT": "#000000", "SCROLL": "#86a6df",
                   "BUTTON": ("#FFFFFF", "#5068a9"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#324e7b", "#5068a9", "#86a6df", "#f8f8f8"], "DESCRIPTION": ["Blue", "Grey", "Cold", "Winter"], },
    "DarkPurple6": {"BACKGROUND": "#070739", "TEXT": "#e1e099", "INPUT": "#c327ab", "TEXT_INPUT": "#e1e099", "SCROLL": "#c327ab",
                    "BUTTON": ("#e1e099", "#521477"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                    "COLOR_LIST": ["#070739", "#521477", "#c327ab", "#e1e099"], "DESCRIPTION": ["#000000", "Purple", "Yellow", "Dark"], },
    "DarkPurple7": {"BACKGROUND": "#191930", "TEXT": "#B1B7C5", "INPUT": "#232B5C", "TEXT_INPUT": "#D0E3E7", "SCROLL": "#B1B7C5",
                    "BUTTON": ("#272D38", "#B1B7C5"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkBlue13": {"BACKGROUND": "#203562", "TEXT": "#e3e8f8", "INPUT": "#c0c5cd", "TEXT_INPUT": "#000000", "SCROLL": "#c0c5cd",
                   "BUTTON": ("#FFFFFF", "#3e588f"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#203562", "#3e588f", "#c0c5cd", "#e3e8f8"], "DESCRIPTION": ["Blue", "Grey", "Wedding", "Cold"], },
    "DarkBrown5": {"BACKGROUND": "#3c1b1f", "TEXT": "#f6e1b5", "INPUT": "#e2bf81", "TEXT_INPUT": "#000000", "SCROLL": "#e2bf81",
                   "BUTTON": ("#3c1b1f", "#f6e1b5"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#3c1b1f", "#b21e4b", "#e2bf81", "#f6e1b5"], "DESCRIPTION": ["Brown", "Red", "Yellow", "Warm"], },
    "DarkGreen3": {"BACKGROUND": "#062121", "TEXT": "#eeeeee", "INPUT": "#e4dcad", "TEXT_INPUT": "#000000", "SCROLL": "#e4dcad",
                   "BUTTON": ("#eeeeee", "#181810"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#062121", "#181810", "#e4dcad", "#eeeeee"], "DESCRIPTION": ["#000000", "#000000", "Brown", "Grey"], },
    "DarkBlack1": {"BACKGROUND": "#181810", "TEXT": "#eeeeee", "INPUT": "#e4dcad", "TEXT_INPUT": "#000000", "SCROLL": "#e4dcad",
                   "BUTTON": ("#FFFFFF", "#062121"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#062121", "#181810", "#e4dcad", "#eeeeee"], "DESCRIPTION": ["#000000", "#000000", "Brown", "Grey"], },
    "DarkGrey5": {"BACKGROUND": "#343434", "TEXT": "#f3f3f3", "INPUT": "#e9dcbe", "TEXT_INPUT": "#000000", "SCROLL": "#e9dcbe",
                  "BUTTON": ("#FFFFFF", "#8e8b82"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#343434", "#8e8b82", "#e9dcbe", "#f3f3f3"], "DESCRIPTION": ["Grey", "Brown"], },
    "LightBrown12": {"BACKGROUND": "#8e8b82", "TEXT": "#f3f3f3", "INPUT": "#e9dcbe", "TEXT_INPUT": "#000000", "SCROLL": "#e9dcbe",
                     "BUTTON": ("#f3f3f3", "#8e8b82"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                     "COLOR_LIST": ["#343434", "#8e8b82", "#e9dcbe", "#f3f3f3"], "DESCRIPTION": ["Grey", "Brown"], },
    "DarkTeal9": {"BACKGROUND": "#13445a", "TEXT": "#fef4e8", "INPUT": "#446878", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#446878",
                  "BUTTON": ("#fef4e8", "#446878"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#13445a", "#970747", "#446878", "#fef4e8"], "DESCRIPTION": ["Red", "Grey", "Blue", "Wedding", "Retro"], },
    "DarkBlue14": {"BACKGROUND": "#21273d", "TEXT": "#f1f6f8", "INPUT": "#b9d4f1", "TEXT_INPUT": "#000000", "SCROLL": "#b9d4f1",
                   "BUTTON": ("#FFFFFF", "#6a759b"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#21273d", "#6a759b", "#b9d4f1", "#f1f6f8"], "DESCRIPTION": ["Blue", "#000000", "Grey", "Cold", "Winter"], },
    "LightBlue6": {"BACKGROUND": "#f1f6f8", "TEXT": "#21273d", "INPUT": "#6a759b", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#21273d",
                   "BUTTON": ("#f1f6f8", "#6a759b"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#21273d", "#6a759b", "#b9d4f1", "#f1f6f8"], "DESCRIPTION": ["Blue", "#000000", "Grey", "Cold", "Winter"], },
    "DarkGreen4": {"BACKGROUND": "#044343", "TEXT": "#e4e4e4", "INPUT": "#045757", "TEXT_INPUT": "#e4e4e4", "SCROLL": "#045757",
                   "BUTTON": ("#e4e4e4", "#045757"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#222222", "#044343", "#045757", "#e4e4e4"], "DESCRIPTION": ["#000000", "Turquoise", "Grey", "Dark"], },
    "DarkGreen5": {"BACKGROUND": "#1b4b36", "TEXT": "#e0e7f1", "INPUT": "#aebd77", "TEXT_INPUT": "#000000", "SCROLL": "#aebd77",
                   "BUTTON": ("#FFFFFF", "#538f6a"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#1b4b36", "#538f6a", "#aebd77", "#e0e7f1"], "DESCRIPTION": ["Green", "Grey"], },
    "DarkTeal10": {"BACKGROUND": "#0d3446", "TEXT": "#d8dfe2", "INPUT": "#71adb5", "TEXT_INPUT": "#000000", "SCROLL": "#71adb5",
                   "BUTTON": ("#FFFFFF", "#176d81"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#0d3446", "#176d81", "#71adb5", "#d8dfe2"], "DESCRIPTION": ["Grey", "Turquoise", "Winter", "Cold"], },
    "DarkGrey6": {"BACKGROUND": "#3e3e3e", "TEXT": "#ededed", "INPUT": "#68868c", "TEXT_INPUT": "#ededed", "SCROLL": "#68868c",
                  "BUTTON": ("#FFFFFF", "#405559"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#3e3e3e", "#405559", "#68868c", "#ededed"], "DESCRIPTION": ["Grey", "Turquoise", "Winter"], },
    "DarkTeal11": {"BACKGROUND": "#405559", "TEXT": "#ededed", "INPUT": "#68868c", "TEXT_INPUT": "#ededed", "SCROLL": "#68868c",
                   "BUTTON": ("#ededed", "#68868c"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#3e3e3e", "#405559", "#68868c", "#ededed"], "DESCRIPTION": ["Grey", "Turquoise", "Winter"], },
    "LightBlue7": {"BACKGROUND": "#9ed0e0", "TEXT": "#19483f", "INPUT": "#5c868e", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#19483f",
                   "BUTTON": ("#FFFFFF", "#19483f"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#19483f", "#5c868e", "#ff6a38", "#9ed0e0"], "DESCRIPTION": ["Orange", "Blue", "Turquoise"], },
    "LightGreen10": {"BACKGROUND": "#d8ebb5", "TEXT": "#205d67", "INPUT": "#639a67", "TEXT_INPUT": "#FFFFFF", "SCROLL": "#205d67",
                     "BUTTON": ("#d8ebb5", "#205d67"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                     "COLOR_LIST": ["#205d67", "#639a67", "#d9bf77", "#d8ebb5"], "DESCRIPTION": ["Blue", "Green", "Brown", "Vintage"], },
    "DarkBlue15": {"BACKGROUND": "#151680", "TEXT": "#f1fea4", "INPUT": "#375fc0", "TEXT_INPUT": "#f1fea4", "SCROLL": "#375fc0",
                   "BUTTON": ("#f1fea4", "#1c44ac"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#151680", "#1c44ac", "#375fc0", "#f1fea4"], "DESCRIPTION": ["Blue", "Yellow", "Cold"], },
    "DarkBlue16": {"BACKGROUND": "#1c44ac", "TEXT": "#f1fea4", "INPUT": "#375fc0", "TEXT_INPUT": "#f1fea4", "SCROLL": "#375fc0",
                   "BUTTON": ("#f1fea4", "#151680"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#151680", "#1c44ac", "#375fc0", "#f1fea4"], "DESCRIPTION": ["Blue", "Yellow", "Cold"], },
    "DarkTeal12": {"BACKGROUND": "#004a7c", "TEXT": "#fafafa", "INPUT": "#e8f1f5", "TEXT_INPUT": "#000000", "SCROLL": "#e8f1f5",
                   "BUTTON": ("#fafafa", "#005691"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#004a7c", "#005691", "#e8f1f5", "#fafafa"], "DESCRIPTION": ["Grey", "Blue", "Cold", "Winter"], },
    "LightBrown13": {"BACKGROUND": "#ebf5ee", "TEXT": "#921224", "INPUT": "#bdc6b8", "TEXT_INPUT": "#921224", "SCROLL": "#921224",
                     "BUTTON": ("#FFFFFF", "#921224"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                     "COLOR_LIST": ["#921224", "#bdc6b8", "#bce0da", "#ebf5ee"], "DESCRIPTION": ["Red", "Blue", "Grey", "Vintage", "Wedding"], },
    "DarkBlue17": {"BACKGROUND": "#21294c", "TEXT": "#f9f2d7", "INPUT": "#f2dea8", "TEXT_INPUT": "#000000", "SCROLL": "#f2dea8",
                   "BUTTON": ("#f9f2d7", "#141829"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#141829", "#21294c", "#f2dea8", "#f9f2d7"], "DESCRIPTION": ["#000000", "Blue", "Yellow"], },
    "DarkBlue18": {"BACKGROUND": "#0c1825", "TEXT": "#d1d7dd", "INPUT": "#001c35", "TEXT_INPUT": "#d1d7dd", "SCROLL": "#00438e",
                   "BUTTON": ("#75b7ff", "#001c35"), "PROGRESS": ('#0074ff', '#75b7ff'), "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#141829", "#21294c", "#f2dea8", "#f9f2d7"], "DESCRIPTION": ["#000000", "Blue", "Yellow"], },
    "DarkBrown6": {"BACKGROUND": "#785e4d", "TEXT": "#f2eee3", "INPUT": "#baaf92", "TEXT_INPUT": "#000000", "SCROLL": "#baaf92",
                   "BUTTON": ("#FFFFFF", "#785e4d"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#785e4d", "#ff8426", "#baaf92", "#f2eee3"], "DESCRIPTION": ["Grey", "Brown", "Orange", "Autumn"], },
    "DarkGreen6": {"BACKGROUND": "#5c715e", "TEXT": "#f2f9f1", "INPUT": "#ddeedf", "TEXT_INPUT": "#000000", "SCROLL": "#ddeedf",
                   "BUTTON": ("#f2f9f1", "#5c715e"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#5c715e", "#b6cdbd", "#ddeedf", "#f2f9f1"], "DESCRIPTION": ["Grey", "Green", "Vintage"], },
    "DarkGreen7": {"BACKGROUND": "#0C231E", "TEXT": "#efbe1c", "INPUT": "#153C33", "TEXT_INPUT": "#efbe1c", "SCROLL": "#153C33",
                   "BUTTON": ("#efbe1c", "#153C33"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkGrey7": {"BACKGROUND": "#4b586e", "TEXT": "#dddddd", "INPUT": "#574e6d", "TEXT_INPUT": "#dddddd", "SCROLL": "#574e6d",
                  "BUTTON": ("#dddddd", "#43405d"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                  "COLOR_LIST": ["#43405d", "#4b586e", "#574e6d", "#dddddd"], "DESCRIPTION": ["Grey", "Winter", "Cold"], },
    "DarkRed2": {"BACKGROUND": "#ab1212", "TEXT": "#f6e4b5", "INPUT": "#cd3131", "TEXT_INPUT": "#f6e4b5", "SCROLL": "#cd3131", "BUTTON": ("#f6e4b5", "#ab1212"),
                 "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                 "COLOR_LIST": ["#ab1212", "#1fad9f", "#cd3131", "#f6e4b5"], "DESCRIPTION": ["Turquoise", "Red", "Yellow"], },
    "LightGrey6": {"BACKGROUND": "#e3e3e3", "TEXT": "#233142", "INPUT": "#455d7a", "TEXT_INPUT": "#e3e3e3", "SCROLL": "#233142",
                   "BUTTON": ("#e3e3e3", "#455d7a"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0,
                   "COLOR_LIST": ["#233142", "#455d7a", "#f95959", "#e3e3e3"], "DESCRIPTION": ["#000000", "Blue", "Red", "Grey"], },
    "HotDogStand": {"BACKGROUND": "red", "TEXT": "yellow", "INPUT": "yellow", "TEXT_INPUT": "#000000", "SCROLL": "yellow", "BUTTON": ("red", "yellow"),
                    "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkGrey8": {"BACKGROUND": "#19232D", "TEXT": "#ffffff", "INPUT": "#32414B", "TEXT_INPUT": "#ffffff", "SCROLL": "#505F69",
                  "BUTTON": ("#ffffff", "#32414B"), "PROGRESS": ("#505F69", "#32414B"), "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkGrey9": {"BACKGROUND": "#36393F", "TEXT": "#DCDDDE", "INPUT": "#40444B", "TEXT_INPUT": "#ffffff", "SCROLL": "#202225",
                  "BUTTON": ("#202225", "#B9BBBE"), "PROGRESS": ("#202225", "#40444B"), "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkGrey10": {"BACKGROUND": "#1c1e23", "TEXT": "#cccdcf", "INPUT": "#272a31", "TEXT_INPUT": "#8b9fde", "SCROLL": "#313641",
                   "BUTTON": ("#f5f5f6", "#2e3d5a"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkGrey11": {"BACKGROUND": "#1c1e23", "TEXT": "#cccdcf", "INPUT": "#313641", "TEXT_INPUT": "#cccdcf", "SCROLL": "#313641",
                   "BUTTON": ("#f5f5f6", "#313641"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkGrey12": {"BACKGROUND": "#1c1e23", "TEXT": "#8b9fde", "INPUT": "#313641", "TEXT_INPUT": "#8b9fde", "SCROLL": "#313641",
                   "BUTTON": ("#cccdcf", "#2e3d5a"), "PROGRESS": DEFAULT_PROGRESS_BAR_COMPUTE, "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkGrey13": {"BACKGROUND": "#1c1e23", "TEXT": "#cccdcf", "INPUT": "#272a31", "TEXT_INPUT": "#cccdcf", "SCROLL": "#313641",
                   "BUTTON": ("#8b9fde", "#313641"), "PROGRESS": ("#cccdcf", "#272a31"), "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkGrey14": {"BACKGROUND": "#24292e", "TEXT": "#fafbfc", "INPUT": "#1d2125", "TEXT_INPUT": "#fafbfc", "SCROLL": "#1d2125",
                   "BUTTON": ("#fafbfc", "#155398"), "PROGRESS": ("#155398", "#1d2125"), "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "DarkGrey15": {'BACKGROUND': '#121212', 'TEXT': '#dddddd', 'INPUT': '#1e1e1e', 'TEXT_INPUT': '#69b1ef', 'SCROLL': '#272727',
                   'BUTTON': ('#69b1ef', '#2e2e2e'), 'PROGRESS': ('#69b1ef', '#2e2e2e'), 'BORDER': 1, 'SLIDER_DEPTH': 0, 'PROGRESS_DEPTH': 0, },
    "DarkGrey16": {'BACKGROUND': '#353535', 'TEXT': '#ffffff', 'INPUT': '#191919', 'TEXT_INPUT': '#ffffff', 'SCROLL': '#454545',
                   'BUTTON': ('#ffffff', '#454545'), 'PROGRESS': ('#757575', '#454545'), 'BORDER': 1, 'SLIDER_DEPTH': 0, 'PROGRESS_DEPTH': 0, },
    "DarkBrown7": {"BACKGROUND": "#2c2417", "TEXT": "#baa379", "INPUT": "#baa379", "TEXT_INPUT": "#000000", "SCROLL": "#392e1c",
                   "BUTTON": ("#000000", "#baa379"), "PROGRESS": ("#baa379", "#453923"), "BORDER": 1, "SLIDER_DEPTH": 1, "PROGRESS_DEPTH": 0, },
    "Python": {"BACKGROUND": "#3d7aab", "TEXT": "#ffde56", "INPUT": "#295273", "TEXT_INPUT": "#ffde56", "SCROLL": "#295273",
               "BUTTON": ("#ffde56", "#295273"), "PROGRESS": ("#ffde56", "#295273"), "BORDER": 1, "SLIDER_DEPTH": 1, "PROGRESS_DEPTH": 0, },
    "PythonPlus": {"BACKGROUND": "#001d3c", "TEXT": "#ffffff", "INPUT": "#015bbb", "TEXT_INPUT": "#fed500", "SCROLL": "#015bbb",
                   "BUTTON": ("#fed500", "#015bbb"), "PROGRESS": ("#015bbb", "#fed500"), "BORDER": 1, "SLIDER_DEPTH": 1, "PROGRESS_DEPTH": 0, },
    "NeonBlue1": {"BACKGROUND": "#000000", "TEXT": "#ffffff", "INPUT": "#000000", "TEXT_INPUT": "#33ccff", "SCROLL": "#33ccff",
                  "BUTTON": ("#33ccff", "#000000"), "PROGRESS": ("#33ccff", "#ffffff"), "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "NeonGreen1": {"BACKGROUND": "#000000", "TEXT": "#ffffff", "INPUT": "#000000", "TEXT_INPUT": "#96ff7b", "SCROLL": "#96ff7b",
                   "BUTTON": ("#96ff7b", "#000000"), "PROGRESS": ("#96ff7b", "#ffffff"), "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
    "NeonYellow1": {"BACKGROUND": "#000000", "TEXT": "#ffffff", "INPUT": "#000000", "TEXT_INPUT": "#ffcf40", "SCROLL": "#ffcf40",
                    "BUTTON": ("#ffcf40", "#000000"), "PROGRESS": ("#ffcf40", "#ffffff"), "BORDER": 1, "SLIDER_DEPTH": 0, "PROGRESS_DEPTH": 0, },
}


def list_of_look_and_feel_values():
    """Gets a list of the valid values to pass into your call to `change_look_and_feel`

    :return: list of valid string values
    :rtype:  List[str]
    """
    return sorted(list(LOOK_AND_FEEL_TABLE.keys()))


def theme(new_theme=None):
    """Sets or gets the current `Theme`

    If none is specified then returns the current one.
    This call replaces the `ChangeLookAndFeel` / `change_look_and_feel` call which only sets the theme.

    :param new_theme: the new theme name to use
    :type new_theme:  (str)
    :return:          the currently selected theme
    :rtype:           (str)
    """
    global TRANSPARENT_BUTTON

    if new_theme is not None:
        change_look_and_feel(new_theme)
        TRANSPARENT_BUTTON = (theme_background_color(), theme_background_color())
    return CURRENT_LOOK_AND_FEEL


def theme_background_color(color=None):
    """Sets or gets the background color currently in use

    Used for `Window`s and containers (`Column`, `Frame`, `Tab`) and `Table`s.

    :param color: new background color to use (optional)
    :type color:  (str)
    :return:      color string of the background color currently in use
    :rtype:       (str)
    """
    if color is not None:
        set_options(background_color=color)
    return DEFAULT_BACKGROUND_COLOR

# This "constant" is misleading but rather than remove and break programs, will try this method instead
TRANSPARENT_BUTTON = (theme_background_color(), theme_background_color())


def theme_element_background_color(color=None):
    """Sets or gets returns the background color currently in use
        for all elements except containers

    :return: (str) - color string of the element background color currently in use
    :rtype:  (str)
    """
    if color is not None:
        set_options(element_background_color=color)
    return DEFAULT_ELEMENT_BACKGROUND_COLOR


def theme_text_color(color=None):
    """Sets or gets the text color currently in use

    :return: (str) - color string of the text color currently in use
    :rtype:  (str)
    """
    if color is not None:
        set_options(text_color=color)
    return DEFAULT_TEXT_COLOR


def theme_text_element_background_color(color=None):
    """Sets or gets the background color for text elements

    :return: (str) - color string of the text background color currently in use
    :rtype:  (str)
    """
    if color is not None:
        set_options(text_element_background_color=color)
    return DEFAULT_TEXT_ELEMENT_BACKGROUND_COLOR


def theme_input_background_color(color=None):
    """Sets or gets the input element background color currently in use

    :return: (str) - color string of the input element background color currently in use
    :rtype:  (str)
    """
    if color is not None:
        set_options(input_elements_background_color=color)
    return DEFAULT_INPUT_ELEMENTS_COLOR


def theme_input_text_color(color=None):
    """Sets or gets the input element entry color
        (not the text but the thing that's displaying the text)

    :return: (str) - color string of the input element color currently in use
    :rtype:  (str)
    """
    if color is not None:
        set_options(input_text_color=color)
    return DEFAULT_INPUT_TEXT_COLOR


def theme_button_color(color=None):
    """Sets or gets the button color currently in use

    :return: (str, str) - TUPLE with color strings of the button color currently in use (button text color, button background color)
    :rtype:  (str, str)
    """
    if color is not None:
        if color == COLOR_SYSTEM_DEFAULT:
            color_tuple = (COLOR_SYSTEM_DEFAULT, COLOR_SYSTEM_DEFAULT)
        else:
            color_tuple = button_color_to_tuple(color, (None, None))
        if color_tuple == (None, None):
            if not SUPPRESS_ERROR_POPUPS:
                popup_error('theme_button_color - bad color string passed in', color)
            else:
                print('** Badly formatted button color... not a tuple nor string **', color)
            set_options(button_color=color)  # go ahead and try with their string
        else:
            set_options(button_color=color_tuple)
    return DEFAULT_BUTTON_COLOR


def theme_button_color_background():
    """Returns the button color background currently in use

    NOTE: This function simply calls the `theme_button_color`
    function and splits apart the tuple.

    :return: color string of the button color background currently in use
    :rtype:  (str)
    """
    return theme_button_color()[1]


def theme_button_color_text():
    """Returns the button color text currently in use

    NOTE: This function simply calls the `theme_button_color`
    function and splits apart the tuple.

    :return: color string of the button color text currently in use
    :rtype:  (str)
    """
    return theme_button_color()[0]


def theme_progress_bar_color(color=None):
    """Sets or gets the progress bar colors by the current color theme

    :return: (str, str) - TUPLE with color strings of the ProgressBar color currently in use(button text color, button background color)
    :rtype:  (str, str)
    """
    if color is not None:
        set_options(progress_meter_color=color)
    return DEFAULT_PROGRESS_BAR_COLOR


def theme_slider_color(color=None):
    """Sets or gets the slider color (used for sliders)

    :return: color string of the slider color currently in use
    :rtype:  (str)
    """
    if color is not None:
        set_options(scrollbar_color=color)
    return DEFAULT_SCROLLBAR_COLOR


def theme_border_width(border_width=None):
    """Sets or gets the border width currently in use

    Used by non ttk elements at the moment.

    :return: border width currently in use
    :rtype:  (int)
    """
    if border_width is not None:
        set_options(border_width=border_width)
    return DEFAULT_BORDER_WIDTH


def theme_slider_border_width(border_width=None):
    """Sets or gets the slider border width currently in use

    :return: border width currently in use for sliders
    :rtype:  (int)
    """
    if border_width is not None:
        set_options(slider_border_width=border_width)
    return DEFAULT_SLIDER_BORDER_WIDTH


def theme_progress_bar_border_width(border_width=None):
    """Sets or gets the progress meter border width currently in use

    :return: border width currently in use for progress meters
    :rtype:  (int)
    """
    if border_width is not None:
        set_options(progress_meter_border_depth=border_width)
    return DEFAULT_PROGRESS_BAR_BORDER_WIDTH


def theme_element_text_color(color=None):
    """Sets or gets the text color used by elements that have text
        as part of their display (`Tables`, `Trees` and `Sliders`)

    :return: color string currently in use
    :rtype:  (str)
    """
    if color is not None:
        set_options(element_text_color=color)
    return DEFAULT_ELEMENT_TEXT_COLOR


def theme_list():
    """Returns a sorted list of the currently available color themes

    :return: A sorted list of the currently available color themes
    :rtype:  List[str]
    """
    return list_of_look_and_feel_values()


def theme_add_new(new_theme_name, new_theme_dict):
    """Adds a new theme to the dictionary of themes

    :param new_theme_name: text to display in element
    :type new_theme_name:  (str)
    :param new_theme_dict: text to display in element
    :type new_theme_dict:  (dict)
    """
    global LOOK_AND_FEEL_TABLE
    try:
        LOOK_AND_FEEL_TABLE[new_theme_name] = new_theme_dict
    except Exception as e:
        print('Exception during adding new theme {}'.format(e))


def theme_use_custom_titlebar():
    """Returns `True` if a custom title bar will / should be used

    The setting is in the Global Settings window and can be overwridden
    using set_options call

    :return:        True if a custom titlebar / custom menubar should be used
    :rtype:         (bool)
    """
    if USE_CUSTOM_TITLEBAR is False:
        return False
    return USE_CUSTOM_TITLEBAR or freesimplegui_user_settings.get('-custom titlebar-', False)


def theme_global(new_theme=None):
    """Sets or gets the global framework Theme

    If none is specified then returns the global theme from user settings.
    Note the theme must be a standard, built-in framework theme, not a user-created theme.

    :param new_theme: the new theme name to use
    :type new_theme:  (str)
    :return:          the currently selected theme
    :rtype:           (str)
    """
    if new_theme is not None:
        if new_theme not in theme_list():
            popup_error_with_traceback(
                'Cannot use custom themes with theme_global call',
                'Your request to use theme {} cannot be performed.'.format(new_theme),
                'The FreeSimpleGUI Global User Settings are meant for FreeSimpleGUI standard items, not user config items',
                'You can use any of the many built-in themes instead or use your own UserSettings file to store your custom theme'
            )
            return freesimplegui_user_settings.get('-theme-', CURRENT_LOOK_AND_FEEL)
        freesimplegui_user_settings.set('-theme-', new_theme)
        theme(new_theme)
        return new_theme
    else:
        return freesimplegui_user_settings.get('-theme-', CURRENT_LOOK_AND_FEEL)


def theme_previewer(columns=12, scrollable=False, scroll_area_size=(None, None), search_string=None, location=(None, None)):
    """Displays a Quick Reference Window

    Showing all of the different Look and Feel settings that are available.
    They are sorted alphabetically.  The legacy color names are mixed in,
    but otherwise they are sorted into Dark and Light halves

    :param columns:          The number of themes to display per row
    :type columns:           int
    :param scrollable:       If True then scrollbars will be added
    :type scrollable:        bool
    :param scroll_area_size: Size of the scrollable area (The Column Element used to make scrollable)
    :type scroll_area_size:  (int, int)
    :param search_string:    If specified then only themes containing this string will be shown
    :type search_string:     str
    :param location:         Location on the screen to place the window. Defaults to the center like all windows
    :type location:          (int, int)
    """
    current_theme = theme()

    # Show a "splash" type message so the user doesn't give up waiting
    popup_quick_message('Hang on for a moment, this will take a bit to create....', keep_on_top=True, background_color='red', text_color='#FFFFFF',
                        auto_close=True, non_blocking=True)

    web = False
    win_bg = 'black'

    def sample_layout():
        return [[Text('Text element'), InputText('Input data here', size=(10, 1))],
                [Button('Ok'), Button('Disabled', disabled=True), Slider((1, 10), orientation='h', size=(5, 15))]]

    names = list_of_look_and_feel_values()
    names.sort()
    if search_string not in (None, ''):
        names = [name for name in names if search_string.lower().replace(" ", "") in name.lower().replace(" ", "")]

    if search_string not in (None, ''):
        layout = [[Text('Themes containing "{}"'.format(search_string), font='Default 18', background_color=win_bg)]]
    else:
        layout = [[Text('List of all themes', font='Default 18', background_color=win_bg)]]

    col_layout = []
    row = []
    for count, theme_name in enumerate(names):
        theme(theme_name)
        if not count % columns:
            col_layout += [row]
            row = []
        row += [Frame(theme_name, sample_layout() if not web else [[T(theme_name)]] + sample_layout(), pad=(2, 2))]
    if row:
        col_layout += [row]

    layout += [[Column(col_layout, scrollable=scrollable, size=scroll_area_size, pad=(0, 0), background_color=win_bg, key='-COL-')]]
    window = Window('Preview of Themes', layout, background_color=win_bg, resizable=True, location=location, keep_on_top=True, finalize=True, modal=True)
    window['-COL-'].expand(True, True, True)  # needed so that col will expand with the window
    window.read(close=True)
    theme(current_theme)


preview_all_look_and_feel_themes = theme_previewer

def _theme_preview_window_swatches():
    # Begin the layout with a header
    layout = [
        [Text('Themes as color swatches', text_color='white', background_color='black', font='Default 25')],
        [Text('Tooltip and right click a color to get the value', text_color='white', background_color='black', font='Default 15')],
        [Text('Left click a color to copy to clipboard', text_color='white', background_color='black', font='Default 15')]
    ]
    layout = [[Column(layout, element_justification='c', background_color='black')]]

    # Create the pain part, the rows of Text with color swatches
    for i, theme_name in enumerate(theme_list()):
        theme(theme_name)
        colors = [theme_background_color(), theme_text_color(), theme_input_background_color(),
                  theme_input_text_color()]
        if theme_button_color() != COLOR_SYSTEM_DEFAULT:
            colors.append(theme_button_color()[0])
            colors.append(theme_button_color()[1])
        colors = list(set(colors))  # de-duplicate items
        row = [T(theme(), background_color='black', text_color='white', size=(20, 1), justification='r')]
        for color in colors:
            if color != COLOR_SYSTEM_DEFAULT:
                row.append(T(SYMBOL_SQUARE, text_color=color, background_color='black', pad=(0, 0), font='DEFAUlT 20', right_click_menu=['Nothing', [color]],
                             tooltip=color, enable_events=True, key=(i, color)))
        layout += [row]
    # place layout inside of a Column so that it's scrollable
    layout = [[Column(layout, size=(500, 900), scrollable=True, vertical_scroll_only=True, background_color='black')]]
    # finish the layout by adding an exit button
    layout += [[B('Exit')]]
    # create and return Window that uses the layout
    return Window('Theme Color Swatches', layout, background_color='black', finalize=True, keep_on_top=True)


def theme_previewer_swatches():
    """Displays themes in a window as color swatches

    Click on a color swatch to see the hex value printed on the console.
    If you hover over a color or right click it you'll also see the hex value.
    """
    current_theme = theme()
    popup_quick_message(
        'This is going to take a minute...',
        text_color='white', background_color='red',
        font='Default 20', keep_on_top=True
    )
    window = _theme_preview_window_swatches()
    theme(OFFICIAL_FREESIMPLEGUI_THEME)

    while True:  # Event Loop
        event, values = window.read()
        if event == WIN_CLOSED or event == 'Exit':
            break
        if isinstance(event, tuple):  # clicked a swatch
            chosen_color = event[1]
        else:
            if event[0] == '#':  # right-clicked
                chosen_color = event
            else:
                chosen_color = ''
        print('Copied to clipboard color = ', chosen_color)
        clipboard_set(chosen_color)

    window.close()
    theme(current_theme)


def change_look_and_feel(index, force=False):
    """Changes the color scheme of all new framework Windows

    The scheme are string names that specify a group of colors. Background colors, text colors, button colors.
    There are 13 different color settings that are changed at one time using a single call to ChangeLookAndFeel
    The look and feel table itself has these indexes into the dictionary LOOK_AND_FEEL_TABLE.
    The original list was (prior to a major rework and renaming)... these names still work...
    In Nov 2019 a new Theme Formula was devised to make choosing a theme easier:
    The "Formula" is:
    ["Dark" or "Light"] Color Number
    Colors can be Blue Brown Grey Green Purple Red Teal Yellow Black
    The number will vary for each pair. There are more DarkGrey entries than there are LightYellow for example.
    Default = The default settings (only button color is different than system default)
    Default1 = The full system default including the button (everything's gray... how sad... don't be all gray... please....)
    :param index: the name of the index into the Look and Feel table (does not have to be exact, can be "fuzzy")
    :type index:  (str)
    :param force: no longer used
    :type force:  (bool)
    :return:      None
    :rtype:       None
    """
    global CURRENT_LOOK_AND_FEEL

    requested_theme_name = index
    theme_names_list = list_of_look_and_feel_values()
    # normalize available l&f values by setting all to lower case
    lf_values_lowercase = [item.lower() for item in theme_names_list]

    # option 1
    opt1 = requested_theme_name.replace(' ', '').lower()

    # option 3 is option 1 with gray replaced with grey
    opt3 = opt1.replace('gray', 'grey')

    # option 2 (reverse lookup)
    optx = requested_theme_name.lower().split(' ')
    optx.reverse()
    opt2 = ''.join(optx)

    # search for valid l&f name
    if requested_theme_name in theme_names_list:
        ix = theme_names_list.index(requested_theme_name)
    elif opt1 in lf_values_lowercase:
        ix = lf_values_lowercase.index(opt1)
    elif opt2 in lf_values_lowercase:
        ix = lf_values_lowercase.index(opt2)
    elif opt3 in lf_values_lowercase:
        ix = lf_values_lowercase.index(opt3)
    else:
        ix = random.randint(0, len(lf_values_lowercase) - 1)
        print('** Warning - {} Theme is not a valid theme. Change your theme call. **'.format(index))
        print('valid values are', list_of_look_and_feel_values())
        print('Instead, please enjoy a random Theme named {}'.format(list_of_look_and_feel_values()[ix]))

    selection = theme_names_list[ix]
    CURRENT_LOOK_AND_FEEL = selection
    try:
        colors = LOOK_AND_FEEL_TABLE[selection]

        # Color the progress bar using button background and input colors...unless they're the same
        if colors['PROGRESS'] != COLOR_SYSTEM_DEFAULT:
            if colors['PROGRESS'] == DEFAULT_PROGRESS_BAR_COMPUTE:
                if colors['BUTTON'][1] != colors['INPUT'] and colors['BUTTON'][1] != colors['BACKGROUND']:
                    colors['PROGRESS'] = colors['BUTTON'][1], colors['INPUT']
                else:  # if the same, then use text input on top of input color
                    colors['PROGRESS'] = (colors['TEXT_INPUT'], colors['INPUT'])
        else:
            colors['PROGRESS'] = DEFAULT_PROGRESS_BAR_COLOR_OFFICIAL
        # call to change all the colors
        SetOptions(background_color=colors['BACKGROUND'],
                   text_element_background_color=colors['BACKGROUND'],
                   element_background_color=colors['BACKGROUND'],
                   text_color=colors['TEXT'],
                   input_elements_background_color=colors['INPUT'],
                   # button_color=colors['BUTTON'] if not running_mac() else None,
                   button_color=colors['BUTTON'],
                   progress_meter_color=colors['PROGRESS'],
                   border_width=colors['BORDER'],
                   slider_border_width=colors['SLIDER_DEPTH'],
                   progress_meter_border_depth=colors['PROGRESS_DEPTH'],
                   scrollbar_color=(colors['SCROLL']),
                   element_text_color=colors['TEXT'],
                   input_text_color=colors['TEXT_INPUT']
        )
    except:  # most likely an index out of range
        print('** Warning - Theme value not valid. Change your theme call. **')
        print('valid values are', list_of_look_and_feel_values())


# ------------------------ Color processing functions ------------------------

def _hex_to_hsl(hex):
    r, g, b = _hex_to_rgb(hex)
    return _rgb_to_hsl(r, g, b)

def _hex_to_rgb(hex):
    hex = hex.lstrip('#')
    hlen = len(hex)
    return tuple(int(hex[i:i + hlen // 3], 16) for i in range(0, hlen, hlen // 3))

def _rgb_to_hsl(r, g, b):
    r = float(r)
    g = float(g)
    b = float(b)
    high = max(r, g, b)
    low = min(r, g, b)
    h, s, v = ((high + low) / 2,) * 3
    if high == low:
        h = s = 0.0
    else:
        d = high - low
        l = (high + low) / 2
        s = d / (2 - high - low) if l > 0.5 else d / (high + low)
        h = {
            r: (g - b) / d + (6 if g < b else 0),
            g: (b - r) / d + 2,
            b: (r - g) / d + 4,
        }[high]
        h /= 6
    return h, s, v

def _hsl_to_rgb(h, s, l):
    def hue_to_rgb(p, q, t):
        t += 1 if t < 0 else 0
        t -= 1 if t > 1 else 0
        if t < 1 / 6: return p + (q - p) * 6 * t
        if t < 1 / 2: return q
        if t < 2 / 3: return p + (q - p) * (2 / 3 - t) * 6
        return p

    if s == 0:
        r, g, b = l, l, l
    else:
        q = l * (1 + s) if l < 0.5 else l + s - l * s
        p = 2 * l - q
        r = hue_to_rgb(p, q, h + 1 / 3)
        g = hue_to_rgb(p, q, h)
        b = hue_to_rgb(p, q, h - 1 / 3)

    return r, g, b

def _hsv_to_hsl(h, s, v):
    l = 0.5 * v * (2 - s)
    s = v * s / (1 - fabs(2 * l - 1))
    return h, s, l

def _hsl_to_hsv(h, s, l):
    v = (2 * l + s * (1 - fabs(2 * l - 1))) / 2
    s = 2 * (v - l) / v
    return h, s, v


# Converts an object's contents into a nice printable string.  Great for dumping debug data
def obj_to_string_single_obj(obj):
    """
    Dumps an Object's values as a formatted string.  Very nicely done. Great way to display an object's member variables in human form
    Returns only the top-most object's variables instead of drilling down to dispolay more
    :param obj: The object to display
    :type obj:  (Any)
    :return:    Formatted output of the object's values
    :rtype:     (str)
    """
    if obj is None:
        return 'None'
    return str(obj.__class__) + '\n' + '\n'.join(
        (repr(item) + ' = ' + repr(obj.__dict__[item]) for item in sorted(obj.__dict__)))


def obj_to_string(obj, extra='    '):
    """
    Dumps an Object's values as a formatted string.  Very nicely done. Great way to display an object's member variables in human form
    :param obj:   The object to display
    :type obj:    (Any)
    :param extra: extra stuff (Default value = '    ')
    :type extra:  (str)
    :return:      Formatted output of the object's values
    :rtype:       (str)
    """
    if obj is None:
        return 'None'
    return str(obj.__class__) + '\n' + '\n'.join(
        (extra + (str(item) + ' = ' +
                  (ObjToString(obj.__dict__[item], extra + '    ') if hasattr(obj.__dict__[item], '__dict__') else str(
                      obj.__dict__[item])))
         for item in sorted(obj.__dict__)))


# ...######..##.......####.########..########...#######.....###....########..########.
# ..##....##.##........##..##.....##.##.....##.##.....##...##.##...##.....##.##.....##
# ..##.......##........##..##.....##.##.....##.##.....##..##...##..##.....##.##.....##
# ..##.......##........##..########..########..##.....##.##.....##.########..##.....##
# ..##.......##........##..##........##.....##.##.....##.#########.##...##...##.....##
# ..##....##.##........##..##........##.....##.##.....##.##.....##.##....##..##.....##
# ...######..########.####.##........########...#######..##.....##.##.....##.########.

def clipboard_set(new_value):
    """Sets the clipboard to a specific value

    IMPORTANT NOTE: Your framework application needs to remain running
    until you've pasted your clipboard. This is a tkinter limitation.
    A workaround was found for Windows, but you still need to stay running
    for Linux systems.

    :param new_value: value to set the clipboard to. Will be converted to a string
    :type new_value:  (str | bytes)
    """
    root = _get_hidden_master_root()
    root.clipboard_clear()
    root.clipboard_append(str(new_value))
    root.update()


def clipboard_get():
    """Gets the clipboard current value

    :return: The current value of the clipboard
    :rtype:  (str)
    """
    root = _get_hidden_master_root()
    try:
        value = root.clipboard_get()
    except:
        value = ''
    root.update()
    return value


# MM"""""""`YM
# MM  mmmmm  M
# M'        .M .d8888b. 88d888b. dP    dP 88d888b. .d8888b.
# MM  MMMMMMMM 88'  `88 88'  `88 88    88 88'  `88 Y8ooooo.
# MM  MMMMMMMM 88.  .88 88.  .88 88.  .88 88.  .88       88
# MM  MMMMMMMM `88888P' 88Y888P' `88888P' 88Y888P' `88888P'
# MMMMMMMMMMMM          88                88
#                       dP                dP
# ------------------------------------------------------------------------------------------------------------------ #
# =====================================   Upper FreeSimpleGUI ======================================================== #
# ------------------------------------------------------------------------------------------------------------------ #
# ----------------------------------- The mighty Popup! ------------------------------------------------------------ #

def popup(*args, title=None, button_color=None, background_color=None, text_color=None, button_type=POPUP_BUTTONS_OK, auto_close=False,
          auto_close_duration=None, custom_text=(None, None), non_blocking=False, icon=None, line_width=None, font=None, no_titlebar=False, grab_anywhere=False,
          keep_on_top=None, location=(None, None), relative_location=(None, None), any_key_closes=False, image=None, modal=True, button_justification=None, drop_whitespace=True):
    """Popup

    Display a popup Window with as many parameters as you wish to include.
    This is the GUI equivalent of the `print` statement.
    It's also great for "pausing" your program's flow until the user can read some error messages.

    If this popup doesn't have the features you want, then you can easily make your own.
    Popups can be accomplished like this:

    ```
        choice, _ = sg.Window(
            'Continue?', [
                [sg.T('Do you want to continue?')], [sg.Yes(s=10), sg.No(s=10)]
            ], disable_close=True).read(close=True)
    ```

    :param *args:                 Variable number of your arguments.  Load up the call with stuff to see!
    :type *args:                  (Any)
    :param title:                 Optional title for the window. If none provided, the first arg will be used instead.
    :type title:                  (str)
    :param button_color:          Color of the buttons shown (text color, button color)
    :type button_color:           (str, str) | str
    :param background_color:      Window's background color
    :type background_color:       (str)
    :param text_color:            text color
    :type text_color:             (str)
    :param button_type:           NOT USER SET!  Determines which pre-defined buttons will be shown (Default value = POPUP_BUTTONS_OK). There are many Popup functions and they call Popup, changing this parameter to get the desired effect.
    :type button_type:            (int)
    :param auto_close:            If True the window will automatically close
    :type auto_close:             (bool)
    :param auto_close_duration:   time in seconds to keep window open before closing it automatically
    :type auto_close_duration:    (int)
    :param custom_text:           A string or pair of strings that contain the text to display on the buttons
    :type custom_text:            (str, str) | str
    :param non_blocking:          If True then will immediately return from the function without waiting for the user's input.
    :type non_blocking:           (bool)
    :param icon:                  icon to display on the window. Same format as a Window call
    :type icon:                   str | bytes
    :param line_width:            Width of lines in characters.  Defaults to MESSAGE_BOX_LINE_WIDTH
    :type line_width:             (int)
    :param font:                  specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                   str | Tuple[font_name, size, modifiers]
    :param no_titlebar:           If True will not show the frame around the window and the titlebar across the top
    :type no_titlebar:            (bool)
    :param grab_anywhere:         If True can grab anywhere to move the window. If no_titlebar is True, grab_anywhere should likely be enabled too
    :type grab_anywhere:          (bool)
    :param location:              Location on screen to display the top left corner of window. Defaults to window centered on screen
    :type location:               (int, int)
    :param relative_location:     (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:      (int, int)
    :param keep_on_top:           If True the window will remain above all current windows
    :type keep_on_top:            (bool)
    :param any_key_closes:        If True then will turn on return_keyboard_events for the window which will cause window to close as soon as any key is pressed.  Normally the return key only will close the window.  Default is false.
    :type any_key_closes:         (bool)
    :param image:                 Image to include at the top of the popup window
    :type image:                  (str) or (bytes)
    :param modal:                 If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                  bool
    :param right_justify_buttons: If True then the buttons will be "pushed" to the right side of the Window
    :type right_justify_buttons:  bool
    :param button_justification:  Speficies if buttons should be left, right or centered. Default is left justified
    :type button_justification:   str
    :param drop_whitespace:       Controls is whitespace should be removed when wrapping text.  Parameter is passed to textwrap.fill. Default is to drop whitespace (so popup remains backward compatible)
    :type drop_whitespace:        bool
    :return:                      Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                       str | None
    """
    if not args:
        args_to_print = ['']
    else:
        args_to_print = args
    if line_width != None:
        local_line_width = line_width
    else:
        local_line_width = MESSAGE_BOX_LINE_WIDTH
    _title = title if title is not None else args_to_print[0]

    layout = [[]]
    max_line_total, total_lines = 0, 0
    if image is not None:
        if isinstance(image, str):
            layout += [[Image(filename=image)]]
        else:
            layout += [[Image(data=image)]]

    for message in args_to_print:
        message = str(message)
        if message.count('\n'):  # if there are line breaks, then wrap each segment separately
            message_wrapped = ''
            msg_list = message.split('\n')  # break into segments that will each be wrapped
            message_wrapped = '\n'.join([textwrap.fill(msg, local_line_width) for msg in msg_list])
        else:
            message_wrapped = textwrap.fill(message, local_line_width, drop_whitespace=drop_whitespace)
        message_wrapped_lines = message_wrapped.count('\n') + 1
        longest_line_len = max([len(l) for l in message.split('\n')])
        width_used = min(longest_line_len, local_line_width)
        max_line_total = max(max_line_total, width_used)
        height = message_wrapped_lines
        layout += [[
            Text(message_wrapped, auto_size_text=True, text_color=text_color, background_color=background_color)]]
        total_lines += height

    if non_blocking:
        PopupButton = DummyButton  # important to use or else button will close other windows too!
    else:
        PopupButton = Button

    # show either an OK or Yes/No depending on paramater
    if custom_text != (None, None):
        if type(custom_text) is not tuple:
            layout += [[PopupButton(custom_text, size=(len(custom_text), 1), button_color=button_color, focus=True,
                                    bind_return_key=True)]]
        elif custom_text[1] is None:
            layout += [[
                PopupButton(custom_text[0], size=(len(custom_text[0]), 1), button_color=button_color, focus=True,
                            bind_return_key=True)]]
        else:
            layout += [[PopupButton(custom_text[0], button_color=button_color, focus=True, bind_return_key=True,
                                    size=(len(custom_text[0]), 1)),
                        PopupButton(custom_text[1], button_color=button_color, size=(len(custom_text[1]), 1))]]
    elif button_type == POPUP_BUTTONS_YES_NO:
        layout += [[PopupButton('Yes', button_color=button_color, focus=True, bind_return_key=True,
                                size=(5, 1)), PopupButton('No', button_color=button_color, size=(5, 1))]]
    elif button_type == POPUP_BUTTONS_CANCELLED:
        layout += [[
            PopupButton('Cancelled', button_color=button_color, focus=True, bind_return_key=True)]]
    elif button_type == POPUP_BUTTONS_ERROR:
        layout += [[PopupButton('Error', size=(6, 1), button_color=button_color, focus=True, bind_return_key=True)]]
    elif button_type == POPUP_BUTTONS_OK_CANCEL:
        layout += [[PopupButton('OK', size=(6, 1), button_color=button_color, focus=True, bind_return_key=True),
                    PopupButton('Cancel', size=(6, 1), button_color=button_color)]]
    elif button_type == POPUP_BUTTONS_NO_BUTTONS:
        pass
    else:
        layout += [[PopupButton('OK', size=(5, 1), button_color=button_color, focus=True, bind_return_key=True, )]]
    if button_justification is not None:
        justification = button_justification.lower()[0]
        if justification == 'r':
            layout[-1] = [Push()] + layout[-1]
        elif justification == 'c':
            layout[-1] = [Push()] + layout[-1] + [Push()]

    window = Window(_title, layout, auto_size_text=True, background_color=background_color, button_color=button_color,
                    auto_close=auto_close, auto_close_duration=auto_close_duration, icon=icon, font=font,
                    no_titlebar=no_titlebar, grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, location=location, relative_location=relative_location,
                    return_keyboard_events=any_key_closes,
                    modal=modal)

    if non_blocking:
        button, values = window.read(timeout=0)
    else:
        button, values = window.read()
        window.close()
        del window

    return button


# ========================  Scrolled Text Box   =====#
# ===================================================#
def popup_scrolled(*args, title=None, button_color=None, background_color=None, text_color=None, yes_no=False, no_buttons=False, button_justification='l', auto_close=False,
                   auto_close_duration=None, size=(None, None), location=(None, None), relative_location=(None, None), non_blocking=False, no_titlebar=False, grab_anywhere=False,
                   keep_on_top=None, font=None, image=None, icon=None, modal=True, no_sizegrip=False):
    """Shows a scrolled Popup window containing the user supplied text

    Use with as many items to print as you want, just like a print statement.

    :param *args:                 Variable number of items to display
    :type *args:                  (Any)
    :param title:                 Title to display in the window.
    :type title:                  (str)
    :param button_color:          button color (foreground, background)
    :type button_color:           (str, str) | str
    :param yes_no:                If True, displays Yes and No buttons instead of Ok
    :type yes_no:                 (bool)
    :param no_buttons:            If True, no buttons will be shown. User will have to close using the "X"
    :type no_buttons:             (bool)
    :param button_justification:  How buttons should be arranged.  l, c, r for Left, Center or Right justified
    :type button_justification:   (str)
    :param auto_close:            if True window will close itself
    :type auto_close:             (bool)
    :param auto_close_duration:   Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:    int | float
    :param size:                  (w,h) w=characters-wide, h=rows-high
    :type size:                   (int, int)
    :param location:              Location on the screen to place the upper left corner of the window
    :type location:               (int, int)
    :param relative_location:     (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:      (int, int)
    :param non_blocking:          if True the call will immediately return rather than waiting on user input
    :type non_blocking:           (bool)
    :param background_color:      color of background
    :type background_color:       (str)
    :param text_color:            color of the text
    :type text_color:             (str)
    :param no_titlebar:           If True no titlebar will be shown
    :type no_titlebar:            (bool)
    :param grab_anywhere:         If True, than can grab anywhere to move the window (Default = False)
    :type grab_anywhere:          (bool)
    :param keep_on_top:           If True the window will remain above all current windows
    :type keep_on_top:            (bool)
    :param font:                  specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                   (str or (str, int[, str]) or None)
    :param image:                 Image to include at the top of the popup window
    :type image:                  (str) or (bytes)
    :param icon:                  filename or base64 string to be used for the window's icon
    :type icon:                   bytes | str
    :param modal:                 If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                  bool
    :param no_sizegrip:           If True no Sizegrip will be shown when there is no titlebar. It's only shown if there is no titlebar
    :type no_sizegrip:            (bool)
    :return:                      Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                       str | None | TIMEOUT_KEY
    """
    if not args:
        return
    width, height = size
    width = width if width else MESSAGE_BOX_LINE_WIDTH

    layout = [[]]

    if image is not None:
        if isinstance(image, str):
            layout += [[Image(filename=image)]]
        else:
            layout += [[Image(data=image)]]
    max_line_total, max_line_width, total_lines, height_computed = 0, 0, 0, 0
    complete_output = ''
    for message in args:
        # fancy code to check if string and convert if not is not need. Just always convert to string :-)
        # if not isinstance(message, str): message = str(message)
        message = str(message)
        longest_line_len = max([len(l) for l in message.split('\n')])
        width_used = min(longest_line_len, width)
        max_line_total = max(max_line_total, width_used)
        max_line_width = width
        lines_needed = _GetNumLinesNeeded(message, width_used)
        height_computed += lines_needed + 1
        complete_output += message + '\n'
        total_lines += lines_needed
    height_computed = MAX_SCROLLED_TEXT_BOX_HEIGHT if height_computed > MAX_SCROLLED_TEXT_BOX_HEIGHT else height_computed
    if height:
        height_computed = height
    layout += [[Multiline(complete_output, size=(max_line_width, height_computed), background_color=background_color, text_color=text_color, expand_x=True,
                          expand_y=True, k='-MLINE-')]]
    # show either an OK or Yes/No depending on paramater
    button = DummyButton if non_blocking else Button

    if yes_no:
        buttons = [button('Yes'), button('No')]
    elif no_buttons is not True:
        buttons = [button('OK', size=(5, 1), button_color=button_color)]
    else:
        buttons = None

    if buttons is not None:
        if button_justification.startswith('l'):
            layout += [buttons]
        elif button_justification.startswith('c'):
            layout += [[Push()] + buttons + [Push()]]
        else:
            layout += [[Push()] + buttons]

    if no_sizegrip is not True:
        layout[-1] += [Sizegrip()]

    window = Window(title or args[0], layout, auto_size_text=True, button_color=button_color, auto_close=auto_close,
                    auto_close_duration=auto_close_duration, location=location, relative_location=relative_location, resizable=True, font=font, background_color=background_color,
                    no_titlebar=no_titlebar, grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, modal=modal, icon=icon)
    if non_blocking:
        button, values = window.read(timeout=0)
    else:
        button, values = window.read()
        window.close()
        del window

    return button


# ============================== sprint ======#
# Is identical to the Scrolled Text Box       #
# Provides a crude 'print' mechanism but in a #
# GUI environment                             #
# This is in addition to the Print function   #
# which routes output to a "Debug Window"     #
# ============================================#


# --------------------------- popup_no_buttons ---------------------------
def popup_no_buttons(*args, title=None, background_color=None, text_color=None, auto_close=False,
                     auto_close_duration=None, non_blocking=False, icon=None, line_width=None, font=None,
                     no_titlebar=False, grab_anywhere=False, keep_on_top=None, location=(None, None), relative_location=(None, None), image=None, modal=True):
    """Shows a `Popup` but without any buttons

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        If True then will immediately return from the function without waiting for the user's input. (Default = False)
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True, than can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY    """
    Popup(*args, title=title, background_color=background_color, text_color=text_color,
          button_type=POPUP_BUTTONS_NO_BUTTONS,
          auto_close=auto_close, auto_close_duration=auto_close_duration, non_blocking=non_blocking, icon=icon,
          line_width=line_width,
          font=font, no_titlebar=no_titlebar, grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, location=location, relative_location=relative_location, image=image, modal=modal)


# --------------------------- popup_non_blocking ---------------------------
def popup_non_blocking(*args, title=None, button_type=POPUP_BUTTONS_OK, button_color=None, background_color=None,
                       text_color=None, auto_close=False, auto_close_duration=None, non_blocking=True, icon=None,
                       line_width=None, font=None, no_titlebar=False, grab_anywhere=False, keep_on_top=None,
                       location=(None, None), relative_location=(None, None), image=None, modal=False):
    """Shows a `Popup` window and immediately return (non-blocking)

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_type:         Determines which pre-defined buttons will be shown (Default value = POPUP_BUTTONS_OK).
    :type button_type:          (int)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) | str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = False
    :type modal:                bool
    :return:                    Reason for popup closing
    :rtype:                     str | None
    """
    return popup(*args, title=title, button_color=button_color, background_color=background_color, text_color=text_color,
                 button_type=button_type,
                 auto_close=auto_close, auto_close_duration=auto_close_duration, non_blocking=non_blocking, icon=icon,
                 line_width=line_width,
                 font=font, no_titlebar=no_titlebar, grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, location=location, relative_location=relative_location, image=image, modal=modal)


# --------------------------- popup_quick - a NonBlocking, Self-closing Popup  ---------------------------
def popup_quick(*args, title=None, button_type=POPUP_BUTTONS_OK, button_color=None, background_color=None,
                text_color=None, auto_close=True, auto_close_duration=2, non_blocking=True, icon=None, line_width=None,
                font=None, no_titlebar=False, grab_anywhere=False, keep_on_top=None, location=(None, None), relative_location=(None, None), image=None, modal=False):
    """Shows a `Popup` box that doesn't block and closes itself

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_type:         Determines which pre-defined buttons will be shown (Default value = POPUP_BUTTONS_OK).
    :type button_type:          (int)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) | str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = False
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    return popup(*args, title=title, button_color=button_color, background_color=background_color, text_color=text_color,
                 button_type=button_type,
                 auto_close=auto_close, auto_close_duration=auto_close_duration, non_blocking=non_blocking, icon=icon,
                 line_width=line_width,
                 font=font, no_titlebar=no_titlebar, grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, location=location, relative_location=relative_location, image=image, modal=modal)


# --------------------------- popup_quick_message - a NonBlocking, Self-closing Popup with no titlebar and no buttons ---------------------------
def popup_quick_message(*args, title=None, button_type=POPUP_BUTTONS_NO_BUTTONS, button_color=None, background_color=None,
                        text_color=None, auto_close=True, auto_close_duration=2, non_blocking=True, icon=None, line_width=None,
                        font=None, no_titlebar=True, grab_anywhere=False, keep_on_top=True, location=(None, None), relative_location=(None, None), image=None, modal=False):
    """Shows a `Popup` window with no title bar, doesn't block, and auto closes itself

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_type:         Determines which pre-defined buttons will be shown (Default value = POPUP_BUTTONS_OK).
    :type button_type:          (int)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) | str
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = False
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    return popup(*args, title=title, button_color=button_color, background_color=background_color, text_color=text_color,
                 button_type=button_type,
                 auto_close=auto_close, auto_close_duration=auto_close_duration, non_blocking=non_blocking, icon=icon,
                 line_width=line_width,
                 font=font, no_titlebar=no_titlebar, grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, location=location, relative_location=relative_location, image=image, modal=modal)


# --------------------------- PopupNoTitlebar ---------------------------
def popup_no_titlebar(*args, title=None, button_type=POPUP_BUTTONS_OK, button_color=None, background_color=None,
                      text_color=None, auto_close=False, auto_close_duration=None, non_blocking=False, icon=None,
                      line_width=None, font=None, grab_anywhere=True, keep_on_top=None, location=(None, None), relative_location=(None, None), image=None, modal=True):
    """Display a `Popup` without a title bar

    Enables grab anywhere so you can move it.

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_type:         Determines which pre-defined buttons will be shown (Default value = POPUP_BUTTONS_OK).
    :type button_type:          (int)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) | str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    return popup(*args, title=title, button_color=button_color, background_color=background_color, text_color=text_color,
                 button_type=button_type,
                 auto_close=auto_close, auto_close_duration=auto_close_duration, non_blocking=non_blocking, icon=icon,
                 line_width=line_width,
                 font=font, no_titlebar=True, grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, location=location, relative_location=relative_location, image=image, modal=modal)


# --------------------------- PopupAutoClose ---------------------------
def popup_auto_close(*args, title=None, button_type=POPUP_BUTTONS_OK, button_color=None, background_color=None, text_color=None,
                     auto_close=True, auto_close_duration=None, non_blocking=False, icon=None,
                     line_width=None, font=None, no_titlebar=False, grab_anywhere=False, keep_on_top=None,
                     location=(None, None), relative_location=(None, None), image=None, modal=True):
    """`Popup` that closes itself after some time period (AKA UX cancer)

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_type:         Determines which pre-defined buttons will be shown (Default value = POPUP_BUTTONS_OK).
    :type button_type:          (int)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) | str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    return popup(*args, title=title, button_color=button_color, background_color=background_color, text_color=text_color,
                 button_type=button_type,
                 auto_close=auto_close, auto_close_duration=auto_close_duration, non_blocking=non_blocking, icon=icon,
                 line_width=line_width,
                 font=font, no_titlebar=no_titlebar, grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, location=location, relative_location=relative_location, image=image, modal=modal)


# --------------------------- popup_error ---------------------------
def popup_error(*args, title=None, button_color=(None, None), background_color=None, text_color=None, auto_close=False,
                auto_close_duration=None, non_blocking=False, icon=None, line_width=None, font=None,
                no_titlebar=False, grab_anywhere=False, keep_on_top=None, location=(None, None), relative_location=(None, None), image=None, modal=True):
    """`Popup` with colored button and 'Error' as button text

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) | str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    tbutton_color = DEFAULT_ERROR_BUTTON_COLOR if button_color == (None, None) else button_color
    return popup(*args, title=title, button_type=POPUP_BUTTONS_ERROR, background_color=background_color, text_color=text_color,
                 non_blocking=non_blocking, icon=icon, line_width=line_width, button_color=tbutton_color,
                 auto_close=auto_close,
                 auto_close_duration=auto_close_duration, font=font, no_titlebar=no_titlebar, grab_anywhere=grab_anywhere,
                 keep_on_top=keep_on_top, location=location, relative_location=relative_location, image=image, modal=modal)


# --------------------------- popup_cancel ---------------------------
def popup_cancel(*args, title=None, button_color=None, background_color=None, text_color=None, auto_close=False,
                 auto_close_duration=None, non_blocking=False, icon=None, line_width=None, font=None,
                 no_titlebar=False, grab_anywhere=False, keep_on_top=None, location=(None, None), relative_location=(None, None), image=None, modal=True):
    """Display `Popup` with "cancelled" button text

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) | str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    return popup(*args, title=title, button_type=POPUP_BUTTONS_CANCELLED, background_color=background_color,
                 text_color=text_color,
                 non_blocking=non_blocking, icon=icon, line_width=line_width, button_color=button_color, auto_close=auto_close,
                 auto_close_duration=auto_close_duration, font=font, no_titlebar=no_titlebar, grab_anywhere=grab_anywhere,
                 keep_on_top=keep_on_top, location=location, relative_location=relative_location, image=image, modal=modal)


# --------------------------- popup_ok ---------------------------
def popup_ok(*args, title=None, button_color=None, background_color=None, text_color=None, auto_close=False,
             auto_close_duration=None, non_blocking=False, icon=None, line_width=None, font=None,
             no_titlebar=False, grab_anywhere=False, keep_on_top=None, location=(None, None), relative_location=(None, None), image=None, modal=True):
    """Display `Popup` with 'OK' button only

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) | str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    Returns text of the button that was pressed.  None will be returned if user closed window with X
    :rtype:                     str | None | TIMEOUT_KEY
    """
    return popup(*args, title=title, button_type=POPUP_BUTTONS_OK, background_color=background_color, text_color=text_color,
                 non_blocking=non_blocking, icon=icon, line_width=line_width, button_color=button_color, auto_close=auto_close,
                 auto_close_duration=auto_close_duration, font=font, no_titlebar=no_titlebar, grab_anywhere=grab_anywhere,
                 keep_on_top=keep_on_top, location=location, relative_location=relative_location, image=image, modal=modal)


# --------------------------- popup_ok_cancel ---------------------------
def popup_ok_cancel(*args, title=None, button_color=None, background_color=None, text_color=None, auto_close=False,
                    auto_close_duration=None, non_blocking=False, icon=DEFAULT_WINDOW_ICON, line_width=None, font=None,
                    no_titlebar=False, grab_anywhere=False, keep_on_top=None, location=(None, None), relative_location=(None, None), image=None, modal=True):
    """Display `Popup` with 'OK' and 'Cancel' buttons

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) | str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    clicked button
    :rtype:                     "OK" | "Cancel" | None
    """
    return popup(*args, title=title, button_type=POPUP_BUTTONS_OK_CANCEL, background_color=background_color,
                 text_color=text_color,
                 non_blocking=non_blocking, icon=icon, line_width=line_width, button_color=button_color,
                 auto_close=auto_close, auto_close_duration=auto_close_duration, font=font, no_titlebar=no_titlebar,
                 grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, location=location, relative_location=relative_location, image=image, modal=modal)


# --------------------------- popup_yes_no ---------------------------
def popup_yes_no(*args, title=None, button_color=None, background_color=None, text_color=None, auto_close=False,
                 auto_close_duration=None, non_blocking=False, icon=None, line_width=None, font=None,
                 no_titlebar=False, grab_anywhere=False, keep_on_top=None, location=(None, None), relative_location=(None, None), image=None, modal=True):
    """Display `Popup` with 'Yes' and 'No' buttons

    :param *args:               Variable number of items to display
    :type *args:                (Any)
    :param title:               Title to display in the window.
    :type title:                (str)
    :param button_color:        button color (foreground, background)
    :type button_color:         (str, str) | str
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param auto_close:          if True window will close itself
    :type auto_close:           (bool)
    :param auto_close_duration: Older versions only accept int. Time in seconds until window will close
    :type auto_close_duration:  int | float
    :param non_blocking:        if True the call will immediately return rather than waiting on user input
    :type non_blocking:         (bool)
    :param icon:                filename or base64 string to be used for the window's icon
    :type icon:                 bytes | str
    :param line_width:          Width of lines in characters
    :type line_width:           (int)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 (str or (str, int[, str]) or None)
    :param no_titlebar:         If True no titlebar will be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True the window will remain above all current windows
    :type keep_on_top:          (bool)
    :param location:            Location of upper left corner of the window
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param image:               Image to include at the top of the popup window
    :type image:                (str) or (bytes)
    :param modal:               If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                bool
    :return:                    clicked button
    :rtype:                     "Yes" | "No" | None
    """
    return popup(*args, title=title, button_type=POPUP_BUTTONS_YES_NO, background_color=background_color,
                 text_color=text_color,
                 non_blocking=non_blocking, icon=icon, line_width=line_width, button_color=button_color,
                 auto_close=auto_close, auto_close_duration=auto_close_duration, font=font, no_titlebar=no_titlebar,
                 grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, location=location, relative_location=relative_location, image=image, modal=modal)


##############################################################################
#   The popup_get_____ functions - Will return user input                     #
##############################################################################

# --------------------------- popup_get_folder ---------------------------


def popup_get_folder(message, title=None, default_path='', no_window=False, size=(None, None), button_color=None,
                     background_color=None, text_color=None, icon=None, font=None, no_titlebar=False,
                     grab_anywhere=False, keep_on_top=None, location=(None, None), relative_location=(None, None), initial_folder=None, image=None, modal=True, history=False,
                     history_setting_filename=None):
    """Display `Popup` with text entry field and browse button
        so that a folder can be chosen

    :param message:                  message displayed to user
    :type message:                   (str)
    :param title:                    Window title
    :type title:                     (str)
    :param default_path:             path to display to user as starting point (filled into the input field)
    :type default_path:              (str)
    :param no_window:                if True, no FreeSimpleGUI window will be shown. Instead just the tkinter dialog is shown
    :type no_window:                 (bool)
    :param size:                     (width, height) of the InputText Element
    :type size:                      (int, int)
    :param button_color:             button color (foreground, background)
    :type button_color:              (str, str) | str
    :param background_color:         color of background
    :type background_color:          (str)
    :param text_color:               color of the text
    :type text_color:                (str)
    :param icon:                     filename or base64 string to be used for the window's icon
    :type icon:                      bytes | str
    :param font:                     specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                      (str or (str, int[, str]) or None)
    :param no_titlebar:              If True no titlebar will be shown
    :type no_titlebar:               (bool)
    :param grab_anywhere:            If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:             (bool)
    :param keep_on_top:              If True the window will remain above all current windows
    :type keep_on_top:               (bool)
    :param location:                 Location of upper left corner of the window
    :type location:                  (int, int)
    :param relative_location:        (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:         (int, int)
    :param initial_folder:           location in filesystem to begin browsing
    :type initial_folder:            (str)
    :param image:                    Image to include at the top of the popup window
    :type image:                     (str) or (bytes)
    :param modal:                    If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                     bool
    :param history:                  If True then enable a "history" feature that will display previous entries used. Uses settings filename provided or default if none provided
    :type history:                   bool
    :param history_setting_filename: Filename to use for the User Settings. Will store list of previous entries in this settings file
    :type history_setting_filename:  (str)
    :return:                         string representing the path chosen, None if cancelled or window closed with X
    :rtype:                          str | None
    """
    # First setup the history settings file if history feature is enabled
    if history and history_setting_filename is not None:
        try:
            history_settings = UserSettings(history_setting_filename)
        except Exception as e:
            _error_popup_with_traceback('popup_get_folder - Something is wrong with your supplied history settings filename',
                                        'Exception: {}'.format(e))
            return None
    elif history:
        history_settings_filename = os.path.basename(inspect.stack()[1].filename)
        history_settings_filename = os.path.splitext(history_settings_filename)[0] + '.json'
        history_settings = UserSettings(history_settings_filename)
    else:
        history_settings = None

    if no_window:
        _get_hidden_master_root()
        root = tk.Toplevel()
        try:
            root.attributes('-alpha', 0)  # makes for smoother 'paint'
            try:
                root.wm_overrideredirect(True)
            except Exception as e:
                print('* Error performing wm_overrideredirect while hiding the window during creation in get folder *', e)
            root.withdraw()
        except:
            pass
        folder_name = tk.filedialog.askdirectory(initialdir=initial_folder)  # show the 'get folder' dialog box

        root.destroy()

        return folder_name

    browse_button = FolderBrowse(initial_folder=initial_folder)

    if image is not None:
        if isinstance(image, str):
            layout = [[Image(filename=image)]]
        else:
            layout = [[Image(data=image)]]
    else:
        layout = [[]]

    layout += [[Text(message, auto_size_text=True, text_color=text_color, background_color=background_color)]]

    if not history:
        layout += [[InputText(default_text=default_path, size=size, key='-INPUT-'), browse_button]]
    else:
        file_list = history_settings.get('-PSG folder list-', [])
        last_entry = file_list[0] if file_list else ''
        layout += [[Combo(file_list, default_value=last_entry, key='-INPUT-', size=size if size != (None, None) else (80, 1), bind_return_key=True),
                    browse_button, Button('Clear History', tooltip='Clears the list of folders shown in the combobox')]]

    layout += [[Button('Ok', size=(6, 1), bind_return_key=True), Button('Cancel', size=(6, 1))]]

    window = Window(title=title or message, layout=layout, icon=icon, auto_size_text=True, button_color=button_color,
                    font=font, background_color=background_color, no_titlebar=no_titlebar, grab_anywhere=grab_anywhere, keep_on_top=keep_on_top,
                    location=location, relative_location=relative_location, modal=modal)

    while True:
        event, values = window.read()
        if event in ('Cancel', WIN_CLOSED):
            break
        elif event == 'Clear History':
            history_settings.set('-PSG folder list-', [])
            window['-INPUT-'].update('', [])
            popup_quick_message('History of Previous Choices Cleared', background_color='red', text_color='white', font='_ 20', keep_on_top=True)
        elif event in ('Ok', '-INPUT-'):
            if values['-INPUT-'] != '':
                if history_settings is not None:
                    list_of_entries = history_settings.get('-PSG folder list-', [])
                    if values['-INPUT-'] in list_of_entries:
                        list_of_entries.remove(values['-INPUT-'])
                    list_of_entries.insert(0, values['-INPUT-'])
                    history_settings.set('-PSG folder list-', list_of_entries)
            break

    window.close()
    del window
    if event in ('Cancel', WIN_CLOSED):
        return None

    return values['-INPUT-']


# --------------------------- popup_get_file ---------------------------

def popup_get_file(message, title=None, default_path='', default_extension='', save_as=False, multiple_files=False,
                   file_types=FILE_TYPES_ALL_FILES,
                   no_window=False, size=(None, None), button_color=None, background_color=None, text_color=None,
                   icon=None, font=None, no_titlebar=False, grab_anywhere=False, keep_on_top=None,
                   location=(None, None), relative_location=(None, None), initial_folder=None, image=None, files_delimiter=BROWSE_FILES_DELIMITER, modal=True, history=False, show_hidden=True,
                   history_setting_filename=None):
    """Display `Popup` window with text entry field and browse button
        so that a file can be chosen by user

    :param message:                  message displayed to user
    :type message:                   (str)
    :param title:                    Window title
    :type title:                     (str)
    :param default_path:             path to display to user as starting point (filled into the input field)
    :type default_path:              (str)
    :param default_extension:        If no extension entered by user, add this to filename (only used in saveas dialogs)
    :type default_extension:         (str)
    :param save_as:                  if True, the "save as" dialog is shown which will verify before overwriting
    :type save_as:                   (bool)
    :param multiple_files:           if True, then allows multiple files to be selected that are returned with ';' between each filename
    :type multiple_files:            (bool)
    :param file_types:               List of extensions to show using wildcards. All files (the default) = (("ALL Files", "*.* *"),).
    :type file_types:                Tuple[Tuple[str,str]]
    :param no_window:                if True, no FreeSimpleGUI window will be shown. Instead just the tkinter dialog is shown
    :type no_window:                 (bool)
    :param size:                     (width, height) of the InputText Element or Combo element if using history feature
    :type size:                      (int, int)
    :param button_color:             Color of the button (text, background)
    :type button_color:              (str, str) | str
    :param background_color:         background color of the entire window
    :type background_color:          (str)
    :param text_color:               color of the text
    :type text_color:                (str)
    :param icon:                     filename or base64 string to be used for the window's icon
    :type icon:                      bytes | str
    :param font:                     specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                      (str or (str, int[, str]) or None)
    :param no_titlebar:              If True no titlebar will be shown
    :type no_titlebar:               (bool)
    :param grab_anywhere:            If True: can grab anywhere to move the window (Default = False)
    :type grab_anywhere:             (bool)
    :param keep_on_top:              If True the window will remain above all current windows
    :type keep_on_top:               (bool)
    :param location:                 Location of upper left corner of the window
    :type location:                  (int, int)
    :param relative_location:        (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:         (int, int)
    :param initial_folder:           location in filesystem to begin browsing
    :type initial_folder:            (str)
    :param image:                    Image to include at the top of the popup window
    :type image:                     (str) or (bytes)
    :param files_delimiter:          String to place between files when multiple files are selected. Normally a ;
    :type files_delimiter:           str
    :param modal:                    If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                     bool
    :param history:                  If True then enable a "history" feature that will display previous entries used. Uses settings filename provided or default if none provided
    :type history:                   bool
    :param show_hidden:              If True then enables the checkbox in the system dialog to select hidden files to be shown
    :type show_hidden:               bool
    :param history_setting_filename: Filename to use for the User Settings. Will store list of previous entries in this settings file
    :type history_setting_filename:  (str)
    :return:                         string representing the file(s) chosen, None if cancelled or window closed with X
    :rtype:                          str | None
    """
    # First setup the history settings file if history feature is enabled
    if history and history_setting_filename is not None:
        try:
            history_settings = UserSettings(history_setting_filename)
        except Exception as e:
            _error_popup_with_traceback(
                'popup_get_file - Something is wrong with your supplied history settings filename',
                'Exception: {}'.format(e)
            )
            return None
    elif history:
        history_settings_filename = os.path.basename(inspect.stack()[1].filename)
        history_settings_filename = os.path.splitext(history_settings_filename)[0] + '.json'
        history_settings = UserSettings(history_settings_filename)
    else:
        history_settings = None

    if icon is None:
        icon = Window._user_defined_icon or DEFAULT_BASE64_ICON
    if no_window:
        _get_hidden_master_root()
        root = tk.Toplevel()
        try:
            root.attributes('-alpha', 0)  # makes for smoother 'paint'
            try:
                root.wm_overrideredirect(True)
            except Exception as e:
                print('* Error performing wm_overrideredirect in get file *', e)
            root.withdraw()
        except:
            pass

        if show_hidden is False:
            try:
                # call a dummy dialog with an impossible option to initialize the file
                # dialog without really getting a dialog window; this will throw a
                try:
                    root.tk.call('tk_getOpenFile', '-foobarbaz')
                except tk.TclError:
                    pass
                # now set the magic variables accordingly
                root.tk.call('set', '::tk::dialog::file::showHiddenBtn', '1')
                root.tk.call('set', '::tk::dialog::file::showHiddenVar', '0')
            except:
                pass

        if root and icon is not None:
            _set_icon_for_tkinter_window(root, icon=icon)
        # for Macs, setting parent=None fixes a warning problem.
        if save_as:
            if running_mac():
                is_all = [(x, y) for (x, y) in file_types if all(ch in '* .' for ch in y)]
                if not len(set(file_types)) > 1 and (len(is_all) != 0 or file_types == FILE_TYPES_ALL_FILES):
                    filename = tk.filedialog.asksaveasfilename(
                        initialdir=initial_folder, initialfile=default_path, defaultextension=default_extension
                    )
                else:
                    filename = tk.filedialog.asksaveasfilename(
                        filetypes=file_types, initialdir=initial_folder, initialfile=default_path,
                        defaultextension=default_extension
                    )
            else:
                filename = tk.filedialog.asksaveasfilename(
                    filetypes=file_types, initialdir=initial_folder, initialfile=default_path,
                    parent=root, defaultextension=default_extension
                )
        elif multiple_files:
            if running_mac():
                is_all = [(x, y) for (x, y) in file_types if all(ch in '* .' for ch in y)]
                if not len(set(file_types)) > 1 and (len(is_all) != 0 or file_types == FILE_TYPES_ALL_FILES):
                    filename = tk.filedialog.askopenfilenames(
                        initialdir=initial_folder, initialfile=default_path, defaultextension=default_extension)
                else:
                    filename = tk.filedialog.askopenfilenames(
                        filetypes=file_types, initialdir=initial_folder, initialfile=default_path,
                        defaultextension=default_extension
                    )
            else:
                filename = tk.filedialog.askopenfilenames(
                    filetypes=file_types, initialdir=initial_folder, initialfile=default_path,
                    parent=root, defaultextension=default_extension
                )
        else:
            if running_mac():
                is_all = [(x, y) for (x, y) in file_types if all(ch in '* .' for ch in y)]
                if not len(set(file_types)) > 1 and (len(is_all) != 0 or file_types == FILE_TYPES_ALL_FILES):
                    filename = tk.filedialog.askopenfilename(
                        initialdir=initial_folder, initialfile=default_path, defaultextension=default_extension)
                else:
                    filename = tk.filedialog.askopenfilename(
                        filetypes=file_types, initialdir=initial_folder, initialfile=default_path,
                        defaultextension=default_extension
                    )
            else:
                filename = tk.filedialog.askopenfilename(
                    filetypes=file_types, initialdir=initial_folder, initialfile=default_path,
                    parent=root, defaultextension=default_extension
                )

        root.destroy()

        if not multiple_files and type(filename) in (tuple, list):
            if len(filename):  # only if not 0 length, otherwise will get an error
                filename = filename[0]

        return (filename if filename else None)

    if save_as:
        browse_button = SaveAs(file_types=file_types, initial_folder=initial_folder, default_extension=default_extension)
    elif multiple_files:
        browse_button = FilesBrowse(file_types=file_types, initial_folder=initial_folder, files_delimiter=files_delimiter)
    else:
        browse_button = FileBrowse(file_types=file_types, initial_folder=initial_folder)

    if image is not None:
        if isinstance(image, str):
            layout = [[Image(filename=image)]]
        else:
            layout = [[Image(data=image)]]
    else:
        layout = [[]]

    layout += [[Text(message, auto_size_text=True, text_color=text_color, background_color=background_color)]]

    if not history:
        layout += [[InputText(default_text=default_path, size=size, key='-INPUT-'), browse_button]]
    else:
        file_list = history_settings.get("-PSG file list-", [])
        last_entry = file_list[0] if file_list else ''
        layout += [[Combo(file_list, default_value=last_entry, key='-INPUT-', size=size if size != (None, None) else (80, 1), bind_return_key=True),
                    browse_button, Button('Clear History', tooltip='Clears the list of files shown in the combobox')]]

    layout += [[Button('Ok', size=(6, 1), bind_return_key=True), Button('Cancel', size=(6, 1))]]

    window = Window(title=title or message, layout=layout, icon=icon, auto_size_text=True, button_color=button_color,
                    font=font, background_color=background_color, no_titlebar=no_titlebar, grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, location=location, relative_location=relative_location, modal=modal, finalize=True)

    if running_linux() and show_hidden is True:
        window.TKroot.tk.eval('catch {tk_getOpenFile -badoption}')  # dirty hack to force auto-loading of tk's file dialog code
        window.TKroot.setvar('::tk::dialog::file::showHiddenBtn', 1)  # enable the "show hidden files" checkbox (necessary)
        window.TKroot.setvar('::tk::dialog::file::showHiddenVar', 0)  # start with the hidden files... well... hidden

    while True:
        event, values = window.read()
        if event in ('Cancel', WIN_CLOSED):
            break
        elif event == 'Clear History':
            history_settings.set('-PSG file list-', [])
            window['-INPUT-'].update('', [])
            popup_quick_message('History of Previous Choices Cleared', background_color='red', text_color='white', font='_ 20', keep_on_top=True)
        elif event in ('Ok', '-INPUT-'):
            if values['-INPUT-'] != '':
                if history_settings is not None:
                    list_of_entries = history_settings.get('-PSG file list-', [])
                    if values['-INPUT-'] in list_of_entries:
                        list_of_entries.remove(values['-INPUT-'])
                    list_of_entries.insert(0, values['-INPUT-'])
                    history_settings.set('-PSG file list-', list_of_entries)
            break

    window.close()
    del window
    if event in ('Cancel', WIN_CLOSED):
        return None

    return values['-INPUT-']


# --------------------------- popup_get_text ---------------------------

def popup_get_text(message, title=None, default_text='', password_char='', size=(None, None), button_color=None,
                   background_color=None, text_color=None, icon=None, font=None, no_titlebar=False,
                   grab_anywhere=False, keep_on_top=None, location=(None, None), relative_location=(None, None), image=None, history=False, history_setting_filename=None, modal=True):
    """Displays `Popup` with text entry field

    Returns the text entered or `None` if closed / canceled.

    :param message:                  message displayed to user
    :type message:                   (str)
    :param title:                    Window title
    :type title:                     (str)
    :param default_text:             default value to put into input area
    :type default_text:              (str)
    :param password_char:            character to be shown instead of actually typed characters. WARNING - if history=True then can't hide passwords
    :type password_char:             (str)
    :param size:                     (width, height) of the input. If not specied a single line Input element used. If height >1 a Mulitline is shown
    :type size:                      (int, int)
    :param button_color:             Color of the button (text, background)
    :type button_color:              (str, str) | str
    :param background_color:         background color of the entire window
    :type background_color:          (str)
    :param text_color:               color of the message text
    :type text_color:                (str)
    :param icon:                     filename or base64 string to be used for the window's icon
    :type icon:                      bytes | str
    :param font:                     specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                      (str or (str, int[, str]) or None)
    :param no_titlebar:              If True no titlebar will be shown
    :type no_titlebar:               (bool)
    :param grab_anywhere:            If True can click and drag anywhere in the window to move the window
    :type grab_anywhere:             (bool)
    :param keep_on_top:              If True the window will remain above all current windows
    :type keep_on_top:               (bool)
    :param location:                 (x,y) Location on screen to display the upper left corner of window
    :type location:                  (int, int)
    :param relative_location:        (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:         (int, int)
    :param image:                    Image to include at the top of the popup window
    :type image:                     (str) or (bytes)
    :param history:                  If True then enable a "history" feature that will display previous entries used. Uses settings filename provided or default if none provided
    :type history:                   bool
    :param history_setting_filename: Filename to use for the User Settings. Will store list of previous entries in this settings file
    :type history_setting_filename:  (str)
    :param modal:                    If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                     bool
    :return:                         Text entered or None if window was closed or cancel button clicked
    :rtype:                          str | None
    """
    # First setup the history settings file if history feature is enabled
    if history and history_setting_filename is not None:
        try:
            history_settings = UserSettings(history_setting_filename)
        except Exception as e:
            _error_popup_with_traceback(
                'popup_get_file - Something is wrong with your supplied history settings filename',
                'Exception: {}'.format(e))
            return None
    elif history:
        history_settings_filename = os.path.basename(inspect.stack()[1].filename)
        history_settings_filename = os.path.splitext(history_settings_filename)[0] + '.json'
        history_settings = UserSettings(history_settings_filename)
    else:
        history_settings = None

    if image is not None:
        if isinstance(image, str):
            layout = [[Image(filename=image)]]
        else:
            layout = [[Image(data=image)]]
    else:
        layout = [[]]

    layout += [[Text(message, auto_size_text=True, text_color=text_color, background_color=background_color)]]
    if  history:
        text_list = history_settings.get("-PSG text list-", [])
        last_entry = text_list[0] if text_list else default_text
        layout += [[Combo(text_list, default_value=last_entry, key='-INPUT-', size=size if size != (None, None) else (80, 1), bind_return_key=True),
                    Button('Clear History', tooltip='Clears the list of files shown in the combobox')]]
    elif size == (None, None) or size[1] <= 1:
        layout += [[InputText(default_text=default_text, size=size, key='-INPUT-', password_char=password_char, focus=True)]]
    else:
        layout += [[Multiline(default_text=default_text, size=size, key='-INPUT-', focus=True)]]

    layout += [[
        Button('Ok', size=(6, 1), bind_return_key=True),
        Button('Cancel', size=(6, 1))
    ]]

    window = Window(title=title or message, layout=layout, icon=icon, auto_size_text=True, button_color=button_color, no_titlebar=no_titlebar,
                    background_color=background_color, grab_anywhere=grab_anywhere, keep_on_top=keep_on_top, location=location, relative_location=relative_location, finalize=True, modal=modal, font=font)
    window.force_focus()
    window['-INPUT-'].set_focus()

    while True:
        event, values = window.read()
        if event in ('Cancel', WIN_CLOSED):
            break
        elif event == 'Clear History':
            history_settings.set('-PSG text list-', [])
            window['-INPUT-'].update('', [])
            popup_quick_message('History of Previous Choices Cleared', background_color='red', text_color='white', font='_ 20', keep_on_top=True)
        elif event in ('Ok', '-INPUT-'):
            if values['-INPUT-'] != '':
                if history_settings is not None:
                    list_of_entries = history_settings.get('-PSG text list-', [])
                    if values['-INPUT-'] in list_of_entries:
                        list_of_entries.remove(values['-INPUT-'])
                    list_of_entries.insert(0, values['-INPUT-'])
                    history_settings.set('-PSG text list-', list_of_entries)
            break

    window.close()
    del window
    if event in ('Cancel', WIN_CLOSED):
        return None
    else:
        text = values['-INPUT-']
        return text


def popup_get_date(start_mon=None, start_day=None, start_year=None,
        begin_at_sunday_plus=0, no_titlebar=True, title='Choose Date',
        keep_on_top=True, location=(None, None), relative_location=(None, None),
        close_when_chosen=False, icon=None, locale=None, month_names=None,
        day_abbreviations=None,
        day_font = 'TkFixedFont 9',
        mon_year_font = 'TkFixedFont 10',
        arrow_font = 'TkFixedFont 7',
        modal=True):
    """Displays a calendar window

    Gets the user's choice and returns as a tuple (mon, day, year).

    :param start_mon:            The starting month
    :type start_mon:             (int)
    :param start_day:            The starting day - optional. Set to None or 0 if no date to be chosen at start
    :type start_day:             int | None
    :param start_year:           The starting year
    :type start_year:            (int)
    :param begin_at_sunday_plus: Determines the left-most day in the display. 0=sunday, 1=monday, etc
    :type begin_at_sunday_plus:  (int)
    :param icon:                 Same as Window icon parameter. Can be either a filename or Base64 value. For Windows if filename, it MUST be ICO format. For Linux, must NOT be ICO
    :type icon:                  (str | bytes)
    :param location:             (x,y) location on the screen to place the top left corner of your window. Default is to center on screen
    :type location:              (int, int)
    :param relative_location:    (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:     (int, int)
    :param title:                Title that will be shown on the window
    :type title:                 (str)
    :param close_when_chosen:    If True, the window will close and function return when a day is clicked
    :type close_when_chosen:     (bool)
    :param locale:               locale used to get the day names
    :type locale:                (str)
    :param no_titlebar:          If True no titlebar will be shown
    :type no_titlebar:           (bool)
    :param keep_on_top:          If True the window will remain above all current windows
    :type keep_on_top:           (bool)
    :param month_names:          optional list of month names to use (should be 12 items)
    :type month_names:           List[str]
    :param day_abbreviations:    optional list of abbreviations to display as the day of week
    :type day_abbreviations:     List[str]
    :param day_font:             Font and size to use for the calendar
    :type day_font:              str | tuple
    :param mon_year_font:        Font and size to use for the month and year at the top
    :type mon_year_font:         str | tuple
    :param arrow_font:           Font and size to use for the arrow buttons
    :type arrow_font:            str | tuple
    :param modal:                If True then makes the popup will behave like a Modal window... all other windows are non-operational until this one is closed. Default = True
    :type modal:                 bool
    :return:                     Tuple containing (month, day, year) of chosen date or None if was cancelled
    :rtype:                      None | (int, int, int)
    """
    if month_names is not None and len(month_names) != 12:
        if not SUPPRESS_ERROR_POPUPS:
            popup_error('Incorrect month names list specified. Must have 12 entries.', 'Your list:', month_names)

    if day_abbreviations is not None and len(day_abbreviations) != 7:
        if not SUPPRESS_ERROR_POPUPS:
            popup_error('Incorrect day abbreviation list. Must have 7 entries.', 'Your list:', day_abbreviations)

    now = datetime.datetime.now()
    cur_month, cur_day, cur_year = now.month, now.day, now.year
    cur_month = start_mon or cur_month
    if start_mon is not None:
        cur_day = start_day
    else:
        cur_day = cur_day
    cur_year = start_year or cur_year

    def update_days(window, month, year, begin_at_sunday_plus):
        [window[(week, day)].update('') for day in range(7) for week in range(6)]
        weeks = calendar.monthcalendar(year, month)
        month_days = list(itertools.chain.from_iterable([[0 for _ in range(8 - begin_at_sunday_plus)]] + weeks))
        if month_days[6] == 0:
            month_days = month_days[7:]
            if month_days[6] == 0:
                month_days = month_days[7:]
        for i, day in enumerate(month_days):
            offset = i
            if offset >= 6 * 7:
                break
            window[(offset // 7, offset % 7)].update(str(day) if day else '')

    def make_days_layout():
        days_layout = []
        for week in range(6):
            row = []
            for day in range(7):
                row.append(T('', size=(4, 1), justification='c', font=day_font, key=(week, day), enable_events=True, pad=(0, 0)))
            days_layout.append(row)
        return days_layout

    # Create table of month names and week day abbreviations
    if day_abbreviations is None or len(day_abbreviations) != 7:
        fwday = calendar.SUNDAY
        try:
            if locale is not None:
                _cal = calendar.LocaleTextCalendar(fwday, locale)
            else:
                _cal = calendar.TextCalendar(fwday)
            day_names = _cal.formatweekheader(3).split()
        except Exception as e:
            print('Exception building day names from locale', locale, e)
            day_names = ('Sun', 'Mon', 'Tue', 'Wed', 'Th', 'Fri', 'Sat')
    else:
        day_names = day_abbreviations

    mon_names = month_names if month_names is not None and len(month_names) == 12 else [calendar.month_name[i] for i in range(1, 13)]
    days_layout = make_days_layout()

    layout = [[B('◄◄', font=arrow_font, border_width=0, key='-YEAR-DOWN-', pad=((10, 2), 2)),
               B('◄', font=arrow_font, border_width=0, key='-MON-DOWN-', pad=(0, 2)),
               Text('{} {}'.format(mon_names[cur_month - 1], cur_year), size=(16, 1), justification='c', font=mon_year_font, key='-MON-YEAR-', pad=(0, 2)),
               B('►', font=arrow_font, border_width=0, key='-MON-UP-', pad=(0, 2)),
               B('►►', font=arrow_font, border_width=0, key='-YEAR-UP-', pad=(2, 2))]]
    layout += [[Col([[T(day_names[i - (7 - begin_at_sunday_plus) % 7], size=(4, 1), font=day_font, background_color=theme_text_color(),
                        text_color=theme_background_color(), pad=(0, 0)) for i in range(7)]], background_color=theme_text_color(), pad=(0, 0))]]
    layout += days_layout
    if not close_when_chosen:
        layout += [[Button('Ok', border_width=0, font='TkFixedFont 8'), Button('Cancel', border_width=0, font='TkFixedFont 8')]]

    window = Window(title, layout, no_titlebar=no_titlebar, grab_anywhere=True, keep_on_top=keep_on_top, font='TkFixedFont 12', use_default_focus=False,
                    location=location, relative_location=relative_location, finalize=True, icon=icon)

    update_days(window, cur_month, cur_year, begin_at_sunday_plus)

    prev_choice = chosen_mon_day_year = None

    if cur_day:
        chosen_mon_day_year = cur_month, cur_day, cur_year
        for week in range(6):
            for day in range(7):
                if window[(week, day)].DisplayText == str(cur_day):
                    window[(week, day)].update(background_color=theme_text_color(), text_color=theme_background_color())
                    prev_choice = (week, day)
                    break

    if modal or DEFAULT_MODAL_WINDOWS_FORCED:
        window.make_modal()

    while True:  # Event Loop
        event, values = window.read()
        if event in (None, 'Cancel'):
            chosen_mon_day_year = None
            break
        if event == 'Ok':
            break
        if event in ('-MON-UP-', '-MON-DOWN-', '-YEAR-UP-', '-YEAR-DOWN-'):
            cur_month += (event == '-MON-UP-')
            cur_month -= (event == '-MON-DOWN-')
            cur_year += (event == '-YEAR-UP-')
            cur_year -= (event == '-YEAR-DOWN-')
            if cur_month > 12:
                cur_month = 1
                cur_year += 1
            elif cur_month < 1:
                cur_month = 12
                cur_year -= 1
            window['-MON-YEAR-'].update('{} {}'.format(mon_names[cur_month - 1], cur_year))
            update_days(window, cur_month, cur_year, begin_at_sunday_plus)
            if prev_choice:
                window[prev_choice].update(background_color=theme_background_color(), text_color=theme_text_color())
        elif type(event) is tuple:
            if window[event].DisplayText != "":
                chosen_mon_day_year = cur_month, int(window[event].DisplayText), cur_year
                if prev_choice:
                    window[prev_choice].update(background_color=theme_background_color(), text_color=theme_text_color())
                window[event].update(background_color=theme_text_color(), text_color=theme_background_color())
                prev_choice = event
                if close_when_chosen:
                    break
    window.close()
    return chosen_mon_day_year


# --------------------------- PopupAnimated ---------------------------
def popup_animated(image_source, message=None, background_color=None, text_color=None, font=None, no_titlebar=True, grab_anywhere=True, keep_on_top=True,
                   location=(None, None), relative_location=(None, None), alpha_channel=None, time_between_frames=0, transparent_color=None, title='', icon=None, no_buffering=False):
    """Show animation one frame at a time

    This function has its own internal clocking meaning you can call it
    at any frequency and the rate the frames of video is shown remains
    constant. Maybe your frames update every 30 ms but your event loop
    is running every 10 ms.

    NOTE: You don't have to worry about delaying, just call it every
    time through the loop.

    :param image_source:        Either a filename or a base64 string. Use None to close the window.
    :type image_source:         str | bytes | None
    :param message:             An optional message to be shown with the animation
    :type message:              (str)
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 str | tuple
    :param no_titlebar:         If True then the titlebar and window frame will not be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True then you can move the window just clicking anywhere on window, hold and drag
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True then Window will remain on top of all other windows currently shownn
    :type keep_on_top:          (bool)
    :param location:            (x,y) location on the screen to place the top left corner of your window. Default is to center on screen
    :type location:             (int, int)
    :param relative_location:   (x,y) location relative to the default location of the window, in pixels. Normally the window centers.  This location is relative to the location the window would be created. Note they can be negative.
    :type relative_location:    (int, int)
    :param alpha_channel:       Window transparency 0 = invisible 1 = completely visible. Values between are see through
    :type alpha_channel:        (float)
    :param time_between_frames: Amount of time in milliseconds between each frame
    :type time_between_frames:  (int)
    :param transparent_color:   This color will be completely see-through in your window. Can even click through
    :type transparent_color:    (str)
    :param title:               Title that will be shown on the window
    :type title:                (str)
    :param icon:                Same as Window icon parameter. Can be either a filename or Base64 byte string. For Windows if filename, it MUST be ICO format. For Linux, must NOT be ICO
    :type icon:                 str | bytes
    :param no_buffering:        If True then no buffering will be used for the GIF. May work better if you have a large animation
    :type no_buffering:         (bool)
    :return:                    True if the window updated OK. False if the window was closed or if the GIF has reached the end
    :rtype:                     bool
    """
    if image_source is None:
        for image in Window._animated_popup_dict:
            window = Window._animated_popup_dict[image]
            window.close()
        Window._animated_popup_dict = {}
        return False

    not_done = True
    if image_source not in Window._animated_popup_dict:
        if type(image_source) is bytes or len(image_source) > 300:
            layout = [[Image(data=image_source, background_color=background_color, key='-IMAGE-')], ]
        else:
            layout = [[Image(filename=image_source, background_color=background_color, key='-IMAGE-', )], ]
        if message:
            layout.append([Text(message, background_color=background_color, text_color=text_color, font=font)])

        window = Window(title, layout, no_titlebar=no_titlebar, grab_anywhere=grab_anywhere,
                        keep_on_top=keep_on_top, background_color=background_color, location=location,
                        alpha_channel=alpha_channel, element_padding=(0, 0), margins=(0, 0),
                        transparent_color=transparent_color, finalize=True, element_justification='c', icon=icon, relative_location=relative_location)
        Window._animated_popup_dict[image_source] = window
    else:
        window = Window._animated_popup_dict[image_source]
        if no_buffering:
            not_done = window['-IMAGE-'].update_animation_no_buffering(image_source, time_between_frames=time_between_frames)
        else:
            not_done = window['-IMAGE-'].update_animation(image_source, time_between_frames=time_between_frames)
    event, values = window.read(1)
    if event == WIN_CLOSED:
        return False
    # window.refresh() # call this instaed of Read to save CPU time
    return not_done


def popup_notify(*args, title='', icon=SYSTEM_TRAY_MESSAGE_ICON_INFORMATION, display_duration_in_ms=SYSTEM_TRAY_MESSAGE_DISPLAY_DURATION_IN_MILLISECONDS,
                 fade_in_duration=SYSTEM_TRAY_MESSAGE_FADE_IN_DURATION, alpha=0.9, location=None):
    """Displays a notification window

    Usually in the bottom right corner of your display.
    Has an icon, a title, and a message.
    It is more like a "toaster" window than the normal popups.

    The window will slowly fade in and out if desired.  Clicking on the window will cause it to move through the end the current "phase". For example, if the window was fading in and it was clicked, then it would immediately stop fading in and instead be fully visible.  It's a way for the user to quickly dismiss the window.

    The return code specifies why the call is returning (e.g. did the user click the message to dismiss it)

    :param title:                  Text to be shown at the top of the window in a larger font
    :type title:                   (str)
    :param message:                Text message that makes up the majority of the window
    :type message:                 (str)
    :param icon:                   A base64 encoded PNG/GIF image or PNG/GIF filename that will be displayed in the window
    :type icon:                    bytes | str
    :param display_duration_in_ms: Number of milliseconds to show the window
    :type display_duration_in_ms:  (int)
    :param fade_in_duration:       Number of milliseconds to fade window in and out
    :type fade_in_duration:        (int)
    :param alpha:                  Alpha channel. 0 - invisible 1 - fully visible
    :type alpha:                   (float)
    :param location:               Location on the screen to display the window
    :type location:                (int, int)
    :return:                       reason for returning
    :rtype:                        (int)
    """
    if not args:
        args_to_print = ['']
    else:
        args_to_print = args
    output = ''
    max_line_total, total_lines, local_line_width = 0, 0, SYSTEM_TRAY_MESSAGE_MAX_LINE_LENGTH
    for message in args_to_print:
        # fancy code to check if string and convert if not is not need. Just always convert to string :-)
        # if not isinstance(message, str): message = str(message)
        message = str(message)
        if message.count('\n'):
            message_wrapped = message
        else:
            message_wrapped = textwrap.fill(message, local_line_width)
        message_wrapped_lines = message_wrapped.count('\n') + 1
        longest_line_len = max([len(l) for l in message.split('\n')])
        width_used = min(longest_line_len, local_line_width)
        max_line_total = max(max_line_total, width_used)
        # height = _GetNumLinesNeeded(message, width_used)
        height = message_wrapped_lines
        output += message_wrapped + '\n'
        total_lines += height

    message = output

    return SystemTray.notify(title=title, message=message, icon=icon, display_duration_in_ms=display_duration_in_ms, fade_in_duration=fade_in_duration,
                             alpha=alpha, location=location)


def popup_menu(window, element, menu_def, title=None, location=(None, None)):
    """Makes a popup menu

    This type of menu is what you get when a normal menu or a right click menu is torn off.
    The settings for the menu are obtained from the window parameter's Window

    :param window:   The window associated with the popup menu. The theme and right click menu settings for this window will be used
    :type window:    Window
    :param element:  An element in your window to associate the menu to. It can be any element
    :type element:   Element
    :param menu_def: A menu definition. This will be the same format as used for Right Click Menus1
    :type  menu_def: List[List[ List[str] | str ]]
    :param title:    The title that will be shown on the torn off menu window. Defaults to window titlr
    :type title:     str
    :param location: The location on the screen to place the window
    :type location:  (int, int) | (None, None)
    """
    element._popup_menu_location = location
    top_menu = tk.Menu(window.TKroot, tearoff=True, tearoffcommand=element._tearoff_menu_callback)
    if window.right_click_menu_background_color not in (COLOR_SYSTEM_DEFAULT, None):
        top_menu.config(bg=window.right_click_menu_background_color)
    if window.right_click_menu_text_color not in (COLOR_SYSTEM_DEFAULT, None):
        top_menu.config(fg=window.right_click_menu_text_color)
    if window.right_click_menu_disabled_text_color not in (COLOR_SYSTEM_DEFAULT, None):
        top_menu.config(disabledforeground=window.right_click_menu_disabled_text_color)
    if window.right_click_menu_font is not None:
        top_menu.config(font=window.right_click_menu_font)
    if window.right_click_menu_selected_colors[0] != COLOR_SYSTEM_DEFAULT:
        top_menu.config(activeforeground=window.right_click_menu_selected_colors[0])
    if window.right_click_menu_selected_colors[1] != COLOR_SYSTEM_DEFAULT:
        top_menu.config(activebackground=window.right_click_menu_selected_colors[1])
    top_menu.config(title=window.Title if title is None else title)
    AddMenuItem(top_menu, menu_def[1], element, right_click_menu=True)
    # element.Widget.bind('<Button-3>', element._RightClickMenuCallback)
    top_menu.invoke(0)


def popup_error_with_traceback(title, *messages, emoji=None):
    """Shows an error message and as many additional lines of messages as you want

    Will show the same error window as framework uses internally.
    Has a button to take the user to the line of code you called this popup from.
    If you include the Exception information in your messages,
    then it will be parsed and additional information will be in the window
    about such as the specific line the error itself occurred on.

    :param title:     The title that will be shown in the popup's titlebar and in the first line of the window
    :type title:      str
    :param *messages: A variable number of lines of messages you wish to show your user
    :type *messages:  Any
    :param emoji:     An optional BASE64 Encoded image to shows in the error window
    :type emoji:      bytes
    """
    _error_popup_with_traceback(str(title), *messages, emoji=emoji)


def _error_popup_with_traceback(title, *args, emoji=None):
    if SUPPRESS_ERROR_POPUPS:
        return
    trace_details = traceback.format_stack()
    error_message = ''
    file_info_freesimplegui = None
    for line in reversed(trace_details):
        if __file__ not in line:
            file_info_freesimplegui = line.split(",")[0]
            error_message = line
            break
    if file_info_freesimplegui is None:
        _error_popup_with_code(title, None, None, 'Did not find your traceback info', *args, emoji=emoji)
        return
    error_parts = None
    if error_message != '':
        error_parts = error_message.split(', ')
        if len(error_parts) < 4:
            error_message = error_parts[0] + '\n' + error_parts[1] + '\n' + ''.join(error_parts[2:])
    if error_parts is None:
        print('*** Error popup attempted but unable to parse error details ***')
        print(trace_details)
        return
    filename = error_parts[0][error_parts[0].index('File ') + 5:]
    line_num = error_parts[1][error_parts[1].index('line ') + 5:]
    _error_popup_with_code(title, filename, line_num, error_message, *args, emoji=emoji)


def _error_popup_with_code(title, filename, line_num, *args, emoji=None):
    """Makes an error popup window

    :param title:     The title that will be shown in the popup's titlebar and in the first line of the window
    :type title:      str
    :param filename:  The filename to show.. may not be the filename that actually encountered the exception!
    :type filename:   str
    :param line_num:  Line number within file with the error
    :type line_num:   int | str
    :param args:      A variable number of lines of messages
    :type args:       *Any
    :param emoji:     An optional BASE64 Encoded image to shows in the error window
    :type emoji:      bytes
    """
    editor_filename = execute_get_editor()
    emoji_data = emoji if emoji is not None else _random_error_emoji()
    layout = [[Text('ERROR'), Text(title)],
              [Image(data=emoji_data)]]
    lines = []
    for msg in args:
        if isinstance(msg, Exception):
            lines += [[f'Additional Exception info pased in by FreeSimpleGUI or user: Error type is: {type(msg).__name__}']]
            lines += [[f'In file {__file__} Line number {msg.__traceback__.tb_lineno}']]
            lines += [[f'{msg}']]
        else:
            lines += [str(msg).split('\n')]
    max_line_len = 0
    for line in lines:
        max_line_len = max(max_line_len, max([len(s) for s in line]))

    layout += [[Text(''.join(line), size=(min(max_line_len, 90), None))] for line in lines]
    layout += [[Button('Close'), Button('Take me to error', disabled=True if not editor_filename else False), Button('Kill Application', button_color='white on red')]]
    if not editor_filename:
        layout += [[Text('Configure editor in the Global settings to enable "Take me to error" feature')]]
    window = Window(title, layout, keep_on_top=True)

    while True:
        event, values = window.read()
        if event in ('Close', WIN_CLOSED):
            break
        if event == 'Kill Application':
            window.close()
            popup_quick_message('KILLING APP!  BYE!', font='_ 18', keep_on_top=True, text_color='white', background_color='red', non_blocking=False)
            sys.exit()
        if event == 'Take me to error' and filename is not None and line_num is not None:
            execute_editor(filename, line_num)

    window.close()


#####################################################################
# Animated window while shell command is executed
#####################################################################

def _process_thread(*args):
    global __shell_process__
    # start running the command with arguments
    try:
        __shell_process__ = subprocess.run(args, shell=True, stdout=subprocess.PIPE)
    except Exception as e:
        print('Exception running process args = {}'.format(args))
        __shell_process__ = None


def shell_with_animation(command, args=None, image_source=DEFAULT_BASE64_LOADING_GIF, message=None, background_color=None, text_color=None, font=None,
                         no_titlebar=True, grab_anywhere=True, keep_on_top=True, location=(None, None), alpha_channel=None, time_between_frames=100,
                         transparent_color=None):
    """Executes a shell command (anything capable of being launched using `subprocess.run`)

    While the command is running, show an animated popup so that
    the user knows that a long-running command is being executed.
    Without this mechanism, the GUI appears locked up.

    :param command:             The command to run
    :type command:              (str)
    :param args:                List of arguments
    :type args:                 List[str]
    :param image_source:        Either a filename or a base64 string.
    :type image_source:         str | bytes
    :param message:             An optional message to be shown with the animation
    :type message:              (str)
    :param background_color:    color of background
    :type background_color:     (str)
    :param text_color:          color of the text
    :type text_color:           (str)
    :param font:                specifies the  font family, size, etc. Tuple or Single string format 'name size styles'. Styles: italic * roman bold normal underline overstrike
    :type font:                 str | tuple
    :param no_titlebar:         If True then the titlebar and window frame will not be shown
    :type no_titlebar:          (bool)
    :param grab_anywhere:       If True then you can move the window just clicking anywhere on window, hold and drag
    :type grab_anywhere:        (bool)
    :param keep_on_top:         If True then Window will remain on top of all other windows currently shownn
    :type keep_on_top:          (bool)
    :param location:            (x,y) location on the screen to place the top left corner of your window. Default is to center on screen
    :type location:             (int, int)
    :param alpha_channel:       Window transparency 0 = invisible 1 = completely visible. Values between are see through
    :type alpha_channel:        (float)
    :param time_between_frames: Amount of time in milliseconds between each frame
    :type time_between_frames:  (int)
    :param transparent_color:   This color will be completely see-through in your window. Can even click through
    :type transparent_color:    (str)
    :return:                    The resulting string output from stdout
    :rtype:                     (str)
    """
    global __shell_process__
    real_args = [command]
    if args is not None:
        for arg in args:
            real_args.append(arg)
    thread = threading.Thread(target=_process_thread, args=real_args, daemon=True)
    thread.start()

    # Poll to see if the thread is still running.  If so, then continue showing the animation
    while True:
        popup_animated(image_source=image_source, message=message, time_between_frames=time_between_frames, transparent_color=transparent_color,
                       text_color=text_color, background_color=background_color, font=font, no_titlebar=no_titlebar, grab_anywhere=grab_anywhere,
                       keep_on_top=keep_on_top, location=location, alpha_channel=alpha_channel)
        thread.join(timeout=time_between_frames / 1000)
        if not thread.is_alive():
            break
    popup_animated(None)  # stop running the animation

    output = __shell_process__.__str__().replace('\\r\\n', '\n')  # fix up the output string
    output = output[output.index("stdout=b'") + 9:-2]
    return output


#######################################################################
#  8888888888
#  888
#  888
#  8888888    888d888 888d888 .d88b.  888d888
#  888        888P"   888P"  d88""88b 888P"
#  888        888     888    888  888 888
#  888        888     888    Y88..88P 888
#  8888888888 888     888     "Y88P"  888
#
#
#
#  888b     d888
#  8888b   d8888
#  88888b.d88888
#  888Y88888P888  .d88b.  .d8888b  .d8888b   8888b.   .d88b.   .d88b.
#  888 Y888P 888 d8P  Y8b 88K      88K          "88b d88P"88b d8P  Y8b
#  888  Y8P  888 88888888 "Y8888b. "Y8888b. .d888888 888  888 88888888
#  888   "   888 Y8b.          X88      X88 888  888 Y88b 888 Y8b.
#  888       888  "Y8888   88888P'  88888P' "Y888888  "Y88888  "Y8888
#                                                         888
#                                                    Y8b d88P
#                                                     "Y88P"
# Code to make messages to help user find errors in their code
#######################################################################

def _create_error_message():
    """Creates an error message containing the filename
        and line number of the users code that made the call

    :return: Error string to display with file, line number, and line of code
    :rtype:  str
    """

    called_func = inspect.stack()[1].function
    trace_details = traceback.format_stack()
    error_message = ''
    file_info_freesimplegui = trace_details[-1].split(",")[0]
    for line in reversed(trace_details):
        if line.split(",")[0] != file_info_freesimplegui:
            error_message = line
            break
    if error_message != '':
        error_parts = error_message.split(', ')
        if len(error_parts) < 4:
            error_message = error_parts[0] + '\n' + error_parts[1] + '\n' + ''.join(error_parts[2:])
    return 'The FreeSimpleGUI internal reporting function is ' + called_func + '\n' + \
           'The error originated from:\n' + error_message


#   .d8888b.           888    888    d8b
#  d88P  Y88b          888    888    Y8P
#  Y88b.               888    888
#   "Y888b.    .d88b.  888888 888888 888 88888b.   .d88b.  .d8888b
#      "Y88b. d8P  Y8b 888    888    888 888 "88b d88P"88b 88K
#        "888 88888888 888    888    888 888  888 888  888 "Y8888b.
#  Y88b  d88P Y8b.     Y88b.  Y88b.  888 888  888 Y88b 888      X88
#   "Y8888P"   "Y8888   "Y888  "Y888 888 888  888  "Y88888  88888P'
#                                                      888
#                                                 Y8b d88P
#                                                  "Y88P"

# Interface to saving / loading user program settings in JSON format
# This is a new set of APIs that enables users to easily set/save/load individual settings.
# They are automatically saved to a JSON file. If no file/path is specified then
# a filename is created from the source file filename.

class UserSettings:
    """
        A reserved settings object for use by the setting functions.
        It's a way for users to access the user settings without directly using the `UserSettings` class.
    """
    _default_for_function_interface = None  # type: UserSettings

    def __init__(self, filename=None, path=None, silent_on_error=False, autosave=True, use_config_file=None, convert_bools_and_none=True):
        """User settings

        :param filename:               The name of the file to use. Can be a full path and filename or just filename
        :type filename:                (str or None)
        :param path:                   The folder that the settings file will be stored in. Do not include the filename.
        :type path:                    (str or None)
        :param silent_on_error:        If True errors will not be reported
        :type silent_on_error:         (bool)
        :param autosave:               If True the settings file is saved after every update
        :type autosave:                (bool)
        :param use_config_file:        If True then the file format will be a config.ini rather than json
        :type use_config_file:         (bool)
        :param convert_bools_and_none: If True then "True", "False", "None" will be converted to the Python values True, False, None when using INI files. Default is TRUE
        :type convert_bools_and_none:  (bool)
        """
        self.path = path
        self.filename = filename
        self.full_filename = None
        self.dict = {}
        self.default_value = None
        self.silent_on_error = silent_on_error
        self.autosave = autosave
        if filename is not None and filename.endswith('.ini') and use_config_file is None:
            warnings.warn(
                '[UserSettings] You have specified a filename with .ini extension but did not set use_config_file.' +
                'Setting use_config_file for you.', UserWarning)
            use_config_file = True
        self.use_config_file = use_config_file
        self.convert_bools = convert_bools_and_none
        if use_config_file:
            self.config = configparser.ConfigParser()
            self.config.optionxform = str
            self.section_class_dict = {}  # type: dict[_SectionDict]
        if filename is not None or path is not None:
            self.load(filename=filename, path=path)

    ########################################################################################################
    ## FIRST is the _SectionDict helper class
    ## It is typically not directly accessed, although it is possible to call delete_section, get, set
    ########################################################################################################

    class _SectionDict:
        item_count = 0

        def __init__(self, section_name, section_dict, config, user_settings_parent):  # (str, Dict, configparser.ConfigParser)
            """The Section Dictionary

            It holds the values for a section.

            :param section_name:                Name of the section
            :type section_name:                 str
            :param section_dict:                Dictionary of values for the section
            :type section_dict:                 dict
            :param config:                      The configparser object
            :type config:                       configparser.ConfigParser
            :param user_settings_parent:        The parent UserSettings object that hdas this section
            :type user_settings_parent:         UserSettings
            """
            self.section_name = section_name
            self.section_dict = section_dict  # type: Dict
            self.new_section = False
            self.config = config  # type: configparser.ConfigParser
            self.user_settings_parent = user_settings_parent  # type: UserSettings
            UserSettings._SectionDict.item_count += 1

            if self.user_settings_parent.convert_bools:
                for key, value in self.section_dict.items():
                    if value == 'True':
                        value = True
                        self.section_dict[key] = value
                    elif value == 'False':
                        value = False
                        self.section_dict[key] = value
                    elif value == 'None':
                        value = None
                        self.section_dict[key] = value
            # print(f'++++++ making a new SectionDict with name = {section_name}')

        def __repr__(self):
            """Converts the settings dictionary into a string for displaying

            :return: the dictionary as a string
            :rtype:  (str)
            """
            return_string = '{}:\n'.format(self.section_name)
            for entry in self.section_dict.keys():
                return_string += '          {} : {}\n'.format(entry, self.section_dict[entry])

            return return_string

        def get(self, key, default=None):
            """Returns the value of a specified setting

            If the setting is not found in the settings dictionary, then the user specified
            default value will be returned.  It no default is specified and nothing is found,
            then the 'default value' is returned.

            This default can be specified in this call, or previously defined by calling `set_default`.
            If nothing specified now or previously, then `None` is returned as default.

            :param key:     Key used to lookup the setting in the settings dictionary
            :type key:      (Any)
            :param default: Value to use should the key not be found in the dictionary
            :type default:  (Any)
            :return:        Value of specified settings
            :rtype:         (Any)
            """
            value = self.section_dict.get(key, default)
            if self.user_settings_parent.convert_bools:
                if value == 'True':
                    value = True
                elif value == 'False':
                    value = False
            return value

        def set(self, key, value):
            value = str(value)  # all values must be strings
            if self.new_section:
                self.config.add_section(self.section_name)
                self.new_section = False
            self.config.set(section=self.section_name, option=key, value=value)
            self.section_dict[key] = value
            if self.user_settings_parent.autosave:
                self.user_settings_parent.save()

        def delete_section(self):
            # print(f'** Section Dict deleting section = {self.section_name}')
            self.config.remove_section(section=self.section_name)
            del self.user_settings_parent.section_class_dict[self.section_name]
            if self.user_settings_parent.autosave:
                self.user_settings_parent.save()

        def __getitem__(self, item):
            return self.get(item)

        def __setitem__(self, item, value):
            """Enables setting a setting by using [ ] notation like a dictionary

            Your code will have this kind of design pattern:
            ```
            settings = sg.UserSettings()
            settings[item] = value
            ```

            :param item:  The key for the setting to change. Needs to be a hashable type. Basically anything but a list
            :type item:   Any
            :param value: The value to set the setting to
            :type value:  Any
            """
            self.set(item, value)
            self.section_dict[item] = value

        def __delitem__(self, item):
            """Deletes an individual user setting

            This is the same as calling `delete_entry`.
            The syntax for deleting the item using this manner is:
                `del settings['entry']`

            :param item: The key for the setting to delete
            :type item:  Any
            """
            # print(f'** In SectionDict delete! section name = {self.section_name} item = {item} ')
            self.config.remove_option(section=self.section_name, option=item)
            try:
                del self.section_dict[item]
            except Exception as e:
                pass
                # print(e)
            if self.user_settings_parent.autosave:
                self.user_settings_parent.save()

    ########################################################################################################
    def __repr__(self):
        """Converts the settings dictionary into a string for displaying

        :return: the dictionary as a string
        :rtype:  (str)
        """
        if not self.use_config_file:
            return pprint.pformat(self.dict)
        else:
            # rvalue = '-------------------- Settings ----------------------\n'
            rvalue = ''
            for name, section in self.section_class_dict.items():
                rvalue += str(section)

            # rvalue += '\n-------------------- Settings End----------------------\n'
            rvalue += '\n'
            return rvalue

    def set_default_value(self, default):
        """Sets the value that will be returned if a requested setting is not found

        :param default: value to be returned if a setting is not found in the settings dictionary
        :type default:  Any
        """
        self.default_value = default

    def _compute_filename(self, filename=None, path=None):
        """Creates the full filename given the path or the filename or both

        :param filename: The name of the file to use. Can be a full path and filename or just filename
        :type filename:  (str or None)
        :param path:     The folder that the settings file will be stored in. Do not include the filename.
        :type path:      (str or None)
        :return:         Tuple with (full filename, path, filename)
        :rtype:          Tuple[str, str, str]
        """
        if filename is not None:
            dirname_from_filename = os.path.dirname(filename)  # see if a path was provided as part of filename
            if dirname_from_filename:
                path = dirname_from_filename
                filename = os.path.basename(filename)
        elif self.filename is not None:
            filename = self.filename
        else:
            filename = os.path.splitext(os.path.basename(sys.argv[0]))[0]
            if filename == '__main__':      # if got __main__ then try an alternative approach
                filename = os.path.splitext(os.path.basename(sys.modules["__main__"].__file__))[0]
                if filename == '__main__':
                    # filename = os.path.splitext(os.path.basename(__file__))[0]      # likely to be FreeSimpleGUI.py which may be a problem...
                    filename = os.path.splitext(os.path.basename(inspect.getsourcefile(lambda: 0)))[0]
                    if filename == '__main__':
                        print(f'Error setting the default settings filename.   Please report this error.  filename = {filename}')
            if not self.use_config_file:            # add the extension to the filename
                filename += '.json'
            else:
                filename += '.ini'

        if path is None:
            if self.path is not None:
                # path = self.path
                path = os.path.expanduser(self.path)  # expand user provided path in case it has user ~ in it. Don't think it'll hurt
            elif DEFAULT_USER_SETTINGS_PATH is not None:  # if user set the path manually system-wide using set options
                path = os.path.expanduser(DEFAULT_USER_SETTINGS_PATH)
            elif running_trinket():
                path = os.path.expanduser(DEFAULT_USER_SETTINGS_TRINKET_PATH)
            elif running_replit():
                path = os.path.expanduser(DEFAULT_USER_SETTINGS_REPLIT_PATH)
            elif running_windows():
                path = os.path.expanduser(DEFAULT_USER_SETTINGS_WIN_PATH)
            elif running_linux():
                path = os.path.expanduser(DEFAULT_USER_SETTINGS_LINUX_PATH)
            elif running_mac():
                path = os.path.expanduser(DEFAULT_USER_SETTINGS_MAC_PATH)
            else:
                path = '.'

        full_filename = os.path.join(path, filename)
        return (full_filename, path, filename)

    def set_location(self, filename=None, path=None):
        """Sets the location of the settings file

        :param filename: The name of the file to use. Can be a full path and filename or just filename
        :type filename:  (str or None)
        :param path:     The folder that the settings file will be stored in. Do not include the filename.
        :type path:      (str or None)
        """
        cfull_filename, cpath, cfilename = self._compute_filename(filename=filename, path=path)

        self.filename = cfilename
        self.path = cpath
        self.full_filename = cfull_filename

    def get_filename(self, filename=None, path=None):
        """Sets the filename and path for your settings file.

        Either parameter can be optional.

        If you don't choose a path, one is provided for you that is OS specific
        Windows path default = users/name/AppData/Local/FreeSimpleGUI/settings.

        If you don't choose a filename, your application's `filename + .json` will be used.

        Normally the filename and path are split in the `user_settings` calls.
        However for this call they can be combined so that the filename
        contains both the path and filename.

        :param filename: The name of the file to use. Can be a full path and filename or just filename
        :type filename:  (str or None)
        :param path:     The folder that the settings file will be stored in. Do not include the filename.
        :type path:      (str or None)
        :return:         The full pathname of the settings file that has both the path and filename combined.
        :rtype:          (str)
        """
        if filename is not None or path is not None or (filename is None and path is None and self.full_filename is None):
            self.set_location(filename=filename, path=path)
            self.read()
        return self.full_filename

    def save(self, filename=None, path=None):
        """Saves the current settings dictionary

        If a filename or path is specified in the call, then it will override any
        previously specified filename to create a new settings file.
        The settings dictionary is then saved to the newly defined file.

        :param filename: The filename to save to. Can specify a path or just the filename. If none specified, then the caller's filename will be used.
        :type filename:  (str or None)
        :param path:     The (optional) path to use to save the file.
        :type path:      (str or None)
        :return:         The full path and filename used to save the settings
        :rtype:          (str)
        """
        if filename is not None or path is not None:
            self.set_location(filename=filename, path=path)
        try:
            if not os.path.exists(self.path):
                os.makedirs(self.path)
            with open(self.full_filename, 'w') as f:
                if not self.use_config_file:
                    json.dump(self.dict, f)
                else:
                    self.config.write(f)
        except Exception as e:
            if not self.silent_on_error:
                _error_popup_with_traceback('UserSettings.save error', '*** UserSettings.save()  Error saving settings to file:***\n', self.full_filename, e)

        return self.full_filename

    def load(self, filename=None, path=None):
        """Specifies the path and filename to use for the settings and reads the contents of the file

        The filename can be a full filename including a path, or the path can be specified separately.
        If none is specified, then the caller's filename will be used with '.json' extension.

        :param filename: Filename to load settings from (and save to in the future)
        :type filename:  (str or None)
        :param path:     Path to the file. Defaults to a specific folder depending on the operating system
        :type path:      (str or None)
        :return:         The settings dictionary (i.e. all settings)
        :rtype:          (dict)
        """
        if filename is not None or path is not None or self.full_filename is None:
            self.set_location(filename, path)
        self.read()
        return self.dict

    def delete_file(self, filename=None, path=None, report_error=False):
        """Deletes the filename and path for your settings file

        Either parameter can be optional.
        If you don't choose a path, one is provided for you that is OS specific
        Windows path default = `%UserProfile%/Local/FreeSimpleGUI/settings`.
        If you don't choose a filename, your application's `filename + .json` will be used.
        Also sets your current dictionary to a blank one.

        :param filename:     The name of the file to use. Can be a full path and filename or just filename
        :type filename:      (str or None)
        :param path:         The folder that the settings file will be stored in. Do not include the filename.
        :type path:          (str or None)
        :param report_error: Determines if an error should be shown if a delete error happen (i.e. file isn't present)
        :type report_error:  (bool)
        """

        if filename is not None or path is not None or (filename is None and path is None):
            self.set_location(filename=filename, path=path)
        try:
            os.remove(self.full_filename)
        except Exception as e:
            if report_error:
                _error_popup_with_traceback('UserSettings delete_file warning ***', 'Exception trying to perform os.remove', e)
        self.dict = {}

    def write_new_dictionary(self, settings_dict):
        """Writes a specified dictionary to the currently defined settings filename

        :param settings_dict: The dictionary to be written to the currently defined settings file
        :type settings_dict:  (dict)
        """
        if self.full_filename is None:
            self.set_location()
        self.dict = settings_dict
        self.save()

    def read(self):
        """Reads settings file and returns the dictionary

        If you have anything changed in an existing settings dictionary, you will lose your changes.

        :return: settings dictionary
        :rtype:  (dict)
        """
        if self.full_filename is None:
            return {}
        try:
            if os.path.exists(self.full_filename):
                with open(self.full_filename, 'r') as f:
                    if not self.use_config_file:  # if using json
                        self.dict = json.load(f)
                    else:  # if using a config file
                        self.config.read_file(f)
                        # Make a dictionary of SectionDict classes. Keys are the config.sections().
                        self.section_class_dict = {}
                        for section in self.config.sections():
                            section_dict = dict(self.config[section])
                            self.section_class_dict[section] = self._SectionDict(section, section_dict, self.config, self)

                        self.dict = self.section_class_dict
                        self.config_sections = self.config.sections()
        except Exception as e:
            if not self.silent_on_error:
                _error_popup_with_traceback('User Settings read warning', 'Error reading settings from file', self.full_filename, e)

        return self.dict

    def exists(self, filename=None, path=None):
        """Checks if a particular settings file exists

        Returns `True` if it does.

        :param filename: The name of the file to use. Can be a full path and filename or just filename
        :type filename:  (str or None)
        :param path:     The folder that the settings file will be stored in. Do not include the filename.
        :type path:      (str or None)
        """
        cfull_filename, cpath, cfilename = self._compute_filename(filename=filename, path=path)
        if os.path.exists(cfull_filename):
            return True
        return False

    def delete_entry(self, key, section=None, silent_on_error=None):
        """Deletes an individual settings entry

        If no filename has been specified up to this point,
        then a default filename will be used.
        After value has been deleted, the settings file is written to disk.

        :param key: Setting to be deleted. Can be any valid dictionary key type (i.e. must be hashable)
        :type key:  (Any)
        :param silent_on_error: Determines if error should be shown. This parameter overrides the silent on error setting for the object.
        :type silent_on_error:  (bool)
        """
        if self.full_filename is None:
            self.set_location()
            self.read()
        if not self.use_config_file:  # Is using JSON file
            if key in self.dict:
                del self.dict[key]
                if self.autosave:
                    self.save()
            else:
                if silent_on_error is False or (
                        silent_on_error is not True and not self.silent_on_error):
                    _error_popup_with_traceback(
                        'User Settings delete_entry Warning - key', key,
                        ' not found in settings')

        else:
            if section is not None:
                section_dict = self.get(section)
                del self.get(section)[key]

    def delete_section(self, section):
        """Deletes a section with the name provided in the section parameter

        Your .ini file will be saved afterwards if auto-save enabled (default: ON).

        :param section:     Name of the section to delete
        :type section:      str
        """
        if not self.use_config_file:
            return

        section_dict = self.section_class_dict.get(section, None)
        section_dict.delete_section()
        del self.section_class_dict[section]
        if self.autosave:
            self.save()

    def set(self, key, value):
        """Sets an individual setting to the specified value

        If no filename has been specified up to this point,
        then a default filename will be used.
        After value has been modified, the settings file is written to disk.

        NOTE: This call is not value for a config file normally.
        If it is, then the key is assumed to be the section key and the value
        written will be the default value.

        :param key:      Setting to be saved. Can be any valid dictionary key type
        :type key:       (Any)
        :param value:    Value to save as the setting's value. Can be anything
        :type value:     (Any)
        :return:         value that key was set to
        :rtype:          (Any)
        """

        if self.full_filename is None:
            self.set_location()
        # if not autosaving, then don't read the file or else will lose changes
        if not self.use_config_file:
            if self.autosave or self.dict == {}:
                self.read()
            self.dict[key] = value
        else:
            self.section_class_dict[key].set(value, self.default_value)

        if self.autosave:
            self.save()
        return value

    def get(self, key, default=None):
        """Returns the value of a specified setting

        If the setting is not found in the settings dictionary,
        then the user specified default value will be returned.

        It no default is specified and nothing is found, then the default value is returned.
        This default can be specified in this call, or previously defined by calling `set_default`.
        If nothing specified now or previously, then `None` is returned as default.

        :param key:     Key used to lookup the setting in the settings dictionary
        :type key:      (Any)
        :param default: Value to use should the key not be found in the dictionary
        :type default:  (Any)
        :return:        Value of specified settings
        :rtype:         (Any)
        """
        if self.default_value is not None:
            default = self.default_value

        if self.full_filename is None:
            self.set_location()
            if self.autosave or self.dict == {}:
                self.read()
        if not self.use_config_file:
            value = self.dict.get(key, default)
        else:
            value = self.section_class_dict.get(key, None)
            if key not in list(self.section_class_dict.keys()):
                self.section_class_dict[key] = self._SectionDict(key, {}, self.config, self)
                value = self.section_class_dict[key]
                value.new_section = True
        return value

    def get_dict(self):
        """Returns the current settings dictionary

        If you have not setup the filename for the settings,
        a default one will be used and then read.

        NOTE: You can display the dictionary in text format by printing the object itself.

        :return: The current settings dictionary
        :rtype:  Dict
        """
        if self.full_filename is None:
            self.set_location()
            if self.autosave or self.dict == {}:
                self.read()
                self.save()
        return self.dict

    def __setitem__(self, item, value):
        """Enables setting a setting by using [ ] notation like a dictionary

        Your code will have this kind of pattern:
        ```
        settings = sg.UserSettings()
        settings[item] = value
        ```

        :param item:  The key for the setting to change. Needs to be a hashable type. Basically anything but a list
        :type item:   Any
        :param value: The value to set the setting to
        :type value:  Any
        """
        return self.set(item, value)

    def __getitem__(self, item):
        """Enables accessing a setting using [ ] notation like a dictionary

        If the entry does not exist, then the default value will be returned.
        This default value is `None` unless user sets by calling
            `UserSettings.set_default_value(default_value)`

        :param item: The key for the setting to change. Needs to be a hashable type. Basically anything but a list
        :type item:  Any
        :return:     The setting value
        :rtype:      Any
        """
        return self.get(item, self.default_value)

    def __delitem__(self, item):
        """Deletes an individual user setting

        This is the same as calling `delete_entry`.
        The syntax for deleting the item using this manner is:
            `del settings['entry']`

        :param item: The key for the setting to delete
        :type item:  Any
        """
        if self.use_config_file:
            return self.get(item)
        else:
            self.delete_entry(key=item)


# Create a singleton for the settings information so that the settings functions can be used
if UserSettings._default_for_function_interface is None:
    UserSettings._default_for_function_interface = UserSettings()


def user_settings_filename(filename=None, path=None):
    """Sets the filename and path for your settings file

    Either parameter can be optional.

    If you don't choose a path, one is provided for you that is OS specific
    Windows path default: `%UserProfile%/AppData/Local/FreeSimpleGUI/settings`

    If you do not choose a filename, your application's `filename + .json` will be used.

    Normally the filename and path are split in the `user_settings` calls.
    However for this call they can be combined so that the filename
    contains both the path and filename.

    :param filename: The name of the file to use. Can be a full path and filename or just filename
    :type filename:  (str)
    :param path:     The folder that the settings file will be stored in. Do not include the filename.
    :type path:      (str)
    :return:         The full pathname of the settings file that has both the path and filename combined.
    :rtype:          (str)
    """
    settings = UserSettings._default_for_function_interface
    if filename is not None or path is not None: # Any parameter means we're changing the location
        settings.set_location(filename, path)
    return settings.get_filename(filename, path)


def user_settings_delete_filename(filename=None, path=None, report_error=False):
    """Deletes the filename and path for your settings file

    Either parameter can be optional.
    If you don't choose a path, one is provided for you that is OS specific
    Windows path default = `%UserProfile%/AppData/Local/FreeSimpleGUI/settings`.
    If you do not choose a filename, your application's `filename + .json` will be used.
    Also sets your current dictionary to a blank one.

    :param filename: The name of the file to use. Can be a full path and filename or just filename
    :type filename:  (str)
    :param path:     The folder that the settings file will be stored in. Do not include the filename.
    :type path:      (str)
    """
    settings = UserSettings._default_for_function_interface
    settings.delete_file(filename, path, report_error=report_error)


def user_settings_set_entry(key, value):
    """
    Sets an individual setting to the specified value.  If no filename has been specified up to this point,
    then a default filename will be used.
    After value has been modified, the settings file is written to disk.

    :param key:   Setting to be saved. Can be any valid dictionary key type
    :type key:    (Any)
    :param value: Value to save as the setting's value. Can be anything
    :type value:  (Any)
    """
    settings = UserSettings._default_for_function_interface
    settings.set(key, value)


def user_settings_delete_entry(key, silent_on_error=None):
    """Deletes an individual settings entry

    If no filename has been specified up to this point,
    then a default filename will be used.
    After value has been deleted, the settings file is written to disk.

    :param key: Setting to be saved. Can be any valid dictionary key type (hashable)
    :type key:  (Any)
    :param silent_on_error: Determines if an error popup should be shown if an error occurs. Overrides the silent onf effort setting from initialization
    :type silent_on_error:  (bool)
    """
    settings = UserSettings._default_for_function_interface
    settings.delete_entry(key, silent_on_error=silent_on_error)


def user_settings_get_entry(key, default=None):
    """Returns the value of a specified setting

    If the setting is not found in the settings dictionary,
    then the user specified default value will be returned.
    It no default is specified and nothing is found, then `None` is returned.

    If the key isn't in the dictionary, then it will be added and the settings file saved.
    If no filename has been specified up to this point, then a default filename will be assigned and used.
    The settings are __saved prior to returning__.

    :param key:     Key used to lookup the setting in the settings dictionary
    :type key:      (Any)
    :param default: Value to use should the key not be found in the dictionary
    :type default:  (Any)
    :return:        Value of specified settings
    :rtype:         (Any)
    """
    settings = UserSettings._default_for_function_interface
    return settings.get(key, default)


def user_settings_save(filename=None, path=None):
    """Saves the current settings dictionary

    If a filename or path is specified in the call, then it will override
    any previously specified filename to create a new settings file.

    The settings dictionary is then saved to the newly defined file.

    :param filename: The fFilename to save to. Can specify a path or just the filename. If no filename specified, then the caller's filename will be used.
    :type filename:  (str)
    :param path:     The (optional) path to use to save the file.
    :type path:      (str)
    :return:         The full path and filename used to save the settings
    :rtype:          (str)
    """
    settings = UserSettings._default_for_function_interface
    return settings.save(filename, path)


def user_settings_load(filename=None, path=None):
    """Specifies the path and filename to use for the settings
        and reads the contents of the file

    The filename can be a full filename including a path, or the path can be specified separately.
    If none is specified, then the caller's filename will be used with .json extension.

    :param filename: Filename to load settings from (and save to in the future)
    :type filename:  (str)
    :param path:     Path to the file. Defaults to a specific folder depending on the operating system
    :type path:      (str)
    :return:         The settings dictionary (i.e. all settings)
    :rtype:          (dict)
    """
    settings = UserSettings._default_for_function_interface
    return settings.load(filename, path)


def user_settings_file_exists(filename=None, path=None):
    """Determines if a settings file exists

    If soit exists a boolean `True` is returned.

    If either a filename or a path is not included, then the appropriate default will be used.

    :param filename: Filename to check
    :type filename:  (str)
    :param path:     Path to the file. Defaults to a specific folder depending on the operating system
    :type path:      (str)
    :return:         True if the file exists
    :rtype:          (bool)
    """
    settings = UserSettings._default_for_function_interface
    return settings.exists(filename=filename, path=path)


def user_settings_write_new_dictionary(settings_dict):
    """Writes a specified dictionary to the currently defined settings filename

    :param settings_dict: The dictionary to be written to the currently defined settings file
    :type settings_dict:  (dict)
    """
    settings = UserSettings._default_for_function_interface
    settings.write_new_dictionary(settings_dict)


def user_settings_silent_on_error(silent_on_error=False):
    """Used to control the display of error messages

    By default, error messages are displayed to stdout.

    :param silent_on_error: If True then all error messages are silenced (not displayed on the console)
    :type silent_on_error:  (bool)
    """
    settings = UserSettings._default_for_function_interface
    settings.silent_on_error = silent_on_error


def user_settings():
    """Returns the current settings dictionary

    If you've not setup the filename for the settings,
    a default one will be used and then read.

    :return:            The current settings dictionary as a dictionary or a nicely formatted string representing it
    :rtype:             (dict or str)
    """
    settings = UserSettings._default_for_function_interface
    return settings.get_dict()


def user_settings_object():
    """Returns the object that is used for the function version of this API

    With this object you can use the object interface, print it out in a nice format, etc.

    :return:    The UserSettings obect used for the function level interface
    :rtype:     (UserSettings)
    """
    return UserSettings._default_for_function_interface


'''
'########:'##::::'##:'########::'######::::::::'###::::'########::'####:
 ##.....::. ##::'##:: ##.....::'##... ##::::::'## ##::: ##.... ##:. ##::
 ##::::::::. ##'##::: ##::::::: ##:::..::::::'##:. ##:: ##:::: ##:: ##::
 ######:::::. ###:::: ######::: ##::::::::::'##:::. ##: ########::: ##::
 ##...:::::: ## ##::: ##...:::: ##:::::::::: #########: ##.....:::: ##::
 ##:::::::: ##:. ##:: ##::::::: ##::: ##:::: ##.... ##: ##::::::::: ##::
 ########: ##:::. ##: ########:. ######::::: ##:::: ##: ##::::::::'####:
........::..:::::..::........:::......::::::..:::::..::..:::::::::....::
'''
def execute_command_subprocess(command, *args, wait=False, cwd=None,
        pipe_output=False, merge_stderr_with_stdout=True, stdin=None):
    """Runs the specified command as a subprocess

    By default the call is non-blocking.
    The function will immediately return without waiting for the process to complete running.
    You can use the returned `popen` object to communicate with the subprocess and get the results.

    Returns a subprocess' Popen object.

    :param command:                  The command/file to execute. What you would type at a console to run a program or shell command.
    :type command:                   (str)
    :param *args:                    Variable number of arguments that are passed to the program being started as command line parms
    :type *args:                     (Any)
    :param wait:                     If True then wait for the subprocess to finish
    :type wait:                      (bool)
    :param cwd:                      Working directory to use when executing the subprocess
    :type cwd:                       (str))
    :param pipe_output:              If True then output from the subprocess will be piped. You MUST empty the pipe by calling execute_get_results or your subprocess will block until no longer full
    :type pipe_output:               (bool)
    :param merge_stderr_with_stdout: If True then output from the subprocess stderr will be merged with stdout. The result is ALL output will be on stdout.
    :type merge_stderr_with_stdout:  (bool)
    :param stdin:                    Value passed to the Popen call. Defaults to subprocess.DEVNULL so that the pyinstaller created executable work correctly
    :type stdin:                     (bool)
    :return:                         Popen object
    :rtype:                          (subprocess.Popen)
    """
    if stdin is None:
        stdin = subprocess.DEVNULL
    if command is None or command.strip() == '':
        return None
    try:
        if args is not None:
            expanded_args = ' '.join(args)
            if command[0] != '"' and ' ' in command:
                command = '"' + command + '"'
            if pipe_output:
                if merge_stderr_with_stdout:
                    sp = subprocess.Popen(command + ' ' + expanded_args, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=cwd, stdin=stdin)
                else:
                    sp = subprocess.Popen(command + ' ' + expanded_args, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd, stdin=stdin)
            else:
                sp = subprocess.Popen(command + ' ' + expanded_args, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, cwd=cwd, stdin=stdin)
        else:
            sp = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd, stdin=stdin)
        if wait:
            out, err = sp.communicate()
            if out:
                print(out.decode("utf-8"))
            if err:
                print(err.decode("utf-8"))
    except Exception as e:
        warnings.warn(
            'Error in execute_command_subprocess {}'.format(e), UserWarning)
        _error_popup_with_traceback(
            'Error in execute_command_subprocess', e, 'command={}'.format(command),
            'args={}'.format(args), 'cwd={}'.format(cwd))
        sp = None
    return sp


def execute_py_file(pyfile, parms=None, cwd=None, interpreter_command=None, wait=False, pipe_output=False, merge_stderr_with_stdout=True):
    """Executes a Python file

    The interpreter to use is chosen based on this priority order:
        1. interpreter_command paramter
        2. global setting "-python command-"
        3. the interpreter running running FreeSimpleGUI

    :param pyfile:                   the file to run
    :type pyfile:                    (str)
    :param parms:                    parameters to pass on the command line
    :type parms:                     (str)
    :param cwd:                      the working directory to use
    :type cwd:                       (str)
    :param interpreter_command:      the command used to invoke the Python interpreter
    :type interpreter_command:       (str)
    :param wait:                     the working directory to use
    :type wait:                      (bool)
    :param pipe_output:              If True then output from the subprocess will be piped. You MUST empty the pipe by calling execute_get_results or your subprocess will block until no longer full
    :type pipe_output:               (bool)
    :param merge_stderr_with_stdout: If True then output from the subprocess stderr will be merged with stdout. The result is ALL output will be on stdout.
    :type merge_stderr_with_stdout:  (bool)
    :return:                         Popen object
    :rtype:                          (subprocess.Popen) | None
    """
    if cwd is None:
        # if the specific file is not found (not an absolute path) then assume it's relative to '.'
        if not os.path.exists(pyfile):
            cwd = '.'

    if pyfile[0] != '"' and ' ' in pyfile:
        pyfile = '"' + pyfile + '"'
    if interpreter_command is not None:
        python_program = interpreter_command
    else:
        # use the version CURRENTLY RUNNING if nothing is specified. Previously used the one from the settings file
        freesimplegui_user_settings.load()  # Refresh the settings just in case they've changed via another program
        python_program = freesimplegui_user_settings.get('-python command-', '')
        if python_program == '':  # if no interpreter set in the settings, then use the current one
            python_program = sys.executable
            # python_program = 'python' if running_windows() else 'python3'
    if parms is not None and python_program:
        sp = execute_command_subprocess(python_program, pyfile, parms, wait=wait, cwd=cwd, pipe_output=pipe_output, merge_stderr_with_stdout=merge_stderr_with_stdout)
    elif python_program:
        sp = execute_command_subprocess(python_program, pyfile, wait=wait, cwd=cwd, pipe_output=pipe_output, merge_stderr_with_stdout=merge_stderr_with_stdout)
    else:
        print('execute_py_file - No interpreter has been configured')
        sp = None
    return sp


def execute_py_get_interpreter():
    """Returns Python Interpreter from the system settings

    If none found in the settings file then the currently
    running interpreter is returned.

    :return: Full path to python interpreter (uses settings file or sys.executable)
    :rtype:  (str)
    """
    freesimplegui_user_settings.load()  # Refresh the settings just in case they've changed via another program
    interpreter = freesimplegui_user_settings.get('-python command-', '')
    if interpreter == '':
        interpreter = sys.executable
    return interpreter


def execute_py_get_running_interpreter():
    """Returns the command that is currently running

    :return: Full path to python interpreter (uses sys.executable)
    :rtype:  (str)
    """
    return sys.executable


def execute_editor(file_to_edit, line_number=None):
    """Runs the editor that was configured in the global settings
        and opens the file to a specific line number

    Two global settings keys are used.
    '-editor program-' the command line used to startup your editor. It's set
        in the global settings window or by directly manipulating the FreeSimpleGUI settings object
    '-editor format string-' a string containing 3 "tokens" that describes the command that is executed
            <editor> <file> <line>
    :param file_to_edit: the full path to the file to edit
    :type file_to_edit:  (str)
    :param line_number:  optional line number to place the cursor
    :type line_number:   (int)
    :return:             Popen object
    :rtype:              (subprocess.Popen) | None
    """
    if file_to_edit is not None and len(file_to_edit) != 0 and file_to_edit[0] not in ('\"', "\'") and ' ' in file_to_edit:
        file_to_edit = '"' + file_to_edit + '"'
    freesimplegui_user_settings.load()  # Refresh the settings just in case they've changed via another program
    editor_program = freesimplegui_user_settings.get('-editor program-', None)
    if editor_program is not None:
        format_string = freesimplegui_user_settings.get('-editor format string-', None)
        # if no format string, then just launch the editor with the filename
        if not format_string or line_number is None:
            sp = execute_command_subprocess(editor_program, file_to_edit)
        else:
            command = _create_full_editor_command(file_to_edit, line_number, format_string)
            sp = execute_command_subprocess(editor_program, command)
    else:
        print('No editor has been configured in the global settings')
        sp = None
    return sp


def execute_get_results(subprocess_id, timeout=None) -> tuple:
    """Get the text results of a previously executed execute call

    Returns a tuple of the strings (stdout, stderr)

    :param subprocess_id: a Popen subprocess ID returned from a previous execute call
    :type subprocess_id:  (subprocess.Popen)
    :param timeout:       Time in fractions of a second to wait. Returns '','' if timeout. Default of None means wait forever
    :type timeout:        (None | float)
    :returns:             Tuple with 2 strings (stdout, stderr)
    :rtype:               (str | None , str | None)
    """
    out_decoded = err_decoded = None
    if subprocess_id is not None:
        try:
            out, err = subprocess_id.communicate(timeout=timeout)
            if out:
                out_decoded = out.decode("utf-8")
            if err:
                err_decoded = err.decode("utf-8")
        except ValueError:
            pass
        except subprocess.TimeoutExpired:
            # a Timeout error is not actually an error that needs to be reported
            pass
        except Exception as e:
            popup_error('Error in execute_get_results', e)
    return out_decoded, err_decoded


def execute_subprocess_still_running(subprocess_id):
    """Returns `True` is the subprocess ID provided
        is for a process that is still running

    :param subprocess_id: ID previously returned from Exec API calls that indicate this value is returned
    :type subprocess_id:  (subprocess.Popen)
    :return:              True if the subproces is running
    :rtype:               bool
    """
    if subprocess_id.poll() == 0:
        return False
    return True


def execute_file_explorer(folder_to_open=''):
    """
    The global settings has a setting called -   "-explorer program-"
    It defines the program to run when this function is called.
    The optional folder parameter specified which path should be opened.

    :param folder_to_open: The path to open in the explorer program
    :type folder_to_open:  str
    :return:               Popen object
    :rtype:                (subprocess.Popen) | None
    """
    freesimplegui_user_settings.load()  # Refresh the settings just in case they've changed via another program
    explorer_program = freesimplegui_user_settings.get('-explorer program-', None)
    if explorer_program is not None:
        sp = execute_command_subprocess(explorer_program, folder_to_open)
    else:
        print('No file explorer has been configured in the global settings')
        sp = None
    return sp


def execute_find_callers_filename():
    """Returns the first filename found in a traceback
        that is not the name of this file (__file__)

    Used internally with the debugger for example.

    :return: filename of the caller, assumed to be the first non-framework file
    :rtype:  str
    """
    try:  # lots can go wrong so wrapping the entire thing
        trace_details = traceback.format_stack()
        file_info_freesimplegui, error_message = None, ''
        for line in reversed(trace_details):
            if __file__ not in line:
                file_info_freesimplegui = line.split(",")[0]
                error_message = line
                break
        if file_info_freesimplegui is None:
            return ''
        error_parts = None
        if error_message != '':
            error_parts = error_message.split(', ')
            if len(error_parts) < 4:
                error_message = error_parts[0] + '\n' + error_parts[1] + '\n' + ''.join(error_parts[2:])
        if error_parts is None:
            print('*** Error popup attempted but unable to parse error details ***')
            print(trace_details)
            return ''
        filename = error_parts[0][error_parts[0].index('File ') + 5:]
        return filename
    except:
        return ''


def _create_full_editor_command(file_to_edit, line_number, edit_format_string):
    """
    The global settings has a setting called -   "-editor format string-"
    It uses 3 "tokens" to describe how to invoke the editor
    in a way that starts at a specific line number
    <editor> <file> <line>

    :param file_to_edit:
    :type file_to_edit:        str
    :param edit_format_string:
    :type edit_format_string:  str
    :return:
    :rtype:
    """
    command = edit_format_string
    command = command.replace('<editor>', '')
    command = command.replace('<file>', file_to_edit)
    command = command.replace('<line>', str(line_number) if line_number is not None else '')
    return command


def execute_get_editor():
    """Gets the path to the editor based on user settings
        or on framework's global settings

    :return: Path to the editor
    :rtype:  str
    """
    try:  # in case running with old version that doesn't have a global settings path
        global_editor = freesimplegui_user_settings.get('-editor program-')
    except:
        global_editor = ''

    return user_settings_get_entry('-editor program-', global_editor)


def execute_restart(your_filename, parms=''):
    """Restarts your program

    The currently running process is exited and a new one is started.
    NOTE: This function calls exit and thus will not return.

    :param your_filename:       Set this parm to __file__
    :type your_filename:        str
    :param parms:               Parameters to pass to your program when it's restarted
    :type parms:                str

    """
    try:
        execute_py_file(your_filename, parms, pipe_output=False, wait=False)
        exit()
    except Exception as e:
        print(f'ERROR restarting program: {your_filename}')
        exit()


'''
'##::::'##::::'###:::::'######::::::'######::'########::'########::'######::'####:'########:'####::'######::
 ###::'###:::'## ##:::'##... ##::::'##... ##: ##.... ##: ##.....::'##... ##:. ##:: ##.....::. ##::'##... ##:
 ####'####::'##:. ##:: ##:::..::::: ##:::..:: ##:::: ##: ##::::::: ##:::..::: ##:: ##:::::::: ##:: ##:::..::
 ## ### ##:'##:::. ##: ##::::::::::. ######:: ########:: ######::: ##:::::::: ##:: ######:::: ##:: ##:::::::
 ##. #: ##: #########: ##:::::::::::..... ##: ##.....::: ##...:::: ##:::::::: ##:: ##...::::: ##:: ##:::::::
 ##:.:: ##: ##.... ##: ##::: ##::::'##::: ##: ##:::::::: ##::::::: ##::: ##:: ##:: ##:::::::: ##:: ##::: ##:
 ##:::: ##: ##:::: ##:. ######:::::. ######:: ##:::::::: ########:. ######::'####: ##:::::::'####:. ######::
..:::::..::..:::::..:::......:::::::......:::..:::::::::........:::......:::....::..::::::::....:::......:::
'''


# Dictionary of Mac Patches.  Used to find the key in the global settings and the default value
MAC_PATCH_DICT = {'Enable No Titlebar Patch': ('-mac feature enable no titlebar patch-', False),
                  'Disable Modal Windows': ('-mac feature disable modal windows-', True),
                  'Disable Grab Anywhere with Titlebar': ('-mac feature disable grab anywhere with titlebar-', True),
                  'Set Alpha Channel to 0.99 for MacOS >= 12.3': ('-mac feature disable Alpha 0.99', True)}


def _read_mac_global_settings():
    """Reads the settings from the framework global settings and sets variables
        that are used at runtime to control how certain features behave
    """
    global ENABLE_MAC_MODAL_DISABLE_PATCH
    global ENABLE_MAC_NOTITLEBAR_PATCH
    global ENABLE_MAC_DISABLE_GRAB_ANYWHERE_WITH_TITLEBAR
    global ENABLE_MAC_ALPHA_99_PATCH

    ENABLE_MAC_MODAL_DISABLE_PATCH = (
        freesimplegui_user_settings.get(
            MAC_PATCH_DICT['Disable Modal Windows'][0],
            MAC_PATCH_DICT['Disable Modal Windows'][1]))
    ENABLE_MAC_NOTITLEBAR_PATCH = (
        freesimplegui_user_settings.get(
        MAC_PATCH_DICT['Enable No Titlebar Patch'][0],
        MAC_PATCH_DICT['Enable No Titlebar Patch'][1]))
    ENABLE_MAC_DISABLE_GRAB_ANYWHERE_WITH_TITLEBAR = (
        freesimplegui_user_settings.get(
            MAC_PATCH_DICT['Disable Grab Anywhere with Titlebar'][0],
            MAC_PATCH_DICT['Disable Grab Anywhere with Titlebar'][1]))
    ENABLE_MAC_ALPHA_99_PATCH = (
        freesimplegui_user_settings.get(
            MAC_PATCH_DICT['Set Alpha Channel to 0.99 for MacOS >= 12.3'][0],
            MAC_PATCH_DICT['Set Alpha Channel to 0.99 for MacOS >= 12.3'][1]))


def _mac_should_apply_notitlebar_patch():
    """Uses a combination of the tkinter version number
        and the setting from the global settings to determine
        if the no-titlebar patch should be applied

    :return:    True if should apply the no titlebar patch on the Mac
    :rtype:     (bool)
    """

    if not running_mac():
        return False

    try:
        tver = [int(n) for n in framework_version.split('.')]
        if tver[0] == 8 and tver[1] == 6 and tver[2] < 10 and ENABLE_MAC_NOTITLEBAR_PATCH:
            return True
    except Exception as e:
        warnings.warn('Exception while trying to parse tkinter version {} Error = {}'.format(framework_version, e), UserWarning)

    return False


def _mac_should_set_alpha_to_99():
    if not running_mac():
        return False
    if not ENABLE_MAC_ALPHA_99_PATCH:
        return False
    # At this point, we're running a Mac and the alpha patch is enabled
    # Final check is to see if Mac OS version is 12.3 or later
    try:
        platform_mac_ver = platform.mac_ver()[0]
        mac_ver = platform_mac_ver.split('.') if '.' in platform_mac_ver else (platform_mac_ver, 0)
        if (int(mac_ver[0]) >= 12 and int(mac_ver[1]) >= 3) or int(mac_ver[0]) >= 13:
            return True
    except Exception as e:
        warnings.warn('_mac_should_seet_alpha_to_99 Exception while trying check mac_ver. Error = {}'.format(e), UserWarning)
        return False

    return False


def main_mac_feature_control():
    """Window to set settings that will be used across all framework programs
        that choose to use them

    Use set_options to set the path to the folder for all framework settings.

    :return: True if settings were changed
    :rtype:  (bool)
    """
    current_theme = theme()
    theme('dark red')
    layout = [
        [T('Mac FreeSimpleGUI Feature Control', font='DEFAIULT 18')],
        [T('Use this window to enable / disable features.')],
        [T('Unfortunately, on some releases of tkinter on the Mac, there are problems that')],
        [T('create the need to enable and disable sets of features. This window facilitates the control.')],
        [T('Feature Control / Settings', font='_ 16 bold')],
        [T('You are running tkinter version:', font='_ 12 bold'), T(framework_version, font='_ 12 bold')]
    ]

    for key, value in MAC_PATCH_DICT.items():
        layout += [[Checkbox(key, k=value[0], default=freesimplegui_user_settings.get(value[0], value[1]))]]
    layout += [[T('Currently the no titlebar patch ' + ('WILL' if _mac_should_apply_notitlebar_patch() else 'WILL NOT') + ' be applied')],
               [T('The no titlebar patch will ONLY be applied on tkinter versions < 8.6.10')]]
    layout += [[Button('Ok'), Button('Cancel')]]

    window = Window('Mac Feature Control', layout, keep_on_top=True, finalize=True)
    while True:
        event, values = window.read()
        if event in ('Cancel', WIN_CLOSED):
            break
        if event == 'Ok':
            for key, value in values.items():
                print('setting {} to {}'.format(key, value))
                freesimplegui_user_settings.set(key, value)
            break
    window.close()
    theme(current_theme)


'''
'########::'########:'########::'##::::'##::'######::::'######:::'########:'########::
 ##.... ##: ##.....:: ##.... ##: ##:::: ##:'##... ##::'##... ##:: ##.....:: ##.... ##:
 ##:::: ##: ##::::::: ##:::: ##: ##:::: ##: ##:::..::: ##:::..::: ##::::::: ##:::: ##:
 ##:::: ##: ######::: ########:: ##:::: ##: ##::'####: ##::'####: ######::: ########::
 ##:::: ##: ##...:::: ##.... ##: ##:::: ##: ##::: ##:: ##::: ##:: ##...:::: ##.. ##:::
 ##:::: ##: ##::::::: ##:::: ##: ##:::: ##: ##::: ##:: ##::: ##:: ##::::::: ##::. ##::
 ########:: ########: ########::. #######::. ######:::. ######::: ########: ##:::. ##:
........:::........::........::::.......::::......:::::......::::........::..:::::..::
'''
class _Debugger:
    debugger = None
    DEBUGGER_MAIN_WINDOW_THEME = 'dark grey 13'
    DEBUGGER_POPOUT_THEME = 'dark grey 13'
    WIDTH_VARIABLES = 23
    WIDTH_RESULTS = 46

    WIDTH_WATCHER_VARIABLES = 20
    WIDTH_WATCHER_RESULTS = 60

    WIDTH_LOCALS = 80
    NUM_AUTO_WATCH = 9

    MAX_LINES_PER_RESULT_FLOATING = 4
    MAX_LINES_PER_RESULT_MAIN = 3

    DEBUGGER_POPOUT_WINDOW_FONT = 'Sans 8'
    DEBUGGER_VARIABLE_DETAILS_FONT = 'Courier 10'

    """
        #     #                    ######
        ##   ##   ##   # #    #    #     # ###### #####  #    #  ####   ####  ###### #####
        # # # #  #  #  # ##   #    #     # #      #    # #    # #    # #    # #      #    #
        #  #  # #    # # # #  #    #     # #####  #####  #    # #      #      #####  #    #
        #     # ###### # #  # #    #     # #      #    # #    # #  ### #  ### #      #####
        #     # #    # # #   ##    #     # #      #    # #    # #    # #    # #      #   #
        #     # #    # # #    #    ######  ###### #####   ####   ####   ####  ###### #    #
    """
    def __init__(self):
        self.watcher_window = None  # type: Window
        self.popout_window = None  # type: Window
        self.local_choices = {}
        self.myrc = ''
        self.custom_watch = ''
        self.locals = {}
        self.globals = {}
        self.popout_choices = {}

    # Includes the DUAL PANE (now 2 tabs)!  Don't forget REPL is there too!
    def _build_main_debugger_window(self, location=(None, None)):
        old_theme = theme()
        theme(_Debugger.DEBUGGER_MAIN_WINDOW_THEME)

        def InVar(key1):
            row1 = [T('    '),
                    I(key=key1, size=(_Debugger.WIDTH_VARIABLES, 1)),
                    T('', key=key1 + 'CHANGED_', size=(_Debugger.WIDTH_RESULTS, 1)), B('Detail', key=key1 + 'DETAIL_'),
                    B('Obj', key=key1 + 'OBJ_'), ]
            return row1

        variables_frame = [InVar('_VAR0_'),
                           InVar('_VAR1_'),
                           InVar('_VAR2_'), ]

        interactive_frame = [[T('>>> '), In(size=(83, 1), key='-REPL-',
                                            tooltip='Type in any "expression" or "statement"\n and it will be disaplayed below.\nPress RETURN KEY instead of "Go"\nbutton for faster use'),
                              B('Go', bind_return_key=True, visible=True)],
                             [Multiline(size=(93, 26), key='-OUTPUT-', autoscroll=True, do_not_clear=True, expand_x=True, expand_y=True)], ]

        autowatch_frame = [[Button('Choose Variables To Auto Watch', key='-LOCALS-'),
                            Button('Clear All Auto Watches'),
                            Button('Show All Variables', key='-SHOW_ALL-'),
                            Button('Locals', key='-ALL_LOCALS-'),
                            Button('Globals', key='-GLOBALS-'),
                            Button('Popout', key='-POPOUT-')]]

        var_layout = []
        for i in range(_Debugger.NUM_AUTO_WATCH):
            var_layout.append([
                T('', size=(_Debugger.WIDTH_WATCHER_VARIABLES, 1), key='_WATCH%s_' % i),
                T('', size=(_Debugger.WIDTH_WATCHER_RESULTS, _Debugger.MAX_LINES_PER_RESULT_MAIN), key='_WATCH%s_RESULT_' % i, )
            ])

        col1 = [
            [Frame('Auto Watches', autowatch_frame + var_layout, title_color=theme_button_color()[0])]
        ]
        col2 = [
            [Frame('Variables or Expressions to Watch', variables_frame, title_color=theme_button_color()[0]), ],
            [Frame('REPL-Light - Press Enter To Execute Commands', interactive_frame, title_color=theme_button_color()[0], expand_x=True, expand_y=True), ]
        ]

        # Tab based layout
        layout = [[Text('Debugging: ' + self._find_users_code())],
                  [TabGroup([[Tab('Variables', col1), Tab('REPL & Watches', col2)]], expand_x=True, expand_y=True)]]

        # ------------------------------- Create main window -------------------------------
        window = Window("FreeSimpleGUI Debugger", layout, icon=PSG_DEBUGGER_LOGO, margins=(0, 0), location=location, keep_on_top=True, right_click_menu=[[''], ['Exit', ]], resizable=True)

        Window._read_call_from_debugger = True
        window.finalize()
        Window._read_call_from_debugger = False

        window.Element('_VAR1_').SetFocus()
        self.watcher_window = window
        theme(old_theme)
        return window

    """
        #     #                    #######                               #
        ##   ##   ##   # #    #    #       #    # ###### #    # #####    #        ####   ####  #####
        # # # #  #  #  # ##   #    #       #    # #      ##   #   #      #       #    # #    # #    #
        #  #  # #    # # # #  #    #####   #    # #####  # #  #   #      #       #    # #    # #    #
        #     # ###### # #  # #    #       #    # #      #  # #   #      #       #    # #    # #####
        #     # #    # # #   ##    #        #  #  #      #   ##   #      #       #    # #    # #
        #     # #    # # #    #    #######   ##   ###### #    #   #      #######  ####   ####  #
    """
    def _refresh_main_debugger_window(self, mylocals, myglobals):
        if not self.watcher_window:  # if there is no window setup, nothing to do
            return False
        event, values = self.watcher_window.read(timeout=1)
        if event in (None, 'Exit', '_EXIT_', '-EXIT-'):  # EXIT BUTTON / X BUTTON
            try:
                self.watcher_window.close()
            except:
                pass
            self.watcher_window = None
            return False
        # ------------------------------- Process events from REPL Tab -------------------------------
        cmd = values['-REPL-']  # get the REPL entered
        # BUTTON - GO (NOTE: This button is invisible!!)
        if event == 'Go':  # GO BUTTON
            self.watcher_window.Element('-REPL-').Update('')
            self.watcher_window.Element('-OUTPUT-').Update(">>> {}\n".format(cmd), append=True, autoscroll=True)

            try:
                result = eval('{}'.format(cmd), myglobals, mylocals)
            except Exception as e:
                if sys.version_info[0] < 3:
                    result = 'Not available in Python 2'
                else:
                    try:
                        result = exec('{}'.format(cmd), myglobals, mylocals)
                    except Exception as e:
                        result = 'Exception {}\n'.format(e)

            self.watcher_window.Element('-OUTPUT-').Update('{}\n'.format(result), append=True, autoscroll=True)
        # BUTTON - DETAIL
        elif event.endswith('_DETAIL_'):  # DETAIL BUTTON
            var = values['_VAR{}_'.format(event[4])]
            try:
                result = str(eval(str(var), myglobals, mylocals))
            except:
                result = ''
            old_theme = theme()
            theme(_Debugger.DEBUGGER_MAIN_WINDOW_THEME)
            popup_scrolled(str(values['_VAR{}_'.format(event[4])]) + '\n' + result, title=var, non_blocking=True, font=_Debugger.DEBUGGER_VARIABLE_DETAILS_FONT)
            theme(old_theme)
        # BUTTON - OBJ
        elif event.endswith('_OBJ_'):  # OBJECT BUTTON
            var = values['_VAR{}_'.format(event[4])]
            try:
                result = ObjToStringSingleObj(mylocals[var])
            except Exception as e:
                try:
                    result = eval('{}'.format(var), myglobals, mylocals)
                    result = ObjToStringSingleObj(result)
                except Exception as e:
                    result = '{}\nError showing object {}'.format(e, var)
            old_theme = theme()
            theme(_Debugger.DEBUGGER_MAIN_WINDOW_THEME)
            popup_scrolled(str(var) + '\n' + str(result), title=var, non_blocking=True, font=_Debugger.DEBUGGER_VARIABLE_DETAILS_FONT)
            theme(old_theme)
        # ------------------------------- Process Watch Tab -------------------------------
        # BUTTON - Choose Locals to see
        elif event == '-LOCALS-':  # Show all locals BUTTON
            self._choose_auto_watches(mylocals)
        # BUTTON - Locals (quick popup)
        elif event == '-ALL_LOCALS-':
            self._display_all_vars('All Locals', mylocals)
        # BUTTON - Globals (quick popup)
        elif event == '-GLOBALS-':
            self._display_all_vars('All Globals', myglobals)
        # BUTTON - clear all
        elif event == 'Clear All Auto Watches':
            if popup_yes_no('Do you really want to clear all Auto-Watches?', 'Really Clear??') == 'Yes':
                self.local_choices = {}
                self.custom_watch = ''
        # BUTTON - Popout
        elif event == '-POPOUT-':
            if not self.popout_window:
                self._build_floating_window()
        # BUTTON - Show All
        elif event == '-SHOW_ALL-':
            for key in self.locals:
                self.local_choices[key] = not key.startswith('_')

        # -------------------- Process the manual "watch list" ------------------
        for i in range(3):
            key = '_VAR{}_'.format(i)
            out_key = '_VAR{}_CHANGED_'.format(i)
            self.myrc = ''
            if self.watcher_window.Element(key):
                var = values[key]
                try:
                    result = eval(str(var), myglobals, mylocals)
                except:
                    result = ''
                self.watcher_window.Element(out_key).Update(str(result))
            else:
                self.watcher_window.Element(out_key).Update('')

        # -------------------- Process the automatic watch list ------------------
        slot = 0
        for key in self.local_choices:
            if key == '-CUSTOM_WATCH-':
                continue
            if self.local_choices[key]:
                self.watcher_window.Element('_WATCH{}_'.format(slot)).Update(key)
                try:
                    self.watcher_window.Element('_WATCH{}_RESULT_'.format(slot), silent_on_error=True).Update(mylocals[key])
                except:
                    self.watcher_window.Element('_WATCH{}_RESULT_'.format(slot)).Update('')
                slot += 1

            if slot + int(not self.custom_watch in (None, '')) >= _Debugger.NUM_AUTO_WATCH:
                break
        # If a custom watch was set, display that value in the window
        if self.custom_watch:
            self.watcher_window.Element('_WATCH{}_'.format(slot)).Update(self.custom_watch)
            try:
                self.myrc = eval(self.custom_watch, myglobals, mylocals)
            except:
                self.myrc = ''
            self.watcher_window.Element('_WATCH{}_RESULT_'.format(slot)).Update(self.myrc)
            slot += 1
        # blank out all of the slots not used (blank)
        for i in range(slot, _Debugger.NUM_AUTO_WATCH):
            self.watcher_window.Element('_WATCH{}_'.format(i)).Update('')
            self.watcher_window.Element('_WATCH{}_RESULT_'.format(i)).Update('')

        return True  # return indicating the window stayed open

    def _find_users_code(self):
        try:  # lots can go wrong so wrapping the entire thing
            trace_details = traceback.format_stack()
            file_info_freesimplegui, error_message = None, ''
            for line in reversed(trace_details):
                if __file__ not in line:
                    file_info_freesimplegui = line.split(",")[0]
                    error_message = line
                    break
            if file_info_freesimplegui is None:
                return ''
            error_parts = None
            if error_message != '':
                error_parts = error_message.split(', ')
                if len(error_parts) < 4:
                    error_message = error_parts[0] + '\n' + error_parts[1] + '\n' + ''.join(error_parts[2:])
            if error_parts is None:
                print('*** Error popup attempted but unable to parse error details ***')
                print(trace_details)
                return ''
            filename = error_parts[0][error_parts[0].index('File ') + 5:]
            return filename
        except:
            return

    """
        ######                                 #     #
        #     #  ####  #####  #    # #####     #  #  # # #    # #####   ####  #    #
        #     # #    # #    # #    # #    #    #  #  # # ##   # #    # #    # #    #
        ######  #    # #    # #    # #    #    #  #  # # # #  # #    # #    # #    #
        #       #    # #####  #    # #####     #  #  # # #  # # #    # #    # # ## #
        #       #    # #      #    # #         #  #  # # #   ## #    # #    # ##  ##
        #        ####  #       ####  #          ## ##  # #    # #####   ####  #    #

        ######                                    #                     #     #
        #     # #    # #    # #####   ####       # #   #      #         #     #   ##   #####   ####
        #     # #    # ##  ## #    # #          #   #  #      #         #     #  #  #  #    # #
        #     # #    # # ## # #    #  ####     #     # #      #         #     # #    # #    #  ####
        #     # #    # #    # #####       #    ####### #      #          #   #  ###### #####       #
        #     # #    # #    # #      #    #    #     # #      #           # #   #    # #   #  #    #
        ######   ####  #    # #       ####     #     # ###### ######       #    #    # #    #  ####
    """
    def _display_all_vars(self, title, dict):
        """Displays all vars into a single text box"""
        num_cols = 3
        output_text = ''
        num_lines = 2
        cur_col = 0
        out_text = title + '\n'
        longest_line = max([len(key) for key in dict])
        line = []
        sorted_dict = {}
        for key in sorted(dict.keys()):
            sorted_dict[key] = dict[key]
        for key in sorted_dict:
            value = dict[key]
            wrapped_text = str(value)
            out_text += '{} - {}\n'.format(key, wrapped_text)
        old_theme = theme()
        theme(_Debugger.DEBUGGER_MAIN_WINDOW_THEME)
        popup_scrolled(out_text, title=title, non_blocking=True, font=_Debugger.DEBUGGER_VARIABLE_DETAILS_FONT, keep_on_top=True, icon=PSG_DEBUGGER_LOGO)
        theme(old_theme)

    """
        #####                                        #     #
       #     # #    #  ####   ####   ####  ######    #  #  #   ##   #####  ####  #    #
       #       #    # #    # #    # #      #         #  #  #  #  #    #   #    # #    #
       #       ###### #    # #    #  ####  #####     #  #  # #    #   #   #      ######
       #       #    # #    # #    #      # #         #  #  # ######   #   #      #    #
       #     # #    # #    # #    # #    # #         #  #  # #    #   #   #    # #    #
        #####  #    #  ####   ####   ####  ######     ## ##  #    #   #    ####  #    #

        #     #                                                       #     #
        #     #   ##   #####  #   ##   #####  #      ######  ####     #  #  # # #    #
        #     #  #  #  #    # #  #  #  #    # #      #      #         #  #  # # ##   #
        #     # #    # #    # # #    # #####  #      #####   ####     #  #  # # # #  #
         #   #  ###### #####  # ###### #    # #      #           #    #  #  # # #  # #
          # #   #    # #   #  # #    # #    # #      #      #    #    #  #  # # #   ##
           #    #    # #    # # #    # #####  ###### ######  ####      ## ##  # #    #
    """
    def _choose_auto_watches(self, my_locals):
        old_theme = theme()
        theme(_Debugger.DEBUGGER_MAIN_WINDOW_THEME)
        num_cols = 3
        output_text = ''
        num_lines = 2
        cur_col = 0
        layout = [[Text('Choose your "Auto Watch" variables', font='ANY 14', text_color='red')]]
        longest_line = max([len(key) for key in my_locals])
        line = []
        sorted_dict = {}
        for key in sorted(my_locals.keys()):
            sorted_dict[key] = my_locals[key]
        for key in sorted_dict:
            line.append(CB(key, key=key, size=(longest_line, 1),
                           default=self.local_choices[key] if key in self.local_choices else False))
            if cur_col + 1 == num_cols:
                cur_col = 0
                layout.append(line)
                line = []
            else:
                cur_col += 1
        if cur_col:
            layout.append(line)

        layout += [
            [Text('Custom Watch (any expression)'), Input(default_text=self.custom_watch, size=(40, 1), key='-CUSTOM_WATCH-')]]
        layout += [
            [Ok(), Cancel(), Button('Clear All'), Button('Select [almost] All', key='-AUTO_SELECT-')]]

        window = Window('Choose Watches', layout, icon=PSG_DEBUGGER_LOGO, finalize=True, keep_on_top=True)

        while True:  # event loop
            event, values = window.read()
            if event in (None, 'Cancel', '-EXIT-'):
                break
            elif event == 'Ok':
                self.local_choices = values
                self.custom_watch = values['-CUSTOM_WATCH-']
                break
            elif event == 'Clear All':
                popup_quick_message('Cleared Auto Watches', auto_close=True, auto_close_duration=3, non_blocking=True, text_color='red', font='ANY 18')
                for key in sorted_dict:
                    window.Element(key).Update(False)
                window.Element('-CUSTOM_WATCH-').Update('')
            elif event == 'Select All':
                for key in sorted_dict:
                    window.Element(key).Update(False)
            elif event == '-AUTO_SELECT-':
                for key in sorted_dict:
                    window.Element(key).Update(not key.startswith('_'))

        # exited event loop
        window.Close()
        theme(old_theme)

    """
        ######                            #######
        #     # #    # # #      #####     #       #       ####    ##   ##### # #    #  ####
        #     # #    # # #      #    #    #       #      #    #  #  #    #   # ##   # #    #
        ######  #    # # #      #    #    #####   #      #    # #    #   #   # # #  # #
        #     # #    # # #      #    #    #       #      #    # ######   #   # #  # # #  ###
        #     # #    # # #      #    #    #       #      #    # #    #   #   # #   ## #    #
        ######   ####  # ###### #####     #       ######  ####  #    #   #   # #    #  ####

        #     #
        #  #  # # #    # #####   ####  #    #
        #  #  # # ##   # #    # #    # #    #
        #  #  # # # #  # #    # #    # #    #
        #  #  # # #  # # #    # #    # # ## #
        #  #  # # #   ## #    # #    # ##  ##
         ## ##  # #    # #####   ####  #    #
    """
    def _build_floating_window(self, location=(None, None)):
        """
        :param location:
        :type location:
        """
        if self.popout_window:  # if floating window already exists, close it first
            self.popout_window.Close()
        old_theme = theme()
        theme(_Debugger.DEBUGGER_POPOUT_THEME)
        num_cols = 2
        width_var = 15
        width_value = 30
        layout = []
        line = []
        col = 0
        # self.popout_choices = self.local_choices
        self.popout_choices = {}
        if self.popout_choices == {}:  # if nothing chosen, then choose all non-_ variables
            for key in sorted(self.locals.keys()):
                self.popout_choices[key] = not key.startswith('_')

        width_var = max([len(key) for key in self.popout_choices])
        for key in self.popout_choices:
            if self.popout_choices[key] is True:
                value = str(self.locals.get(key))
                h = min(len(value) // width_value + 1, _Debugger.MAX_LINES_PER_RESULT_FLOATING)
                line += [Text('{}'.format(key), size=(width_var, 1), font=_Debugger.DEBUGGER_POPOUT_WINDOW_FONT),
                         Text(' = ', font=_Debugger.DEBUGGER_POPOUT_WINDOW_FONT),
                         Text(value, key=key, size=(width_value, h), font=_Debugger.DEBUGGER_POPOUT_WINDOW_FONT)]
                if col + 1 < num_cols:
                    line += [VerticalSeparator(), T(' ')]
                col += 1
            if col >= num_cols:
                layout.append(line)
                line = []
                col = 0
        if col != 0:
            layout.append(line)
        layout = [[T(SYMBOL_X, enable_events=True, key='-EXIT-', font='_ 7')], [Column(layout)]]

        Window._read_call_from_debugger = True
        self.popout_window = Window('Floating', layout, alpha_channel=0, no_titlebar=True, grab_anywhere=True,
                                    element_padding=(0, 0), margins=(0, 0), keep_on_top=True,
                                    right_click_menu=['&Right', ['Debugger::RightClick', 'Exit::RightClick']], location=location, finalize=True)
        Window._read_call_from_debugger = False

        if location == (None, None):
            screen_size = self.popout_window.GetScreenDimensions()
            self.popout_window.Move(screen_size[0] - self.popout_window.Size[0], 0)
        self.popout_window.SetAlpha(1)
        theme(old_theme)
        return True

    """
        ######
        #     # ###### ###### #####  ######  ####  #    #
        #     # #      #      #    # #      #      #    #
        ######  #####  #####  #    # #####   ####  ######
        #   #   #      #      #####  #           # #    #
        #    #  #      #      #   #  #      #    # #    #
        #     # ###### #      #    # ######  ####  #    #

        #######
        #       #       ####    ##   ##### # #    #  ####
        #       #      #    #  #  #    #   # ##   # #    #
        #####   #      #    # #    #   #   # # #  # #
        #       #      #    # ######   #   # #  # # #  ###
        #       #      #    # #    #   #   # #   ## #    #
        #       ######  ####  #    #   #   # #    #  ####

        #     #
        #  #  # # #    # #####   ####  #    #
        #  #  # # ##   # #    # #    # #    #
        #  #  # # # #  # #    # #    # #    #
        #  #  # # #  # # #    # #    # # ## #
        #  #  # # #   ## #    # #    # ##  ##
         ## ##  # #    # #####   ####  #    #
    """
    def _refresh_floating_window(self):
        if not self.popout_window:
            return
        for key in self.popout_choices:
            if self.popout_choices[key] is True and key in self.locals:
                if key is not None and self.popout_window is not None:
                    self.popout_window.Element(key, silent_on_error=True).Update(self.locals.get(key))
        event, values = self.popout_window.read(timeout=5)
        if event in (None, '_EXIT_', 'Exit::RightClick', '-EXIT-'):
            self.popout_window.Close()
            self.popout_window = None
        elif event == 'Debugger::RightClick':
            show_debugger_window()

"""
M""""""'YMM          dP
M  mmmm. `M          88
M  MMMMM  M .d8888b. 88d888b. dP    dP .d8888b. .d8888b. .d8888b. 88d888b.
M  MMMMM  M 88ooood8 88'  `88 88    88 88'  `88 88'  `88 88ooood8 88'  `88
M  MMMM' .M 88.  ... 88.  .88 88.  .88 88.  .88 88.  .88 88.  ... 88
M       .MM `88888P' 88Y8888' `88888P' `8888P88 `8888P88 `88888P' dP
MMMMMMMMMMM                                 .88      .88
                                        d8888P   d8888P
MM""""""""`M
MM  mmmmmmmM
M'      MMMM dP    dP 88d888b. .d8888b. .d8888b.
MM  MMMMMMMM 88    88 88'  `88 88'  `"" Y8ooooo.
MM  MMMMMMMM 88.  .88 88    88 88.  ...       88
MM  MMMMMMMM `88888P' dP    dP `88888P' `88888P'
MMMMMMMMMMMM
"""
def show_debugger_window(location=(None, None), *args):
    """Shows the large main debugger window

    :param location: Locations (x,y) on the screen to place upper left corner of the window
    :type location:  (int, int)
    :return:         None
    :rtype:          None
    """
    if _Debugger.debugger is None:
        _Debugger.debugger = _Debugger()
    debugger = _Debugger.debugger
    frame = inspect.currentframe()
    prev_frame = inspect.currentframe().f_back
    # frame, *others = inspect.stack()[1]
    try:
        debugger.locals = frame.f_back.f_locals
        debugger.globals = frame.f_back.f_globals
    finally:
        del frame

    if not debugger.watcher_window:
        debugger.watcher_window = debugger._build_main_debugger_window(location=location)
    return True


def show_debugger_popout_window(location=(None, None), *args):
    """Shows the smaller popout window

    Default location is the upper right corner of your screen.

    :param location: Locations (x,y) on the screen to place upper left corner of the window
    :type location:  (int, int)
    :return:         None
    :rtype:          None
    """
    if _Debugger.debugger is None:
        _Debugger.debugger = _Debugger()
    debugger = _Debugger.debugger
    frame = inspect.currentframe()
    prev_frame = inspect.currentframe().f_back
    # frame = inspect.getframeinfo(prev_frame)
    # frame, *others = inspect.stack()[1]
    try:
        debugger.locals = frame.f_back.f_locals
        debugger.globals = frame.f_back.f_globals
    finally:
        del frame
    if debugger.popout_window:
        debugger.popout_window.Close()
        debugger.popout_window = None
    debugger._build_floating_window(location=location)


def _refresh_debugger():
    """Refreshes the debugger windows

    NOTE: Users should **not** be calling this function.
    Within the framework it is called for the **user** every time
    the `Window.Read` function is called.

    :return: return code False if user closed the main debugger window.
    :rtype:  (bool)
    """
    if _Debugger.debugger is None:
        _Debugger.debugger = _Debugger()
    debugger = _Debugger.debugger
    Window._read_call_from_debugger = True
    rc = None

    frame, *others = inspect.stack()[1]
    try:
        debugger.locals = frame.f_back.f_locals
        debugger.globals = frame.f_back.f_globals
    finally:
        del frame
    if debugger.popout_window:
        rc = debugger._refresh_floating_window()
    if debugger.watcher_window:
        rc = debugger._refresh_main_debugger_window(debugger.locals, debugger.globals)
    Window._read_call_from_debugger = False
    return rc


def _debugger_window_is_open():
    """Determines if one of the debugger window is currently open

    :return: returns True if the popout window or the main debug window is open
    :rtype: (bool)
    """

    if _Debugger.debugger is None:
        return False
    debugger = _Debugger.debugger
    if debugger.popout_window or debugger.watcher_window:
        return True
    return False


def get_versions():
    """Returns a human-readable string of version numbers for:

    - Python version
    - Platform (Win, Mac, Linux)
    - Platform version (tuple with information from the platform module)
    - Framework Port (FreeSimpleGUI in this case)
    - TKinter version
    - Framework version
    - The location of the this file

    The format is a newline between each value and descriptive text for each line

    :return:
    :rtype:  str
    """
    if running_mac():
        platform_name, platform_ver = 'Mac', platform.mac_ver()
    elif running_windows():
        platform_name, platform_ver = 'Windows', platform.win32_ver()
    elif running_linux():
        platform_name, platform_ver = 'Linux', platform.libc_ver()
    else:
        platform_name, platform_ver = 'Unknown platorm', 'Unknown platform version'

    versions = "Python Interpeter: {}\nPython version: {}.{}.{}\nPlatform: {}\nPlatform version: {}\nPort: {}\ntkinter version: {}\nFreeSimpleGUI version: {}\nFreeSimpleGUI filename: {}".format(
        sys.executable, sys.version_info.major,
        sys.version_info.minor,
        sys.version_info.micro,
        platform_name, platform_ver,
        port,
        tclversion_detailed,
        ver,
        __file__)
    return versions


# ==================================================#
#
# MM""""""""`M                     oo oo
# MM  mmmmmmmM
# M`      MMMM 88d8b.d8b. .d8888b. dP dP
# MM  MMMMMMMM 88'`88'`88 88'  `88 88 88
# MM  MMMMMMMM 88  88  88 88.  .88 88 88
# MM        .M dP  dP  dP `88888P' 88 dP
# MMMMMMMMMMMM                     88
#                                  dP
# M""MMM""MMM""M                   dP       dP
# M  MMM  MMM  M                   88       88
# M  MMP  MMP  M .d8888b. 88d888b. 88 .d888b88
# M  MM'  MM' .M 88'  `88 88'  `88 88 88'  `88
# M  `' . '' .MM 88.  .88 88       88 88.  .88
# M    .d  .dMMM `88888P' dP       dP `88888P8
# MMMMMMMMMMMMMM
#
# When things look bleak, show your users emojis and a little hope
# ==================================================#

EMOJI_BASE64_BLANK_STARE = b'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'
EMOJI_BASE64_CLAP = b'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'
EMOJI_BASE64_COOL = b'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'
EMOJI_BASE64_CRAZY = b'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'
EMOJI_BASE64_CRY = b'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'
EMOJI_BASE64_DEAD = b'iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAC61BMVEUAAAAYAwAoBgAOAgBsNgASAQBEFAIvBwAuBgBjKwBFEgAvBwAOAQARAgANAAAQAQBYIwBIGQcuBwAZAgAQAQBUHwA/DgB4PgBoMABJHApjLQBtNABJFwAzDgAvCQAtBwAxCQAvCAAoBgBwOAB6QglQIApOHwA5CABXIQBiLAA+EQCEVCs8PDwAw///vgA3HxzMmAA3IR7TngA8PT0+NjQ7CwI9OjnPmgDRnAA8Pj//xgA+NTEAyf9naWlmZmb/wgD/wAA9ODY6MjE+Mi44Kij/6aE/LypWIQE5MC49Ewq6hAEBZpo5GxUAxf8sQ003JCGYYQBBDQA7NjU4JyU9JiA9IxyudgHJlQBkLgBiW1g6ODjAjADMgwCRWAARm8VhYWY+Kyc9Hhb0tAC2fQCHUAB4QwB0PwBNGABFEQADvPNHwbdPwbAid5EvWWZpZmRFRUU4LCs8GhJ9RwH5ugC7jACmcQCDSgBcJwAAy/8MqdlYwaUma4IqaH//5nz//2avyFg1SlFFIRQ6EwxmVAWeaALkpQHvsADTlADUiwAA0v8BwPkUlLv/6Jj/5ImAxoT/4W/91FU5QUQ6QEL/0DD/zyJNJQ5WSQZRRAbqqgLFjwLknADFkgCwfgClaACTXACJVACa7P8F0f8Pos4dgZ9jwpxtw5ONxncrYnKYx26oyF9dXV8yVV7/3FdWVFY4RUn+yCP/xwhcOAhQHQLcowHuowDWoADdkwDLjAAYZo1zwYs3UFS4yE9VPDagewLmrQDGhwCE5P8Uyv8Jr+EKtuDg7cMysrmR07gZi64HYpX/7ZEqdoZIZXXCyG+enmZ0dGajyGX//2TMyWSzyFVRS0xbWkb/2ERNOTPfqibSnibMlBz2vRrqsBRIOgZoPgS0iAG7fQH/yAD9swBm4PtQ0/Og7u+66ea15+Yrv8vI5MpQmpKYtXXXs27u7mbj42aCgmaRt2CLplEuPkYyNjrywDdWSzBLLSLKoQt8ZAWEaQTFIq9KAAAALHRSTlMANVAJ/S/CdGnLtmIpIxsQ2Mt/QT3Nofv38fDl2LWqnJeHWfTv4cCS7+Gs/K/WTwAAAAaSSURBVEjH1ZZ1QBNRGMBhjBATwe6uud1ut+B2bKw3FNkYjDmkW+lORVKRUlAUBezu7u7u7u6uP313cyFh/Onvj+3uxo/ve99777tn8V/T3pJk27f34FZ6Bvfq07G/Zbs/Wm1s7Xukam5cvza7KDg4KTi4aHZt8baQhh6DO1r+TiPZd3G7VpmTU3Gler0rAZ/PRwH82dtCHezat6BZ2qRerzwhKatcR20CH+Vv8utJataz7Xqj4oSkosqV2jyo677wIVZNvX6fTx8+/Pzojh1LFmdmTgCMJwAXmZmLFy/ZUb50+bv3l+2bmHY7H86fv//AyN/ivuBk50aeteDRnz1gpq9q/ato/+Lx0ydHM5eUly9duvzcihWTJk26uGvXrovge8WKc8uXLy0vB0MYf+TZkUG/1NaSXCkpLVuPPti8ubZ269YpU6aMMwCut26trd28+QEfLSqGvib+EnJISI5EsjpYmbYxIjJSxWyMKjIyIkKWWpjkA8HzbMw8qw63SktLb5KZQYGBgVKRSMQlQPRf4F4qDQz0ZsqKYQiCurYxy7RLlURSoWRKnY0wDBB3OrFYThEwyUCEG8xytatbLZF8kgU5U1pCTKN5UAIj53EgOKWPSeyzrUJSNocpbVFk6DxoNLWAGQpDHLdOJtFmU45ktR+TxaAAWMYPApb+Mp5Gp+sStBDEnjusnVltyiTrtAlEQNZ0AYUimM4yeM4MAYNFmSGk02lyrwg3DsTpam0Q2/W4WZpTGOGFi8jJQ9FcbtahRYjeW7twYa5oun9GLp1GE4tUKTAEhzkZd++AdZLV25giQlw01T06a+TUaVxCFORGTc1Y5b/AfZU3KA9X0QDEUJJxoXapllRrmAgDDzHDHxs5Elu49meuyLIorAQryRLgg/RUhAPRzzgflolVZWi9Ql8bASUDww7OQAzFkWa7u2PRUoacRqd5JmjZEKy0M4qpVZX81LyfIbKiMKwk2iAK1vpjGJaRKxACURiU5sM2FxOr1/HD8hh6zz3df1o6Bkx9jRcuKFkUteBgLh5R7i2bg4umMa53RcPynAnx2FR/Z9Y0Y3F2lrhnS2Oi0mOkRrG+tamqfCoQGfr6L5suYDkvyzVMZEwMQkFWxTgLjWIoyTSPSa5oaJ5OR5QVYREfLARHQEEQPDBCkRvHmOho7N0divioUiGUA9EAMiP7mP+06J1cw2qN11cVrByytYWBToV8VMMUqVlGE4nJwADpUdGCnzmrDfPo0930QuhdjKLFKpFazDB6UZi+O2H6tcfwpNPBylH5wWzfDqYW2TEENHmZl5wmZ4AdjC+fjHRDX3NfhjDAUzHIVCxVaWDOPHuzd4YfSuWH53mC34Q6sI+QbCIeAebP9fQU4onShN4yXzZc0A8YxvmgUsEguWCf0+geHmr1xzEmPnjQwWM8UwGxVBNJJtEKVIc/O8JbR8f/AGe0GTQ6ADwWSvFdBXVva94e790Pdg1linRiD1yjNwJ/pPZEFGAWOSE2FmY4JqKF8Jw0ZpCUK4xXg9yMEMmr44WeIm9mRAoHbCpbc9GqZ2GwD3tuQ0SkIsELNFahUB4vxomXC4VCkdQrSKGKDAN9g+0DMjXHzs8Vgjjs/NvhWlmkSqFICPL2wvEOSlAoVKqN2rANNclggFuUjV5XVg779oKQ+bOSYd95BQ1hZG2aTLZRJkvTasNDlZpkNju/5i5I1G1o28anhkFuW9hQfk0yh82BAdBcX5y5EHHHYfuA/8nekqwlNT0B9FSyN32/DXq1HrYew53vrHwYThna36Ip7TqTNXdnfQNiM8B7avaEhNm0cGZxGt79Ts0eDozDMQATJM/aQLYB4VqibevhHbom1hekaELc9IRoUgrqU8kd7G2tLX6PVRvH1h379u7Vc+NMQLdevfv0syNZt7f4azoGMnQUUS+Lf8Ha1t7BodtknG4ODjZ9SX+M19bJydHJ1qbb7stjDayJi7v6ZVBnkqOjk6VVi9kNLKhT+pF3u5iz8lJcXJwstb6uzq9T2xYyHJFzZX3SXs1VFx4gNjaWxwsICHDhrYlj3dlUhKL3izs3L/Z9VU2luiYpd7sAjZe9/VQs78yZswE83sq4DVv4+BFyYLMh2w2sogIxOPSSC/CyRo0aderCxIlv3gbwXNbM9MHPlOi+fs2JtvdQXNwbvgZE3D4K5+X5iRNfnw1wWTk5BPwEshnWTH2tOhXxqQB4w0qX2Oztx3Hx+GlgXgjgBQQWJBEh64yr7gccAJfWZWgXFAAAAABJRU5ErkJggg=='
EMOJI_BASE64_DEPRESSED = b'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'
EMOJI_BASE64_DREAMING = b'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'
EMOJI_BASE64_SKEPTICAL = b'iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAC+lBMVEUAAAAVCgiJUwAaAgBsNQBCEgAuBgBdJwAeAwAqICBIGAQsBwAcAwAPAQAMAQBhMQOXYQB1PgAPAgBqamdWIAA3DQBFPTdmZmZnNAVYIwBQHgAwCAAzCgAdAgBfYWJDEwRGHxGDSwByOwBkLwhCFAAqBgBsR0BsR0A1BwAmBQBuR0BcQkBIPUBPJQgvBwCDTAFrRkDGxmYAw/88PDz/vQDTngDMmAA3IB3/xgAAyv8Axv/OmQA7Pj8+NTJmZmb/vwDRnAAAZpo6GRP/wgA6Kig8JyI3JSI5HRloams+LSg8IRxRHAA+MC3//2Y9Ojk9ODbaogHPmwC+iwDypwBqZmQ6QkU6MTA9DwXIlABADQADvfQIsOH/6aI4MzU+NzSdZwGATQFWIQH8uQCQVwBbJgBIFAAAzv8agKA7NzbpqgCueABzPQBiKwATlr4jc4z/54U2Rks5CwTtrwBoMQAEwvgFt+wLqtodepYWZo5jY2ZfX2Y3TlL/ziU8FAurbwHDjgC6hAC1fACSXAB9RgABw/wNpNBSxrFcxqgYhqgoX3AuWWcyUl3/3FwxTliwwE+3v0hHRkj+zzNAIRg/HxRSRwbjqATztAD6rwCS6f4SwusHtOYiwtstwdAYiq7/6JonZnr/2EteT0nEwD7+xw+pggXUlgCocwChbgCp6/cNn8w7xMZFxb306a4mbIHFzGl2dmb//mRcWVwvOT9SOTJULxZHQAh5YgXQkgDJigCkaQCdXwAAX5wLZpT/6ZEhaIo6ZnxPZnH/5HD9/Wbg4GaYmGZRUlQwSFBeUEwrQErJvzUxMDPQvy3SmBX/yAD3twBW0+tmx58sY4L22XtWZm7w8Gb39mWOjWX70VFgUk1YSki6v0XlsjLgwSHVsxnuwxZdNhZzQwZvWgWFawRFJQK5jAF4PQAzzPZ71dM7r8dfxqZfxqXa4Ys9fYbW1oVSjYNnl36vhEnxxUXWrj6nqTipnyypeCyvnCL4vhxzSgyobQlsPgdhNgZvWQVuWQXIxL7HAAAAMnRSTlMACP4y/rlr6EwZzYBAJiD+/uwR/t6a/vv50b2vjVb+/fjq3c2un29nYV1UQTDydfJh/nD2VQwAAAcFSURBVEjHjZZlWFNRHMZl5WSgYHd3K7tL7na9KzfnNqbbwA3HxgYDRpdIKygiKCjY3d3d3d3d3d0+j+dOHRe9xvuBcc748Y/znqhCpOpkL3qT9kBN6F7k6h4Ef0HA0BmtW7X07eZj3piVtdHs0823ZavWDHr1v1PVaA19s45cPl80I4Pjlshavj7LtyGt2h+xmoyq5stFsdNiZ2QImTgJRQCPMFdl1CTm6LU/vow1bS2azSSS6GjCkNp0Io5W/9XWJUuezjp8cNasS6NHjx7lEvjl0qxZBw8ePnzlytU59bsScOn3FyyYcG9iUk9C5SVNnDh58pR02q8cue7xCRMm8Hr+VTxuUl2vypyH54MJCxYcnzxlyqJFixcPGzZs+PDhD0+ceAQ+wGDx4kWLpkyZPHniRG6+p0flxoQ8XrLk1LXZHCHTah0/fnw/nMDQamUKObOvXX335vWHJpVA6pHYadNKx2XdpSQmOm02i6WPWxaLzeZMTKTczTrGnDtXE0mtZJf6paZpseXOeFQmUygkQGK3wEABJEPjnRoNi8+q740DO2wqMpnOR8XD/gTyG6iLC5bo/eB4CsRiQaQOOLDNhp2mrUeC5P5+vwlg4ZMGGFPFMj950DyIBc1rgwM9y2NNO0PjVURcekpSwfTU6OhVbFXmUIiF5HjivF31/TRTqRMlCKiOMxrT5XKlZNUIafAYWyCfH1i1wu2dKRmmWI1d7j8QhgdWCqtSLUzW+RWOKIxDUalYbs9FWIizsxvsNLTUVJQbD+uWFsQU+sPqChBO5Y2IMfbk8pLDD6FS2OADiozq5AY7hpaaMkIz1cWF4VxeSmr6QFj1gyvkFURzeZjbwowHUAdWJBTS0Q123zQjlhOF+qt1KTxgyAHR0+NcOcNxk/KjuT+MyjUe0qOJCFiPdm6w3aYZRdZEmT88lfvdy7xJ0UtH6lTpKZNi8twWDwuXKEB3oNC2brDtxhkZCTaFX1wyz70PuHnJxiRjsTsgmJu0SmHRBgAQF7F0doRFoh7Bw22hAeHhMTpdMn6qcEwfLYIHu/vMFmHgUi4eTFfC8MgBOJA7fUyfHATUiOsqR5RgkQycXgksVvupiyuBI0DEANBV3DpyROOcCuXIPBxo1Kn8VDojDswrHmvJDgDriHMO2MCJMr0jpSIkdyqMLeRU3Ex+8Fgn6GqNzjivWoWcoZnBiooieUkj1ZhVQZEVmcpRCsRn4bzq4Rkh4mw0wGxxdBjvx3LEwN+9E8P9MRM2la03kKAALf7UaTSXw1kfpBTL9FN5XEwDYgYCh2OGV8cMcM3khbOlSrAhkdxGVSrEyAXdsSmC2TJFcUF+ysLUfUqHCvYf6Q87HPK41IUp+QX7ZLJgRR/QGzMDB3qROEwOyaCWstkoypbKUJlUKluVn7TwkIzNxkZsVMaWqjNvAI8PpVfB7+RxIpCr3AHIn0LDw3hhqah7LHVgRwd+H7uKXC8qT4iKlzj04p8sWhAGfI3+oMR6hyQ+kcWHwPGIV5PQoxArO8rebIxcqdeLxVKQ6oHksOQDIGexWK9Xysc0s0dpEbAbO1S+GmtHRAQGQPNv2+2GTFQhkSuVSvm+6XFy8CFRoJkGu/22GQLnhrb2L5ckjXQMnJlz1n7NMYdQbH3sQQaDISgoCPyw97FRQsw5X9bOgUCmQ3+9rjxaZ5XzkTlr12kgCArU5kbO9xkC5DM/MlcbiECQZt3aOQgfGkL1+O0epw5hae6U3URYLBY/AIHcQgL4YAq5WXZHww+lEtzmHo0pkci6MtAAAgVoy9YhkZTGxC8XL2oUqezW9yA4ucLfKiNFUb2q/Enkxp5dQsyROdrsQCxhLMnAbG1OpDmki2djcpW/ypvetQ21QYPaVWu4VLV2gwbUNl3p3lX+Ux7k5sFAzckEVf0laofGdRo1GwvUrFGdOjTyv4ma1b29yTRql9UzL1zYPxNo/8W6dVc392R4eXtXr/bn9Oq0bNHCl2LZL+hdoaZ7S0pKmjt9W7Ro2fBPL0Hai50ZogTNjZW9BQJB//79BYK0wWkCwd4S3ZrAchHn6NzWfwjY6pQIvNk09Vdi3I5t2/sPXr5n+WBBraYla7RCIXiwkIirbfI2gwlA/vU0jNvSq9fJc2f7ntmDkZJIADI5c+sQgg0jQEChMGdNb8D1Atr87GzfvrsAmab0OSbEvvMlahAZnDvgS+v81b37nx40yEU+X9G375nlaYK6IQkAZHJyaQQgY4MLTCBdxMDtWwYB8AkA+54b3LvkswYDRQkNiVozToSBmk8rQaourtegZYBbViut1t412VaMJGqPV+j3TLNBb0Bztrk4EHA31teVknmuf8vZwPgNrLNBxASKACXWq1fvJOC2LVuxa9fu3T1q1avXFA7RuN7XEQ3c3v0Gj2jYxeUmtBsAAAAASUVORK5CYII='
EMOJI_BASE64_EYE_ROLL = b'iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAC9FBMVEUAAABFEwBGEwBGFABFEwBFEwBFEwBNGgBZJQBGFABGEwBHFQBGFABFEwBFEwBFEwBFEwBFEwBFEwBFEwBIGABGFABFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFMR9SKQpGFABFEwBHFQBFEwBFEwBFEwBFEwA8PDzMmAD/vgBFEwA3IR4Aw/9mZmb80y3/5ZkAgrU8OjpSRwdGRkZGFQBDHA04JCH8uwC5fgBPHQAPw/DvvhCtcwCZ5/8Pn8s9NzU7NTQ/Lyk4KSdBJRr/wAfKlgBnNQBYJQACwvwGtesHsuYah6lTa3UsX245QkQ5LCr/xBZEFAL6ugDtrgDfpgC9igDFiAC0gACrdwB1PwANpdURm8b/5JYgeZVvwZCGwHlkZGQ1SlE7ODc5MTE4JiNEGAjpqgDRkwDGkwC/gwCcaQCYZQCQXACHVQBwPQBuOQBhLgCL5P8CvvcCvfcEu/MfwuAmwtkMqdkOo9EvwtA/wsAUlLxPwbAZi64OfqpewaEdgZ8jc4z/4YkmbYL/3n1KbXv/3HZaaW6fwGAyUlyuwFH/0UxMTEw4REjUtjz/zTs7OzrGvzn30C85MC/Svy05Ly0/LSbfvyA3IyBBIxdKHAlXSgdPOwX+vQD3uADqrQDmqwDbowDdnwDUngDXmQDMjwDAjAClcQCgbACNWAB+RwB6RABjMQBcKABWIgBY2P+c5/wIw/ep5+8SwOuz5+ULq90dvdv/8s3N5ssissr+78TW5sIyuMDg5rhwybEYjK9Xwah4xZcmboXi2IQqZXguW2gvWWabwGT/12JdXV1ZWVlhWlj/1FZWVlZRUVGjkk83R0yUp0s3R0u4v0dbS0W7v0RGRUT/z0E7P0EvOkDOsT9LUz9MQDymoC/50S7/yStGMitRMSVFKR5PLB1HIhJkPxD/wQuMbgSjfQK2igHkpQDgoQDXoAC4hQC6fwCncwCmbACfZgCdZACIUQCCTwCBTgB8SQBfKgCPQcWcAAAAK3RSTlMAYfn2wG4j/vzw6ea5p6FXUUA4NP7fybGdkIiDd2dJHRkH/v7Uxqurmi8SFA87JQAABGhJREFUSMeV1mVU21AUwPHCgLm7u768m7JQ2lG6DYexwQZs2Ji7u7u7u7u7u7u7u7v7vuzmpRltBLb/ORzyTvM77yaEnhi08iicL08GYGUsXc6lqOFfck8D1drGWkNDqT1rK9+NkN4lZZXTNTw25owgjIihit7Z0nvosuKWpFcjBKHBY6qVdUMaHVfIEtpAEIbJM6plG8im5TK/PH5w/56jgwf069urZ+XKlasbsa140LNX334DBjdqfPrqw5KF1M7lflc/v67GVCqRQwVrb/bz8zOmGihd7u1btu041KjxmHE3p86YXaVKFWoPD2fPmHp93JjGjY4c2FV9b14FhPGCIFCxOrHLWq9M8PX1rYrhr4SVrd/HWqnYUo7jFFsWbItusjUtpNAmugThWuc7CxThQoAgotssgEUclsYZxgjCqE2gh0w870MIJHHKWT2+XxCEUJhF9JrJ8zwJARF2cYQFWg8ThAQg+vHinvARYfusDrAUXuL4jSnBaJQEOiGMz6K4NxRCCKse/p0bJpMTuKwx0YQwsBKbNYMKBhDsVA8jVr+67GoMFNe9GyJsEcQgOMPby6RJe5A+eOKVO90l5z+W4LIbqX+XzRqmhvQLg/Xwp6F/U0IirzEYQUhU/Ug8MDK4WgUb0PUMGoncQILVqiUvIxjsqIKT6W8F9CfY0Inysj9CE3RSQUpttZ1g1BCCjR0ur7szWE0XHm5KpHoTVvLd1YXhMMVhy1r+hDU0krC6NWewswZMAhNhUpzOvw+xNyQiipCTxqbB7Ob8RGhxgK4IvwKJljarV6N/FEkuMmLnMUJ4BtcgzOMAM9WhdAUQnuglwzYcl1jAAbon4JYQwM/RdeIl+rBHrkN2B1hhnQjnTudb6P8nyw95uMExQNgZ2DzB0wObTZHPNzULbB7dgpci8AshqGArMPnwKRQcwJ5xixPM2wolVCJz9J0PqQ3oPhd0gkWT6PK4qihNwbyU0Z68ncnUEuoitBmcA/FLsx0AhJhIYLSP01YzmxFTCAA6DBQwX9s6HLbAAljLkKAAYi8gaG5LwHIt4MQ6uhtUW3KYtzcX1q4aKOq0hn2ChYFBWQ5bnATl4hPr1k1cZV/In0Axg6rCaR2hnDOE7AaNyuM3ymvvNtrurfcbrj3up11Z6OA9X2fD+R0hv0G/rPiW026VUsW33wDpi+grGWfOCE7lzpLN8B8BwcDwf+XM4uYGlTBwc8tc5F9V9gzw9LynvUtm8wNwdUmFuEPadOksliaeDjUxY/MgPJ0NyujCLrtH0ThuradzE8zmcG45pfSbh47LtI9icV08FZ01A0fFXHVgrhiKfQB29rSKjzxrenl51cTjc3a4vrimc1lBxTgGK4qJ0Gs0XucLCS7MpAmBSvA5c6yRosTlk3jKsmjCddIbWeINCeKwFSfZ4a0Oi6nYp5waLv8i6X3thzwpdtkOzTaOsjKmMCkkw3uD7HdnAnD6s3amYlZu3l84SXQjR+Py4rMwadaqf190/wDRN/fPi1RLLQAAAABJRU5ErkJggg=='
EMOJI_BASE64_FINGERS_CROSSED = b'iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAC9FBMVEUAAAAOAQBHHAn9vAGWYABhKwIOAQAPAQBmNgI2DQIzDAEyDQEtBwArBwATAgA6EAIgBgArBwAZAgAWAQDrqgHOjABlMQBVIgAvCAAFZZdnZmf/wABLHQZPKh5iLQBdKAI5Fwl2QQGARQA0EwdUNittNgBxOQBHFgAscYnLzWfZ2mdMGQZAEAROHAI2i5Hu7mZJZnR2dmZCTEGMVQBWe19SJwRaJQA9Pzn8+2VXSktEPTA8PDz/vwA3IB0Aw/88PT3SngA8OTg+NjRgYmTNmADPmwA4Kig7EAj/wgD/xgA3IiBnaWk+MzA9MS3ZogBfX2BcW1xbUU05MjI5Ly0AZZpmZmY8JiJDEgFhZWhfV1RUPTT3twC4v0fxsgACyv8ffJpONCs8DQTBggHHkgDCjwC0fQA7NjVSNyo9Fw7/yAGrcQG+igDDegBcJwD/6aKYyG86QkRaSEJTQT07Lis3JiRGJRk8HxlvOgFOGgHhpADTlgDJlQC4hwCveACmbABVIAAA0P+NyXr//2ZqZmT/21ZLP0HEwD7gwCDXmgN+SAKdaQBkLwAMwvEdxeQNocx7x4pfX2YxVWFiW1lQR0s8KydNLCFOKBk6GBJmPBFsWAWGTwH/zADmnQChZQCGUgBryJv/65f/54g0Zn//5HUuWWc1S1I3RkvMvjFxRQ+mfwvckgCPWQArw9APl8BAwr4XkLUaiKgPZpEYZ4wpZ3oqYnT9323392acwmb//2RXVFhPT1RJSk1MNTPYqCRYNR3FiQh+YghSRwdKPAaKVwLMggCF6vkEu/AAr/AVlLr766tDn6gfhJwdd5KTvXGEgmUyUFpUTk770Uf/0CzrtitdNhReNAaV5vyr7vO26esIs+YGrOE1sLRPw7FKwK8ncYpYZGve42iTk2akwFvKmSVDKyX/yh/DpBfzvhX5uwD7rgCeXwA0zPWC08YtucYAWZ3W14gyeXd0qWvT02ahoWZomWQ5X2CowFdPZEb7xSZ4XBqtjRRULxAAlAM5AAAAO3RSTlMACr/+/tEaEf6WjIBjViaiPEo0L/7+4sBy/vLy4t7Yya7+77b17dup/v798+nR/f38+/r6+fnj2/7y0oKvOL8AAAcXSURBVEjH7ZZ1XBNRHMBdoG4jDLC7u3s3d7fb2MZ6c64cDrY5BoqE0qEIiKAgIC3Y3d3d3d3d3fqP7+4Gypz68X+/f4z3Ge+7X7y7916N//wTNeu4073ILd0wWjZsRWN41Cf93fJs1LBN8L0d5x5RIEgAQRSDMTYukNrBy6PWH7V6HdvsOjNvzrzUB0AiEAiEQqEgtrxFo9+rJPqUHRtmz059AFEoUHUEdkN597q/q428ZMORI6/SFy1KT08fUUV6Ovhm0eTJk78WN3Idj3z00qWLz6ZOHeqKqVOnTVv+wd2VSDt64OIB/6F/wN+/T30Xfelz4PLl5zdmzcrJyZk4ceJYwCbsYyIgJ2fWrOvXV75YfpT8q+h1b3boHDvkPXPm0qU++/ePrmT/fp+lS5fOnPlESImLf9i6zi+daX8mNDQ1IzpGowkI4FcnIECj0SQ/NUi5cDDNWfRImhc6e0dMUaRYzOEg1eGIIyXi4QEVUi7P3ILknGnGnNANU/hMtiuQcX6+iESTCHPh1vWcRLdzs0PPxcxgM13BVrJYfkjQFCBS3Z1LPBs6JzCAA0SXjGOxVMPHmHlwIs1pMUrPHEktLfqdx1axWOOwXHkJTgtStzw19HOWHy4iTPwT+WnMHAVyFfOpMM/S0qmpwRvmeMdEYmJYLgcgXnAKAeMF+HjhAsSPxVJiRcY7tdXdOi81zlHiqux189cdvjKfA0KNPLx+/vrV2acQrMioLB6X26D629UocN7ZQD6CiUjYiqET/K+u5+DjVQeHHszO5bB9WSxfrDu8BjWdxFR7IiYCEM6p+blM4OHjhbkLEA4TF2ckW1yIZ4VJfKYDDofQCBXB2hoJxMjkECDWcqpRKAzmM3+3HCCiQ+S2qC7WTRIKE/mjkD+KIFXY7FajGnWoQmEgX6JkY5MWMjnVYIeBRwdvTjxsaVh9U6zXpqwsQxPpi1eVu3rFqtXHRhKsXrXi2AIE8cOWozYMB7eq1ajOjwrbkZstjjMmzxinwhdk4c3sg/4TcPyvHF4fhoCnHH8ApNad7bqHN68qs1We3rR1ijA6SsVSsgEg1YXz1x0fOfL4utww0GHwXmGPXECmNDNNYdI2r1oRhkJuSysvK+ePApWolKMwxBICsVKl8gWJgt7EJMAhOwsUcvKPntq027OM9gyNxJdF4OeA9YNRRdE8XvyY8drwtlUioxDNby2EBNFFCDBd4qcEmcKwtZteYWtWVSO50GSK8YZirZoiiRIk5iyN81WCPad2PCzd180WUVBYuX2Qmunl8u3LpGY4MUsTFDU8UgLKqkSlUklmDA/SxFSY4RBqsh5F5YUelatvQ2WoYrx+cYg0Ye+F6GQNPygoKmo4TlRREJCyoveWSGFLcX6ETSZDdeTKQ0OOoqg+Qpa/D4i7pRZr0rIp0VljMLJqt66gJibwLHtKwOJHoOEmGZgb7kEEDEcVCplcr5cvlibs2Q3zYByu2WyO5+JDHhwCvpdSTysKULneJpe1IrYNBWqKKlDobdrzVrikhFsJD+AYwkv2LoEz+2/RFerHDxfrHGLdcHQbUzK+QKdtTi6l7lkihQmjygchS0oy29MZCm24ScwOk+V5Vaa6lSlWoKiOVqOu14DamYkhlniuI2FevDkkIbiif3eGZw3PdqC+COVWVMfAxfp6VJYfAbrVDjv9atVxp4ErR4MGtXEatHBr2Irh4UkcoTrw66dRVOFO7OLNtSjQtAr6z+ezZzelUulLq9wMHTNR+ZYtcq3CcRsg5283mbanNSeBfzHo4Fbj6e7Vtm3X8YBmbdvSPGqS6rnTGbXAr9EKixcvLt5ZQLyRngOogXEZPkntO5JILeNid/V166rX5eXl6QB5p9PSTM3clvnE+jQk1ehYscsIQYbYJKI5dJ8ycJWxU+DWnrS4MoHdyC1GRSLRJBGOfBs7GjbYBWW76DXIFm/s/iMUdMAraPhEAC4jj4wZLejBdggQslOrVqtvaSeh06ejInTbNy4+vbwu3fpwxKYTm0ZM7os1i+SWs3wauI1ce9+sjQDzDPvyRepJcxuvvXXybeeT09WiNOpj7I5E6eD1OnsoxrR+eP8HEneUQ9m2mbgYdx4F3rBhw9Z03pyy8c50kfyCFAIIY7sev0rcW3rU+1lc8YUISI0QgXjDADdvb07p2VurvZ+EhYTsT9cecohYRNKQactX3li58tqx3bjIK5ap1WvnrlkzbNjLE5tTUt5NV6fVJkIGfnqz6e7HuydmgVQBLXfggnFJhQD7Q40AFfZasxbE7HQ7JWXjSVS09X6SEReXeUMYwjb4PtcRL01gtJYKIIHBAipUEzV26oLXqBZtYV/gGsB867JYAW4Sy8Hwadq0qYFiTCilUAwZpYObAHo1bty4U5dBG3t26dy7SRP5NvE+qYECBWd6Uwxgsjc4B74DqzwM9jJjFWgAAAAASUVORK5CYII='
EMOJI_BASE64_FRUSTRATED = b'iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAC/VBMVEUAAAAfBgBNGAFJGAUqBwAVBAAyCAAQAwBGEAE4CwAbBQA5DAAwCAAtBgARAgAoBQAuCQAbBAATBABiKwA7CgBEFgA3CQAoBwDMwMJSKBhSNB87CQBgKQA6CgBXIgBHKB9kMQBPKx5FHw9dLAB6QAA9CQBOIhIvBwBPIQ7/vQA8PDxmZmYAw///vwA3IB3NmQDTngBnaGg8Pj8/NTJoams+NzX/wwH/yAA8OjlkLQAAzP8AZppkZGQ7GRPQmwAWw+k6Ih5AFAlFRkc+LSh4QAD//2ZhYWGbZAP0twJrMgBcJwBXIgAAyf88MS04KCbYogDEkAAOptJqZmRTNCk4Kyk8JyM3IyBBIxg4HBizgACKVAASmcI4MDDgvx9CHhM+DQKASAAAxv8DwPkoxNkbh6c5QkXuvxH2vgqgZgFwOgGWYABFEgA0xc5iW1hDJBw7Hhn7uwHgogDKkQAOxfEHteggxN8vxNITkroXjLAefJgrYnIwXWctVWJdXl5aWFhAQUJAMy1BKCCXdQP3uADxtAC8gwCQWABRHgAKrt8PZpInaHz/4nb5+GViYmUyT1hISkvlwBo7FQ1IQQeveAXorwTvrwDepgDEiQAA0P8AXpoedI93enqKe3ZdYGdxWlRYTEtNPTo6NzZLMCrbwiT/yg3kqAC7iwCmbgAlv9T/7Z+SkZAbZov/74kpb4U1Zn5JZnRrbWs0S1JRUVFbSEL90T5aPzXotTNcOi3/zCtLFwLUlwCFUQADvPJEvrVnwZiUi4uBgoJokXuOwHFycG/61mfv8GaovlT/21AvQ0toTkQwPELyvyVoTyRCLCR7YgVyWASrcgMyytw6xMawsLAvmKKcmZiIiYp2wYmFvnjS1mjh4WaYmGaIiGZ5eWa+v1XjulLZpjLSvy3NlhzMpRNYMhKMXg1mVgZGNAZWOAS2egAVrdIgqsOytbaHpqE/f4ZMgGf8/Gazs2alpWaFdF9xZF/zzVI2SU+RoU1VZUjAjSeBdCfDoxV9TAxVSwdiOwGhM1DzAAAAKXRSTlMANPXNRBqQC+OfLa6JaSRgVjoS2cO6t00K6P7T0MrF/uz9/PTr69t67qMFhlUAAAeASURBVEjHrZZ3WBJhGMAPMNIc2d57AiEcB8cIKEYqGCGlIkhAmiWSM82RmWZqu8zM9t5777333nvvvffTd3dApo2n5+n3x/Fx9/7ufe/7Pt4D+v/UxfkXw8fNm+pZq3HDGoCGDRvX8vSqWq3S36TKbtSGLU/curHucG8ajclk0mh5JUmbSgNaNm5T5U+aN8V4a83wJcP3b5jDdIKifD4fLclX1qrzO68OJWbd8IUL92wAicqD8tFNSk+fX2mVqEE3lgDtcK9evcZ0x5g9ezb2MWYMONM7EZ0TGEv2rlzBq1ZvWv0jr5+ejFoQlZraAadv377EIDU1Kurk1udH1GunUaqXfzzK2UVvFk05eCCtc492FencbtLAadu3Tzs9hVpOdDv4JG735B2LpjTLWhAV1a9fvz6AU9gBjKNSHx9av/3c5Mni3afrlVsZzynn/MVif3/ugNAvvXr37h0IyMsLxADfxt1BGAxwneF/dpr3zzPTdhGXgQH7RzdX2VQqldAJGNuEitEwflk8eUrNn8Sq63eICXGVwBwentCxLAnhknhONjAxdpB/2gm1D+7GRXgAJ1fBqYg5Ry6GiZTrvctW6h4H455YztPTK8LRmOmrCHHF6tplRI/VsKNQeq6G8ytTr+AMcBTb7UfKKvUdMyMeiOh5iKCCJ+ApzHTH/MD+lB+7Zr1zSgc2WZk+LLqcKkDomT2jFXIg4rSu7lr9tS5Rz8vUpWREI2U8Hn3pkCFLQ486RW69Sr8UeYJJkSnDeK6kSJauR89oRPEXMR4IyEqdqCdd4Hi6SZ1T+iMCjkb/C5HUjcHl4qsoiCeK6ymK4AhwD4ywwjmIWS7GNa5/a+dvy7eRLH5GNsxlwNmaeA4WnYOkT0jDTEGGSMfJwSZrpn6gP8zgiqfPSpDVrkLkI8/Pj1EWxk+HuaOPKjg8JDozfcgWUbtRPLogOmVC5JC0pe8QnsCck71CPMMcZJ2fX9AAm9fKjWKwpjI3prDJdI4e4WWlp0QOicgYloVvhFGZGWlDIrdEZPIkufLpZvXDEhDMVFKx/V1/3xi8qWiVMn3uynRd2rBRHARBeMRagJFgZWZPXcQBWYK9YDAfBbGz3zevAn76Z0Qdtu7rBdTxARsV/cHyg7pwg4cfCJuTmSVTF48DWvddp/pO6E+FvHMisV6RemEMc25wkIJO7BqeIGtSmk6ni8joTydSK8KLbOwS5s1tHbBOonOH3D/0bYfT4cJta5Fzs4yKiBR1xumh64+bIX5+lpjb2xzBUfUhS+ns8x2IhnRmY/hMDuGliLAzeNsSRQKTIwjzCyu6s6AHoe3qFQCp56K0Mbv6YRH9ZWFhJqxSsOrAEnWO7CECkaIIRDCzi5+fX5gdOx+5dV9vGr8UsibSAInXtqU+2qgIAVe7hISEZkwQibb0zDowKiNFJJqQnhDmh2Ey5/RdcP4m3tiToPlEv2cmfj5i0c/0wwk3pUdMOiSRhEskpmERaYfC8bNhApnlk5bGxMMHQ8k0QhxfqlZackBJOBJgEfdwjsJCBLl2oUo6jkkIUBLhBbJj1SyhRa9BTCFd8Mpc4OWbEIXEYjUUGrSJhAmVOBKyhEZtsLHQLksIVWg0JlNISBcAeGCTSaNRhEpkdnUAiy3c7EwJ5eFeHtsQlC9laY/ft6kK7RZZkSShYyhGxwRJkcxiD7J9uz9Iy8LK0jpKJZ51rnSzcByLJT0+dh57niHGqFQJ1UEYaqHNWjDfEKwdNHYQm8U22E9IB+MKRFSqNZApsWwp+9hYAzhisJKDMZLxb1IWGxPZwbaawuC5ZcXx8xtU8lLOI+7rRCqVusbglvO0xS18SeT8cWXFwGBbo2p1KEbDvXssEF0B9ryvxwxKT1JVdyM70SkSC8qOCaKSfGu1eHC3FJT3M9Lg/OMPmnq4udVWGcbnOWYVde6cwVIjmVrFx9ejcY2mys0FsQE4sbHGzcqmNWp5ufm4eQbFjA+kEfEoFBOIEiaTmcgykj1IEFTdh1Stjm/Njl1Cu0g86rhVI/mAtlanpjogCQTRcPhJUAPlYD6NgInOWRdQ6IE1Ih8SqWauRqMxe5FIPtjbpaaw+PAc1KEx+ZvUUGUv4SY+OEEwZ/91ZW03KqVZNyezZjWhUH3dA96uQX/853lIrop1K3IxitKc7N+jkq2O47oYMFoun2G5O3wDDUCkyytoUI14yzWyJvFd6vDrhdNXgJbdtSs4jBTD4lXyXNvwNS4NTVaBp8EB5ZILkpxZNywxzuICb/lyhnjk1RVTYXiA7OMSp8ZMtrqDMl2QPMhGR1Z0nXo1l9F1Wfv2i7teG3Hp8kgGd5Z1DRO/hCYr3b3K/dGp4kGOLeEzwdRa42HMAyzd26lTp1dT4TjZCT7esq3ubYBWHpJnUDGTzw+QxcFdlw3FxInPgPniykjuDHspnz84lkwF2q/wdVcmF8iyQaGLly0eipkXQcqXU+FsxcbifGFtEvQ7qnu1io/DZ2YoJk7cOaJTpxFXRsLZcqSolTf0J2phHma6vMtTwQtXPnqGJ/RHKHEw5k11ensvXbw6EvYHu4Dyc+B3l1L/SjXr7EQAAAAASUVORK5CYII='
EMOJI_BASE64_HAPPY_GASP = b'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'
EMOJI_BASE64_GLASSES = b'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'
EMOJI_BASE64_GOLD_STAR = b'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'
EMOJI_BASE64_YIKES = b'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'
EMOJI_BASE64_GUESS = b'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'
EMOJI_BASE64_HAPPY_BIG_SMILE = b'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'
EMOJI_BASE64_HONEST = b'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'
EMOJI_BASE64_HAPPY_IDEA = b'iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAC91BMVEUAAAAMAwCDTQAWCwAvBwB1PwAsIBEnBQBqMwIuBwBDEgAmBQAyIxgVCgBEFwAgBAD/53z/5HZiKwAwCQAkBgBoMABbJgBKFwJcJwBVIgJgKwBWIwA1DwA1CwD/5kvKrTZ0OwBIIQj/41dGRkb80ytuST89DgBtRC5sRkAtIx9rRj8lAwC0kQ+YdwVoRUD/66NYIwBQTk310zb41jjGoyPMpyD40intxSPJqhv/7qH/7qEAw/88PDw3IB3/vgDMmADSngBnZmb/xgD/wQA8Ojo+NzU/NjPPmwA7EAc6MzI6GxUAyf8AzP89MS43JSI8OTgAZppnaWv//2U9Fg1hYmY4Kin9vgHUnwA+KCJ7RgD/6aI/Lik6FA7//fEVk7k4LzBkMQHurwDFkgCzfwCMUABADgD/6pIuW2k1SE5ZQzs4Hhr4ugDaogCVVAAFwvj/+eAxws7/8bwah6k0TlfhxyZvOgHkpwAFue4Jr+H/9s7/9Mf/77AOZpPaxy71tAC6hwC5gACrdABWJABGEwALw/T/99UNpdP/65kidI3/5YYoZHf/4GovVWD/0zg7NzXYlwDNiwCqawCcYwACwvw3wsheXWDNxzu+iwDFhQClcACgZwCV6///++eXl5cee5dOZnL/6m4lWGq3tWX/21ZER0c5Q0XkrB9NRAdaSwaVXgFOHAE7CwG+dwCNWwAKq9xPwa2Li4svZoIoan7392b/4l1ZVlhQTlC9yEsuO0JTNCb/yRDQlApkUgWjXgAQw+8RnMdDwrz/76QAXZwcZos+e4V9f4Sxy4L/4HLY22d+fmbq6WWqwVRzbkX3ykJJRUBOPTjzwTXToyVOLRlhOhRBHRF+YwSSbgO1cgBo3fuq5tYQn8o9wsKoqrJowpeUxnpWZm6NjWbNsD9wYTHBixTutxFzXQWabQFGw+HN6trP58/U8M3T6M0QocwQoMwQoctjy8O1uL2jo6Rrt4X/7IO8zG6bm2bkv2K5k1zRy1AqLC4dICrQmihGOBL6/7s9AAAAO3RSTlMACP0gaf4VW9V9vkosDrE2/v7nmT7z29LQxsC7o5L7++3p3sHBnpaGbtaVhnhWS0jy18bEuKyom4otIwPAsygAAAbrSURBVEjHlZZ1eBJxGMcRBsjK7u7u1jFuB8dRN4whpQPGYBNw6ubCWuqmLnSburC7u7u7u7u72z987whBNx/9Pnue8d7v97nv933vdw/Q/lM927XrUdoaoxybU6e2f62aNWvW8q9dicOuzHAu+XVvWKF8w26sEqhynBr1l97/fnaRwZCYmGgwxE3aXlhcv2wdHz9YZHXaOwy0t6Hvb1QZtnf49jOZ5SvMz97GdwgllTipuCqHRes6ctzIESNGDjN3LOPp5j14UWaG5nA2P/A3AW4ortbMPHDGuCFDxo3UzGnjznlVOVshwzx/G7W1v1Mull94f8TAgUPgb8So913cuVOHnj25+nr16j3Xp0yZMtQp+Hx9z57Vq2/efPdlhhOc0PgX57PgyvTpV3r9TYfGzYCoM8aNdAf9WjyePn26Y0dUVNTYsWN37do1FhQVle+4fGvEwCHUcDTlO/8KeuLq0+eHjm/ePG3atDGg4U6RBVzbvPn4rePmgeNGweMYNWFOa9eDqLYoI2MCGjhpxYrLuTt3DgaFkyI/7NyZe3nFismJqOHkkJGaUaP2mjPruo5EZfp8jWb+dv1ykV0D3GS/sjw1OdF2eJQ5I8OcuQEMHWqVXF6TsWjZAAKTC4ULYyIxeYBDwoCYGLmWEAslJiPyoMKECRMqbHCbqfcis6ZCuAi2YzGh8b3iQ2OEFCYQjE/Iz0+YaOHqAiR6nq3unDlzNtT99fhZFc9oNGdSucBlJSSERocmJGRhFBcdfy06+kX8LItFR6SlKM/Wq3f3bj2GC/RlZmvM200EbI2IwLRaLfwTkGDkxEhCqyUi5yoswTmicOTem7cHD3bwc4FtB8/XZOaJyL0YETlxXZackDtaJMsIuZbL5Yoh64kbM2fObERzqXnuBk12rIQKNyteKsvfHYPZe8TGQ9nrVYyFy1WoliUBuGaNG9hsxWHzg9Rg0jBaJoVDIkuIlFOGs6RUGb9Fwg0mTMZ7B9escXdsWVg+05ZGABfRyy5ZKIwVRpXvLAEUi/LCfnz72oLxC2wyuXz25OVCcAiVOsh40lIYLXMeX7AU96Pbki428KW5g5nbkkUYdJjuBKUR5H1eOktZFgmqEQSvTvMAs9EUePyCgFUeIJbuAucCKIlF8LDqZdzAlpO3obkiMttu5878LMw9uTTSCXo4NitEwZEEx8scG9MDBFCukzrKVQqLHSyo4Q42v4yiRpEYsi5cZSelEyEpsOn2UjZRwoUemQie5O0BFqNo4XJCR57xVTKpVBY1HiYlFAqwyHSy7DVLyyVBOoIYa7uDbcNRdFKaViEHcuGsa+nRWUKBIGDiuoUCbOH43emhEXIFCYqWIkhRK3fQl4nyDakqhQLiwQuJCTHqDMlCBeBLloJgLnlyUhBkqZc7yKpo5fNjJWKLOMAhyBwFvUVg9krHtZ9VXKmuTHOXdxwfzRPlwKo4Ry6AmDBfKYwoWiiX5+SIISj1duA8vArDA6w0GZo0EdSGYEqW8TLqiAZDSErBmGilEi+oTvMQOw/l99dLoBWnJFsSZLIoOC9O5ajSkhEkpZInyKjf32pNWa6S61yoRTd37haL006RQ4hiEZ6S7kPzlLfNysPVpn4qQqxTKChaAqKSK3RiQnvBpE/C8bCKLNrvWfk8HlKUmmbqJ1FpCYIQO0QQWpWknylt2UoezlMWQVJP+VWLi4OVHUvy6HqgRf2cEpnSUvXq4h2Lk5Swrvel/S4fZhwkWbKDp0TCjCl5K+lqZiyTqQ5fWmQswJW2i4uNCK6kc2h/iqMOU4JjGDwrxFM4NPFwcYESD/d3vYue38gptktwY96fgigPlUmxTYErSeX8mY+WXFQiOO5J4Qjc8BK9GptWqipXqpq60pgUxkOUv4KGFRgf6Rv4s8HuL2JV9qpdo2rFKrFMNSVmlYpVa/hzfBi0f1EZFsPXS6LT6VSVfBksu9O/geXYXk0vqFSqC95sr381K8OqXKfa1kFOnT69tYG3l28Zv7/6lqtVtmzZqssGTe3jUsimBQtOnWsP12tySmX9yn46yY/D6Rv7BDkUEhIUtHHBgnNGmzXQmutVGsj+nA0/vQxqCpy99nZQyNGjQE7dpEruzw9ErdVLs6xxkg9g3PmpJNe79+jZ8/qunwemIdoi8icdmutTSodL0UAAeedDKA7ID3379p0HFbbSSt3Sv2SwziQSDEze2ifo9ujRFHkEyDshfU4xDXzSks4oeTRkHr61+HSfoNn715Lovnl2y016GwUWljgen1wqqYG+CWazdvR+4A4c69t3/Z2QoI3nCvpTa7VKApvakyphNiAX9xHKqaqixFKzsipSA0gkWwRH6JDijhw5CmPF6HGBJJjMce3/CSmzD1u3LwZvAAAAAElFTkSuQmCC'
EMOJI_BASE64_ILL2 = b'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'
EMOJI_BASE64_ILL = b'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'
EMOJI_BASE64_JEDI = b'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'
EMOJI_BASE64_HAPPY_JOY = b'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'
EMOJI_BASE64_KEY = b'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'
EMOJI_BASE64_LAPTOP = b'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'
EMOJI_BASE64_HAPPY_LAUGH = b'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'
EMOJI_BASE64_HAPPY_HEARTS = b'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'
EMOJI_BASE64_MASK = b'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'
EMOJI_BASE64_NOTUNDERSTANDING = b'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'
EMOJI_BASE64_NO_HEAR = b'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'
EMOJI_BASE64_NO_SEE = b'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'
EMOJI_BASE64_NO_SPEAK = b'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'
EMOJI_BASE64_OK = b'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'
EMOJI_BASE64_FACEPALM = b'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'
EMOJI_BASE64_PARTY = b'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'
EMOJI_BASE64_PONDER = b'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'
EMOJI_BASE64_PRAY = b'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'
EMOJI_BASE64_QUESTION = b'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'
EMOJI_BASE64_RAINEDON = b'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'
EMOJI_BASE64_READING = b'iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAC91BMVEUAAABSHQgLAABmZ2dmZmaCSAArBgASAwBtNQAzBwDIvL8MAQBiKwA/DAApAwBQMiVNHAg8EgE4DAAcBQATAgDIvL8TAQB2QABnLQBNGAU2CgAlAgAOAgA5SktKGQdWIAwjAAAvCgDIvL/Kvr9lKwBnaGg9HhFbJgCeaFFzSzo8PDyibFUAw/+gaVJ1TTw8Pj+ia1RxSjn/vgA9Mi49Lik8Ojk3IBxmZmZUJhSWYk06P0H/xgFmOyp+SDI+NzWDTTYAzP/y9faQXUhgLBdkYmGIUjw5JyM/KiJpMx5hMR5oaWqbZE06NTR6QizTngBHEgD////4+frv8fJrQjE5JB9nMRxSIxFQGgFvx5avwFBoPi1kNiRdKxg6DgfMmADo5uXW09L/6aT/6pyVXkeEWEWGVUF8UUBsOCPAhQMAyf8Bv/bs7u/o6utAw8jHvbpmx6D/6o+nko2TeXBqbG1iXly6v0WIWUVHREOCVUKOVj+GTzn/zzM/NTI2Ly4+Ixs4GhPsoADnnQCZXgBgKQBMFgCn6vfBtLC5q6ali4L/5n2eg3v92F5bVVJPUVKAW01PR0NxTD85PDw4KylFLCJXLh9MKBs8GQ7/wQL3rQCRWABYIgDe3NsLpNDKxcNKxrkRjLGxn5tjZWZTQjvHwDpCOTV0RjNiOSxzPihFIRRnMAH/swDxpgDZmgDOmgDJjwCNUwBm3v0Sw+wHrd4gw9wvws8TmsP36a0efZq1nJKJb2ZbXV6FZVulb1gsTVb/21B3VkrtwkdtQjBTOS9YKxm6hBascALcpQC0fACeaQB3PgCa6/8RxfUWvePRzcvOycfTyMRVxq5exqcqdYb/424uW2qTc2kwV2OowFd8Xlb/10FZRUDFvjXSvy3vuSbdvyHYoB61mhr/zhnlrBiHVxB2TA9CHA7/wQ3QnABxOgAA0v/g4eKL4d3k4aYTc4/k5I0qZnkcYXbOzmw0ZWlCaGZqTUFEPjxfPTavqC9qQS/AnxaDYRJeJxHsuw+sch0BAAAAKHRSTlMAzzTz4P1JEvF6OwnWpmHrwrSWOy4qJvzn3YdUIf7u3pdsGgnz6NDM8Ya7kQAABa5JREFUSMdiGOpAWUlUlAsMREWVlInUJMKnIMAjwcG6fmZT08z1rBwSPAIKfEzcBHSJcaqzZtw/0L2v2hoOjGasyVjPIyWCR5uMEMeRA5cLCrqrnxkhgekg3RnivDi1AsQncaS7IKmzejpUA6rm6cdVOLHrk3pyIGnbm4+Lb98uLS2NBILr10EkkLN48eI7d+7de/CEF5tXOT+/bm3dcDpLBzs4vXHj5s2XhDD1scluOHVqgw5ekOnwiQ9dH7dabmtra+6W3Nx58y5czM/Pj4ACIPPihXnzcnO3bNl8ZuMZfnY0jdKP323b1v3M2mjVqhkzVq9uaGhoBAMgY/XqGTNWrTKytv7z88H3X+gBJHi/IKng4RrWlc3Ns2aFh4e3tPiDQUtLS3j4rFnNzStZ100/Frcmg5EbNQYB4qhOTLyc4R9rFhLi5mYCAsZgAGa6ubmFmE2LPXosLs5PXBjVpU3diUl3w+u19LECn0mTfLTq/DOex/mdQHWr0LrOxM6jsXb6WliBqZuZ2SStWFa/uOfHBVE0CjwqSNz3oh6qDxP4mJmZ+dTNWrd27ToeZE+y89xNSnoU7oZToxbISmP/435xaznE0MKmMyO2BrfGWjOzEJ/YmX5oocPEWp14synWVEsLr1unvQBqXM+GpBEg4Zk3kx6ehHrRtMbUzg45ZGrs7OxMQ8zMauua1/r5NfEhJ9SmfZ1rWuqtQDrt9s6fs/WKHUKf1fY5cy6Bw9UkfOaJYycUkTUePfK4+Ubw0xAffVPZTQ6ZDlkInabzHTIzHbYDbayfdnj34ZMrkTSy855cWdiVMLt995T6kO0vM3V0HLbCNNpdA+ULh6za2KcTCs/GdyyYwMspDLewr3BnfECAY86rc4Wapm83OTg4bNKChlTNe5AD5u/9VpQ3OycoMCCgo6tDEJqj2KU7AgICgrKDHAMdc2a3Xb21d34Wko1Zcz6U9+1IAOoKdMwGaY0XZAdnLl55yeiiHXkJ8UEgcaDehB195bVuE0Ehpa9fG2L6pSsvHqILaO759q79cvKSoFQAqKZ+XpsGwziA1ynzOBER9OBNSHx584MmpgmpYWlrmmTBg2xCO3BQzQ7CYO3oL+aOnci6H2zdrbCVteu/sDkYq2f1JIj/hyB48XmTtknLUNnN5xLI+3zyfEnyvtd0OeUsJswMvZlfXq99ejk9/ebLu+3u47es+HS/87VGbiwsrR+8/+BeZBOzx5pOzU4QKCMOIYRzKY14Vd0+Wa41P9fynf3G5kGzuXSQP8+oRMSrug2t0O7DHKZIYYygqFxFc9IJs3O+tLDeXMh3PJHqC7+TGoVQgee0Z+b2yTf1xSzli6AngPYZSUqNFEqZtubEc/FFNHIfcwjqDODNu/ccx4mnctw49DrGIEdVNNL9azJya6rX+n4kCA1nDCaIQKMQV+Z3BaHV6vWmIg8tq1CoK4piVMMtXCrBXQLNGeg8LRSs65EbUnKlFIX6B4jxHul8spE89OEWOQa7ce4ymA5D+6MBx+ZRH0rWocIqipgdgdq8D80Q5Cq7kHSnXrCk4cToqjE6se1DLWbj0ESI6k0MoGB0q+FQsprow2L4C8+v+VGT/agsbIOZcFRcHkJGxuGoLAtRJcmDUl0URVY4RoHT6cwgKl0eQpxr7DwSxVLSg5BUEAxjzbSDBpsZwGqM4fVgpNZdMwxhdWOFTLRO4ZRQjAoaOsrlmQDSobDIhF6x5L1VS6rvsGx0z8ZDV+bpAdQA8oFEcQNeh3IKf87U1g8hutvYa+sU9kt2eRpgjMLQ2AYIMlhUG/C3RkutyOTtB+lspg3Pdcu6LMt6meFpgD/nyBjuAiBI3vXWii7N0BeqmY3dJ/uxyMAiWeVp8MAIfD5X5MjnBEiqv+Y9k2GK6TsEvqbHyoeMzFFlD44X/yo98QfIM0WXuRKEuhqEy/8A6b/B32ySyKPhVcoyAAAAAElFTkSuQmCC'
EMOJI_BASE64_NEWS = b'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'
EMOJI_BASE64_HAPPY_RELIEF = b'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'
EMOJI_BASE64_SALUTE = b'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'
EMOJI_BASE64_SANTA = b'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'
EMOJI_BASE64_SCREAM = b'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'
EMOJI_BASE64_SEARCH = b'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'
EMOJI_BASE64_SKEPTIC = b'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'
EMOJI_BASE64_SLEEPING = b'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'
EMOJI_BASE64_SAD = b'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'
EMOJI_BASE64_HAPPY_CONTENT = b'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'
EMOJI_BASE64_SMIRKING = b'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'
EMOJI_BASE64_HAPPY_STARE = b'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'
EMOJI_BASE64_TEAR = b'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'
EMOJI_BASE64_THINK = b'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'
EMOJI_BASE64_HAPPY_THUMBS_UP = b'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'
EMOJI_BASE64_UPSIDE_DOWN = b'iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAC8VBMVEUAAABZJQBGFABFEwBFEwBGFABFEwBFEwBFEwBFEwBFEwBFEwBUIQBGFABFEwBGFABFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBHFQBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwBFEwA8PDzMmAD/vgBFEwA3IR4Aw/9mZmb80y3/5ZkAgrVSRwdGRkY6MjEPw/A+MCtDHQ+Z5/88Ojk7NTRAKiLFiAC5fgA8ODc5LSw4JSLvvhD/wAW4hACucwCDUABRHwBkwZs9NjM+NDE4KCY4JyQ3Ih5DGwxEGAiJawSadgL+vQD3twDLlwASmcNPwbAffZlkYWGgwF//01H/zj/gvzhBJRpCHhHztADJlADQkwC1gQCzfgCvewCzdwCndACpbwCdZgCZYACLUwCHUwCCSwB8RgB1QABgLQBKFwBL1f8EwfkDvPQFuPAIsOMfwuAJq90vwtAQn8s8wsPX5sJCwr0DgbMYjrIXjLAdepj/4o97wYQqY3X/23KPwHAsV2b/12P/1l1TU1OvwFD/0Uo4RkpJSEhGRkU6QUO/v0A7PkDPsj7/zDXPvzBTNyz/yChGMCg/LSffvyD6vgVKKQOuhAKgdwL5uQDxtADssADoqQDfpADdnwDVnwDTnQDanADQmwDVlwDLjwC7iwC6hgDBhQCrdwCfagCTXwCSXAB+TABmMwBOHgBIGQArzf+h5/ccw+yu5+oHtOoSv+gHs+e45uANptUruskUlr643bssrLr/7bgWkrjm5bIJgK4Sfacae6FBn5kkeJk2c4t9wYL/3n5MbXosX2//2m6RwG4uXGthZ2r30WhrbWZucGR6dV5eXl7ov1uNgleYilNfVFCkk09LS0u3oUctPkaZo0BZRT7VtjxGPTr/yzVSMyimkyJKLSLFpyH/xh/svhNOIxBJHgpXSgd4YAWCZwSTcgOxhgLBkAHAjQDChgDAhACkcACibgChZwCLWQCPVwB2RABP9lOpAAAAKHRSTlMA/vy+kPm0gHAjEgz+9eu7qKKHaWJFKhsH79zVxq2ahHdQP+NcNjAZ5x7anwAABF1JREFUSMeV1mV02lAUwPFQOuvc3S15lwAFxkZb2rUbbOvWbW3n7u7u7u7u7u7u7u7u7vZp9wVGQkig+3+o5PA7973kHYBRLGuK5LnTAi1truSZsjJJKXtegI0rE0gM+VfC8lYAyVP5Z8HQIv7pWaOxNpHXDDKqswKwto7RaBwaQ5RaBcEqLm3rMUY6TK2lv4IUHbw82qfPwXLV+/bu2b0ExtPoH9179u5bvdzgYbUePgcFF7SjVKlS23j/dfaV+U6i68QH6pBWDqHT9p176XpGT5w663V09GzianZ0dPSsqRNH17p4plz1/bv5OPnACLwvdQitwaIljSK+2u1laXb72ohGyxc1IEIcxzVOLxsYg5DYwV8tKOTAy6XuUBufXyuIi2TViiwJbSls73WG8q/CgTFQT01V1Omi2HBYhnBNBilMRhC2BFY1nU5XmoV2PmsFhHWgsjoMQ2mrD4qQgJUVq9GZFzowwTOyYnkBdpTCza+Mg1aCyPoj2VNtwJF9+Lura5coWWiJ8E+I6LK3nmKc3laEXauNlczmJ9G1CrADwg2FRJi1xRgjEbc4hPVuuHutlpKAsHlmERaxjxxEVB+GuMlwCpukEGHKiBHTCcz0D7EKFJYJlsILhED5gNAmh1m+jUAYGRCyApQstWCzmKTDpilFmK0VoUu1ue4pPruxUtKL5/tL4PqCIszRjkJraRY7z9MkrguP9RCgcHTaZGPE0lBYL5bFeKFqHjeBFxKOufA4NjOSgMLKltIeuMsDL/FCFoRRwgEAOcQjpwsTVobVYD25oM515OQwHcIlCFFOku+xF48NdMEfcpi/EUoIj6IbiRrQbaDNjWyRYZao4d16PKAu1groVmeQwtTtETpxpL9YoNBRjJFvcjHYwvw4CwvfZSvFcsYTbiHgObdUUlSVLKwVB/rCQq0JXtQAVLayrCUWtWhiLSxrjQNwUrcxC+MdkBV4ueocoNUPr8D+q0J4faDNqcLJBwplabcAL1cxVeHKtEkD3jkdjbmqpvfUtcnEyEsXgdc/muZx7hquabKuSZmGnLu5pg/4s3Eyxrdk6znuM05UDCd+wrcb5Y9krTORM5lU4DsTl6jJzSgXkmzLPNNcRbfaVFUDfr6y5MgIWzc1TZSzpo6tkDcHE6BUBfIEgbSgPCmyMUkvpZU+xGDm/8qcXFs4riSWTqsNDkmqygTwqKbendk87gVoiwcgOSGNxgnP9NJGmc3m8dBRowHIruYyXjk8Bc866L2qaTbPaMjR7x2gBjuOJBj3Ri/r3pPm8wnWrKjKHblJBDhNj90yGO7rT4SG9hM26lhAaEHKEAgtft0dfOldAzb5eKhLjtuymNDaK7rUvwlt4SZ85XVkVB5DeRpvEHCENj+DEkxPhFYAwscGw209Sn0optffeIuQBuorJRyFdQ2uzqE7hf/P+JJAaD9DFFbaktASEqeJ8KowEBvvWEqE0vvCXPGEtmxDTQ+8Rt1lCs0gX+tfrOPgM1dv1nEAAAAASUVORK5CYII='
EMOJI_BASE64_WARNING2 = b'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'
EMOJI_BASE64_WARNING = b'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'

EMOJI_BASE64_WAVE = b'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'
EMOJI_BASE64_WEARY = b'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'
EMOJI_BASE64_HAPPY_WINK = b'iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAC+lBMVEUAAAARAQAhGBdHFgI0CgAsBgAZAgBRHABEFQJrRkAqBQAnBQAWDg5wOwBgKwCGTgBZIwBTHgAlBQAeAwBHIhRKGwlbJwAtBgAmBADLv79xNgB/RABhLABeJgAyCwBrRkAtCABoRT9NPj8VAwBpMABKHQw3EAAuCQAiAgBsRj6YWwBHLRs+DQA+CABrRj9rRkBHPD9JPUDMwL88PDw3IB3/vgAAw//SngA8Ojk8PT4+NjPMmAD/xQA9ODY7EgrOmQBnZ2c+NDHQmwA3IyD/wAA5MC87DQQAzv86HBc+DwPUnwD//2U8MC3KlgAAZpphXVs4RUk6Nzc6MzI9KiY8IBv/xwCdaQAHtehoamtfX2U4LCs3JiM8GRJFEQAAx///6qBpZmU9LyvoqACyfQADvfQPoMxXwag3KCe+ggHwtADCjAC+iQDEggCOVwAzTlc2Sk9ISEk5QURNQwe2gQOrdwL6uwDDkADHhwC0eABmLgAJruALqtsUlb3/43JjZGcxVF//1kjIx0D/wgDZogCmcQCBTQB6RABSHQBMGACU7P8RmsQYjK4LZZT/6Y4kcYn/3GI7JiL/yxpWLAyibQH3tADVmADHkwC6fAC2bgCuZwCaYgCoYQB2PwBYIwAVkLUZhqdfwaEffJn/6JiAwX81Zn7/5n0ransnXnDFxWayyFZWVFa/yEnMxztOPjtBMi+TcAOpawCARwAA0f8Ay/9Mv6/66qcAZZxnwZgfdpBxwY4XZo1xvYgjZoeLxHhbZmyVwWouW2j1yUtYSEbNxzv/0TXWnhtkOg5FGgdeTQXZmwSwcgR/ZQS1iQHrsADbkQDJjQDPhgC/dwCUXwAZy/8BwfuI5fLB6d/Z6cYAW5tPpY8mbIKKqHWzvWqgyGj392bh4maBgWZycWWoyGArQk1SWz/tvTVUNCdJKh71uxlpVwahfAJhQAL/yQDMjQCjZgABxPtVw9Y7pb+n17Oc0qodgqEdYIk/goiUlGaGpVSwo1T7vAZ1YQVFJwJ3SgGAhbK4AAAAM3RSTlMAJQfBkocw0bOIVkoO/v796N1COf3Nza1dGffx7dqlgGZPOB3v17d5bmP96JuBd24nHg24W13lAAAGZ0lEQVRIx9WWd1gSYRzHc5tmpmV7772AjjvuOA8FEcFUBARFc6Xmnjly5EqzUjNLzXZpaq723nvvvffeezxP70kaKFj92ed5fATu+fh93+/787g2/zftxvbvN2x0n7aAPmOG9es/7q8kcz2dXt3PRvkHTW0gaEGd6cDOvbtqta5p6fUqOfAgNzF3f74I/U10mn8PQyNtzWl6AyP3rPKYnZtPU8UaFVkfCdYx1+DpGxzdM9tj1X5rmjpQ66Duo9R6HUd82XDp0rsVK7Zt2bR06dLJkyevXz+ZZOmmTVu2rNixa9fn+yPVbW/E6+zsC+cmtIK7TZmaTMM32dnZwGvVXBfasblnfP/CxYtvt+3YdeNuRUVV1fTp09es2bcP/IBXVVUVFXdv7Fix7cr6KzotAg/MXj4739rr5MnTQWfOFBUVFy8kKS4uLioqOhN0+vTJeaJ5hYWFJs0itbqneHjketVncUiYLeBwbBfFRjMYvAJdVXFoXaKHx4M4jpAgEIRAMDqAQqHQSTCE4PMJgmsblSZgTTFQnYMuR8AJFnAIGMYQ2MGBgmAwhQSmI1h4aHge14oNcxfNxxlQd31lT9vs8XKPPXFcmIIk58T7SOJzkkEgGemw2VfiI/Etp3JlhG0BxICCuyqLYwfu91h+QO4JY5vdfRJmTpvm+14hYrt9yXeSdTNlXEdmJo8Bpespi/3rUzYkHuVgWFn8VQcMbBPBKAro4HVNDZy8eDGV7QzWCkV2URb7DU/ZkFLPhOnJDgQdVKKQGlWHUITIu+fn5yn3hliBFsrimLrc5Y/jnGEKRgd1hIdjCL3Jg5dIJIsdhFyqK2ErhvAYg/FKYp/YxESvGUKySSw0JyHed0448ktElti4u9vMZFOpVCemKYQLzLopiW39V6UUyvkw6SWstQHEl2O/apW4gyk9H8IFolsphOMdVMSgxPwXHAKI9Jlr46ctmzMnZ1lLkc2NaymmoP4cBAb1S+aEE4hSrchimwkTbHzpVkB0bo83E/ssyEcXcDAYBIQSyp2SkdN8fHxDEIUowBkq4uijqCJRcRSqJj0kGbStEBksgZlyq8NeougpDp8OTDVgGAV2pCr2yIoxUBmAYBQtlHuyKU00HiSm+A07UclWTcAA6KiMXCaaCs7Rz/FXJD2UrAjDECK5rMGEFeeYAUHeKiM3rifNOjrOWeZKgRUinCBZtjskpHyJz1XFJLhSqVbk5EAFKkOubXAiFTVlOlFlFLgBpMxmnbuPj/vaBJj8pCEQzGokBAUbNftHRsF5EK5UV5mTI4COLHtlA0gI4Ts5sWUgD6yUPA3IRF/11hErApvMY1NJrEic723OWVIu41IbscKYGTx8fq92qrfxDJQmMmXS/ahNcN0A1N+eo1DurdoNSbteAdEnTsm5hBNYVkus/NiYkGPCYvCC+7ZRRTeIJoDEM+RuQj7Blvm5ulpZKRbt6idjs/lC50NZmTEsXNBzQDNRv5TGE0Axzw5l2TLdnPOEnp58Ek9PYZ6zG9M2a8b3Wh5LwEvv3aY5IxecEOD4k4ioqODS9ouy5LYK5Fkz2puYigOPRTyFGKz5cfotxAFmp9JwxpPDMTyIh8dEekcViEvE4nTvyEABxIPSaoHIwjOHqvteNUuH0o5FHGcxGDjOgppg4QwGAwIX0qaU6ql/ADCsDzweUctjtASff/ibQNwBNKqerhaZz8i1kjksFg6CAeANj1cb8aOnLihUE9rmugY9M0rInQVOaSDQ3ztKHGxiZtgXaK2jZd5Xr/dgHYNFcwEddAb31h1ipA/m7G/RdwOzzh/8b49k5ro6FoMOdSKxsNDRM9f+o6JlbNTVSHfQw70TG6kMC6t+NEgXfGyspdkz7hHrHysurXZxcbFsZGJYWFhNphhc6GGssdPO856LUgPSq4E2adJOy0lJUqnUMqkyTBgVkCp6HtBZW1NgnYgG7j3Be12At3LW9qQ711ffloLQmrPR4DlN9FJTpKFXKhADMiqBuNLefuOH1XZ2Nz9JLV2qMwKAiHoZamjGFKUB0evgROBttAfmx1vAvC11CTvoBUQa2kN9P0NeNIiCg0mTdm5daT/L3v7yNTs7u9VSy8q5rAZx6hAN1ZBXo70fulgmbd+6lRSvK0Tpo8iv5N+cp7aejiUi8mLAWbKbnduBN4sMvHUnyVLqWQI2CeoZ/vuB7CfCiKdk5pqUMAAAAABJRU5ErkJggg=='
EMOJI_BASE64_WIZARD = b'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'
EMOJI_BASE64_ZIPPED_SHUT = b'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'
EMOJI_BASE64_MIKE = b'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'
EMOJI_BASE64_SUPERHERO = b'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'
EMOJI_BASE64_HEAD_EXPLODE = b'iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAYAAACohjseAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMDEyRDc5MzQwQzExRUQ4QjhGREE4RURBODNBOEY0IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjlCMDEyRDdBMzQwQzExRUQ4QjhGREE4RURBODNBOEY0Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OUIwMTJENzczNDBDMTFFRDhCOEZEQThFREE4M0E4RjQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OUIwMTJENzgzNDBDMTFFRDhCOEZEQThFREE4M0E4RjQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7feGyYAAAQ70lEQVR42sxa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'

EMOJI_BASE64_HAPPY_LIST = [EMOJI_BASE64_HAPPY_STARE, EMOJI_BASE64_BLANK_STARE, EMOJI_BASE64_HAPPY_LAUGH, EMOJI_BASE64_HAPPY_JOY, EMOJI_BASE64_HAPPY_IDEA, EMOJI_BASE64_HAPPY_GASP,
                           EMOJI_BASE64_HAPPY_RELIEF, EMOJI_BASE64_HAPPY_WINK, EMOJI_BASE64_HAPPY_THUMBS_UP, EMOJI_BASE64_HAPPY_HEARTS, EMOJI_BASE64_HAPPY_CONTENT,
                           EMOJI_BASE64_HAPPY_BIG_SMILE, EMOJI_BASE64_PRAY, EMOJI_BASE64_GUESS, EMOJI_BASE64_FINGERS_CROSSED, EMOJI_BASE64_CLAP, EMOJI_BASE64_COOL,
                           EMOJI_BASE64_UPSIDE_DOWN, EMOJI_BASE64_OK, EMOJI_BASE64_COOL, EMOJI_BASE64_GLASSES, EMOJI_BASE64_HEAD_EXPLODE, EMOJI_BASE64_GLASSES, EMOJI_BASE64_LAPTOP,
                           EMOJI_BASE64_PARTY, EMOJI_BASE64_READING, EMOJI_BASE64_SANTA, EMOJI_BASE64_SEARCH, EMOJI_BASE64_WAVE, EMOJI_BASE64_KEY, EMOJI_BASE64_SALUTE,
                           EMOJI_BASE64_HONEST, EMOJI_BASE64_WIZARD, EMOJI_BASE64_JEDI, EMOJI_BASE64_GOLD_STAR, EMOJI_BASE64_SMIRKING]

EMOJI_BASE64_SAD_LIST = [EMOJI_BASE64_YIKES, EMOJI_BASE64_WEARY, EMOJI_BASE64_DREAMING, EMOJI_BASE64_SLEEPING, EMOJI_BASE64_THINK, EMOJI_BASE64_SKEPTIC, EMOJI_BASE64_SKEPTICAL,
                         EMOJI_BASE64_FACEPALM, EMOJI_BASE64_FRUSTRATED, EMOJI_BASE64_PONDER, EMOJI_BASE64_NOTUNDERSTANDING, EMOJI_BASE64_QUESTION, EMOJI_BASE64_CRY,
                         EMOJI_BASE64_TEAR, EMOJI_BASE64_DEAD, EMOJI_BASE64_ZIPPED_SHUT, EMOJI_BASE64_NO_HEAR, EMOJI_BASE64_NO_SEE, EMOJI_BASE64_NO_SPEAK, EMOJI_BASE64_EYE_ROLL,
                         EMOJI_BASE64_CRAZY, EMOJI_BASE64_RAINEDON, EMOJI_BASE64_DEPRESSED, EMOJI_BASE64_ILL, EMOJI_BASE64_ILL2, EMOJI_BASE64_MASK, EMOJI_BASE64_WARNING,
                         EMOJI_BASE64_WARNING2, EMOJI_BASE64_SCREAM]
EMOJI_BASE64_LIST = EMOJI_BASE64_HAPPY_LIST + EMOJI_BASE64_SAD_LIST

EMOJI_BASE64_JASON = EMOJI_BASE64_WIZARD
EMOJI_BASE64_TANAY = EMOJI_BASE64_JEDI


def _random_error_emoji():
    c = random.choice(EMOJI_BASE64_SAD_LIST)
    return c


def _random_happy_emoji():
    c = random.choice(EMOJI_BASE64_HAPPY_LIST)
    return c


'''

M#"""""""'M                             .d8888P dP   dP
##  mmmm. `M                            88'     88   88
#'        .M .d8888b. .d8888b. .d8888b. 88baaa. 88aaa88
M#  MMMb.'YM 88'  `88 Y8ooooo. 88ooood8 88` `88      88
M#  MMMM'  M 88.  .88       88 88.  ... 8b. .d8      88
M#       .;M `88888P8 `88888P' `88888P' `Y888P'      dP
M#########M

M""M
M  M
M  M 88d8b.d8b. .d8888b. .d8888b. .d8888b. .d8888b.
M  M 88'`88'`88 88'  `88 88'  `88 88ooood8 Y8ooooo.
M  M 88  88  88 88.  .88 88.  .88 88.  ...       88
M  M dP  dP  dP `88888P8 `8888P88 `88888P' `88888P'
MMMM                          .88
                          d8888P

90 x 90 pixel images
These images are intentionally a little large so that you can use the image_subsample to reduce their size.
This offers more flexibility for use in a main window (larger) or perhaps a title bar (smaller)

'''
HEART_FLAT_BASE64 = b'iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAPjklEQVR4nO2ce3BdxX3Hv7/dPefch96WLMuYAOZRsKc8qmYMpImSJiSmQ2sgtVNKQ0uahnYmwDA4pEAmskjixAkd8qCh0E6ZaaaPWCU2DJ10kja2QhtosIBkYhuM8VN+yHrrXt3HObu/X/+4upbsWG/JstH9zOyM7tU5+/vt9/z2t3vO7rlAiRIlSpQoUaJEiRIlSpQoUaJEiRIlFggC0Hz7MAvMehtmrUIBiAA5+XnFWh9LEUfoXwFS74NSV0FcHEQJCBRA3RA+AfBBQF5C3h7EK60hAW6sOqdkv6nJoM8PULv4N2BxLRT9JgTVIFU+cpL0QcmbEHkdVl5DbzREu1rD6difiBkLXYzgokPSeEctYrjBafUZUuompVQAZwF2gIz2mQClAFKA0mDhvWDeqlj+DdnB3dT+YqZQf7MitPD4PowcIzf+QTko3gjj/RGTulUR1YPdKPtn8EFrMEtegf4LLM/CDr1EL285MbqNMxV8RkKPdkBuuG2x094noIO/1kYvlewQXJQTyaWBVA8w1A/YCHCuYNULAD8OxMuBilooP046SIKVBsRuYZv/dofpfuWStrbc6RdztP3i99J4SwKJxPsdeQ9rbZpgQ9gwCxkaEGT6gaEBIMoDLhqpxQ+AWBJIVoPKFkEHMaJYGSIbHVHiHtcq/+/UtqXj9LZOh2kLXYwiAcjesO6jbMyXfC94b5jqZaS7Bd2HFXo6iHjcYBypL1YuUrtMqGaZ+OU1Gp4PttGTYVa+GW///ju/1nNGfc6tuvUqz4+vV8r/lEQZRKlei57DCl0HFUX5SbYHQNUSkfqLGRWLVVBeQ1EU7hEbfsEPa7ZS+zPRZHrXWExL6JMiN60ty0byYNyLbbBRHlH3kYiO7jYq3UcnqyfCKYFQ/PMUywRIwX8hAtcvZ6pfbmM1S/1cmH+bOXwo+fIPtp4+0BIgQ6s+frv2vScC7b0n19MR4vh+o7oOqJGD1Jntn+LDsI/DqY3LagQNV1iqvcALggTCMPt4Pp/bVNH+Yvd0xZ6y0AIoAjj9/tsayKqNiVjZn2X6j1t07Fa665A6pXEylZ5WvCgoiB4k4JZeEXlLL/ciqBBReF/y51ueFqzVQCsTIKlVtz+ojPmaETa2Y3ekj+7xYKNC3pWp2sew/ZGLzrXLWJZd6RI1F3hDuaGtiuj+xP+2HipqMKWqp3JwMU/J7/xxddrm/qkslrwlc+JARId+5al03/Qb+GteKYgwCICru9hh+TUEE5B14ecrX9n6DQAYXHXrozEv+HI+n2G9/w1R3Ye1AKCChzO0P3zRmSHxcvBFV0eJ+ku8VJT5Scj6rtpXWo8IhAg0aUNTE7qpyRzAxaYqN/BMhZ/4ZPbEwUjtb/cozBWiWKaVvsZ2jQrRxdVL2F3629BeTEXi/gRATaDMt6Mw4/TbO0gNdCooBfDps4qZujB80Twf7pLrbHzJpWYwzD6fyyTvXFJ9aR5tLW6yA6Sa+JAC25qaDLW12apc/xfjxv9kpu+oo32veRTmIESzLDJQSD0MKAXVd1ypvTsoclbA+I4wNuVtyLR3h1IDnUqUApgxqyIDBZGJgCiE2veGyXQfdgntrwnimQ3U1mK3o1lPtqpJRbSsXavR2sr9713zu0J4wbM2ht0/VTqbguC0wW4uIAKJIFpymeDSRmIWqH2viuncT5iNVDGxAyAIXFAGrPwAh8aP2OlP1LU/9/y2pibzobY2O3ENEyCQQh++bHVZT7X3w8CL3chvvcK657DC2RD5JAQQYBsuY4iQObb3LIk8yj4ErvoC1lfeqPJRvj0nvHppe2MvsEEmytcTpo6dK9Z5BHBXhb6bQde7rkOg3g4SEASCYlac+yIQEeijbyt9bC8JAJGzbB8A9R+lqOugiKJrjeBuQgvvXLHOm0jHcYVuBtTKXa3RntWrAyb5w6TyFB95y0GEzq7I506BCMnRtyRGSgvJx/dfs6Zq5a7WSNA8rpbj/vP3Gxs1AVJ+TNY40Vfne4+A8mk1342d76JyaYq6O+CgroxJ+DECpL3xxXEHxnGFbswuJwBgoZsr/VgFnzjgyFma74bOdwE7ct2HXbkXq2QlqwEgNqzVWJix/tEMKNrVGr6zvLGSCctdbgiSSw0bO5uD4LlGYQYiuRQklwazurx/xUdrqna19o53ez5mRG9Yu5YAwEtUX2tJXZxPdQE2pMJsdWHmZxluOwOAy1OU6gIrujBF7moA2N60fUw9x4zo9n37FAAXCV8OoMEN9cEMp40SAJyjKDMIW7a4jsRdBADl6fSY6WPMK1DMORpSpZXyJMwLFnQkn1ogAs5nxNc6TqCG0ZqdiTEjuoiFqylTGs7lnUzi+AUEiQudp0jnSSomOnhM4fwwVZhxOEoaECJnCxdyQQ+ERYYHRGYhAZjFB0Y0OxMTRqgjx1YYABW6TUnnkwgIkTCcsJvo2DGFDv3ygpyMXOQcnFJUWP2cNT/PYwQCCCutLDtAkAVGaXYGxononQAAFvQNuQie9jQDMhzTJQA446msDZkc9wHArmHNzsSYQu8qVkauK3Rh3jNBwCChUkgXIBIxAVnmIUN8AgDW1tWN+VB+TKHrdhVOsk72Efg4x8ouYm1Eu2jBz6UJAGsjCBJg5zpz4vYDANoWTz11bEcbA0As436VS7gOCsouYq1FuagU0wAcGSBWAWF3pKHS/bLwbeuYET3mDUsLwDsaG70VR1/tcWyPiB8HK09mMsl/NxVrfDgdQJw9dEF7e2bzihX+eOuH407vYtksAYCQ7Bm0FrFYuVG5lNC7YyPjtGGQhLFyPeRCQOTNyZwz7mPSlbtWOgDgED/KR/kOLqsDa2/4xmVhFgBw2giX18Ha6ECE8McAgGGtpiU00MrbmprM9Yd//hIxvymxcljtL/j0Yb0YOCiDYrf7ffvfeHVHY6O3Dq3TF5oAKT6Rssz/PeBCzpUt0g60YMV2IMknF6lBmw8t2x+Op9+khQaAxvZbnAAkRv0Azh0Iy+oQah+Cwp6ohVQEgDW+hGV1EGf3O6u3CkCN7e0T3oJPKDShhdsbG80H9r+6hyFbc0q5TOViKhpeSMUBSFc2qCESFpLvNx3dcbi9sdFMZh/e5DbQAITmZvrJ0y9cCE9eCkgtqzq6E8bmF9TsIzIxGVi6EiG7/fEwuPH6E6u7gBaZzLawSW0JI0C2b9+uPnz89YMQ/IsFKFXZcDJ9zHekzXUppo50VQMiERLQszec+L/O7U3b1WT33k0lImkzoMqWXFtjNG9TpFZU9RxEMttHPMWKzicEhbYNJRfJQM2FxMyvDRn68K0HfzFII9diQia9yRGA7ATk946/0UUO6y2zDFQu4UibeY+4uSwAEGkfg+X1bB1bcfqB2w7+ov+0QyZkKkKjBeBmQN10/Jf/yeB/hPZ1T0WDFLoXzfusYLaLA4GJ0FPZIKQ9zXDf/djx13/aXNiIPmmRgWn2+GZANTZcUaPZ/5FSdF0ifUKqU53vsqd6heWqvoolkilbTMzuZT+fvfkjfftSU93tX6htBvx46VXX5RxtU5Cy6sFjqjzbTxYEBZna5T6HKKzUFdowmKiW/vKlAkGvi/iDa/p2j/1kfwKmlDpG0wyom47ufh3CdzNI9yTreDAoF4LAnqdpRADY4UgeDCqkL1nLThih4rvW9O3eKTMIzFl5z3BL3RUPBcpsslHO1qaOmViUxfm4Wi4gaAgyfhI95fVWm5gJObrvtq63v1Ns63TrnnZEAyPv/L3RtefxvA2/bEzM9CbrXGh8AOfbZptCJGdNgJ5kndM6ZiIXfeHWrrefHN3WGWg1YwiAbAa0WXTZY74yj7go66qHOnU8yp0nkT0sshdHb3KxMyau8xI9dnvPOxtoZCo9o0bMKKKHEQFoHeC6/MqvZFz0d2IC3Z2olyETk/MhsgmCIZOQrkS9wAQqI+ETHdW0cfjFjVmJlFn/dYPmFSv8K4/mNgZK3e/Y6pr0CZTbDE15PnSWIAApL8l9ycVKKW0j4a8/95F9X2xthZtpXj7dzqwx2rF/rrrkkRipZifsV2S7uSKfUudiEhkMKnkgsUhpIJ8HN9/Zd2ATUHjzZ7ZEBmYndZyk2NWaAXVn//6NGRs+zCKD/Yla1RtUsqPCPc18P4gCAEtK+mJVrj++SInY/qzjz93Zd2BTM6BmW+RhbeYEagZ0C2C/V3HRHQT5ulFmWSzfbyvygzrGltwcGh/XMQB5ZWQgVsV5v0LnOTpIRA/eNXDouacB7x7AYg463py29Vu4LLgfe/PPVl7wQe1oo6e9G8hmpTrXK0kXqtERNtcMv06PlI5xf7yaoGMUsW2zoEc+lTr0s6Kvc2l/TtkM+OuA8OnY8vcEOnxUSP2FgaOK/ICtiDJGg6f+4GBKFG6nHRQGvIRNBVXGglhgn4rY+8o9mUPHij7OrRdngW2A+VChS+Ifkg33KqgNvjI1XpiKqqNBU0wls+lQsacYABntSb+psJFf5kXiOhm25c/Tx5863be55KylyebhgbcF4L9PNtxETA8EWt/sbI6rbRoVNnsylczUqWIdBGDAJLjfS0LrmArZviDE3/z0UOe20f7M0NykOKvjkQDUCqh1gHs2UbckL+azQnjUCJB0GbsoShtPHGYyUAoADSAijR5TZoe8hLEQ1iJfzmp68v708a7NgF43Mvk5K8zLClQzYFqGu+tTsfp1EDzuK32h4ly+1qaCpIsw4fr9GCgAaR1Ir0mGomJBTtw7RPK5v8qe2HK67bPJvC31NQOq2G2f8epXWiWPBaRuD8W6apuhGpdRhMn36+IvJ3WbJA/oBHzSKmL5V4J67J7w2Jun2zzbzPeaatG+fAs1FX5g7ghFNgWgSsWhW8xpnWA7oTIKQE4ZdKoyy8o3eeCIEnwekTz/WXSlZdSvNc1hW8ZlvoUGcOqt+9/6NVdFov/GA252YKnlDFW77BnPK66G9Og4elVcNBRF4P8QwoMPhD1vnV73fHJOCA2cKsi9QHCpqXlIgIcVVDwpedS7NAxGlsgIQASFTp1ElgJY8BCBvtRve55oGZkTnzOPV84Zoc/EE6ZmlUCeNsA1WhwWc0YSUnhNOkNGulSSLClYwg6B/sv1UXf7fPs8Fues0MVQ/EY9ktRT/V2I3KEBr4YzIiD0qTgxEArhe7Sk/94HO5A9Z8L3DMzq07vZpChYuhPZ9bbvT6249aFIZy8lqI/iFAofc2LvW2/7Pz3Ygfzoc0pMk88AHgBsRPmqr1LFz75K5f+zCYnfAgrz4vn17l3G5sIN34Tfnaucszn6TDQDaiVAO4df9Zuvm4+FQvF5UYkSJUqUKFGiRIkSJd7l/D/zcbmEg5v3VgAAAABJRU5ErkJggg=='
HEART_3D_BASE64 = b'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'
PYTHON_COLORED_HEARTS_BASE64 = b'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'
RED_X_BASE64 = b'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'
GREEN_CHECK_BASE64 = b'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'


####################################################################################################

def _main_entry_point():
    # Relaunch using the same Python interpreter that was used to run this function
    interpreter = sys.executable
    if 'pythonw' in interpreter:
        interpreter = interpreter.replace('pythonw', 'python')
    execute_py_file(__file__, interpreter_command=interpreter)


####################################################################################################

# M""""""'YMM          dP
# M  mmmm. `M          88
# M  MMMMM  M .d8888b. 88d888b. dP    dP .d8888b.
# M  MMMMM  M 88ooood8 88'  `88 88    88 88'  `88
# M  MMMM' .M 88.  ... 88.  .88 88.  .88 88.  .88
# M       .MM `88888P' 88Y8888' `88888P' `8888P88
# MMMMMMMMMMM                                 .88
#                                         d8888P
# M""""""'YMM            dP
# M  mmmm. `M            88
# M  MMMMM  M .d8888b. d8888P .d8888b.
# M  MMMMM  M 88'  `88   88   88'  `88
# M  MMMM' .M 88.  .88   88   88.  .88
# M       .MM `88888P8   dP   `88888P8
# MMMMMMMMMMM

def main_get_debug_data(suppress_popup=False):
    """Collect up and display the data needed to file issues

    This function will place the information on the clipboard.

    You **MUST** paste the information from the clipboard prior to existing your application (except on Windows).

    :param suppress_popup: If True no popup window will be shown. The string will be only returned, not displayed
    :type suppress_popup:  (bool)
    :returns:              String containing the information to place into the GitHub Issue
    :rtype:                (str)
    """
    message = get_versions()
    clipboard_set(message)

    if not suppress_popup:
        popup_scrolled('*** Version information copied to your clipboard. Paste into your GitHub Issue. ***\n',
                       message, title='Select and copy this info to your GitHub Issue', keep_on_top=True, size=(100, 10))

    return message


# ..######...##........#######..########.....###....##.........
# .##....##..##.......##.....##.##.....##...##.##...##.........
# .##........##.......##.....##.##.....##..##...##..##.........
# .##...####.##.......##.....##.########..##.....##.##.........
# .##....##..##.......##.....##.##.....##.#########.##.........
# .##....##..##.......##.....##.##.....##.##.....##.##.........
# ..######...########..#######..########..##.....##.########...
# ..######..########.########.########.########.####.##....##..######....######.
# .##....##.##..........##.......##.......##.....##..###...##.##....##..##....##
# .##.......##..........##.......##.......##.....##..####..##.##........##......
# ..######..######......##.......##.......##.....##..##.##.##.##...####..######.
# .......##.##..........##.......##.......##.....##..##..####.##....##........##
# .##....##.##..........##.......##.......##.....##..##...###.##....##..##....##
# ..######..########....##.......##.......##....####.##....##..######....######.

def _global_settings_get_ttk_scrollbar_info():
    """This function reads the ttk scrollbar settings from the framework settings file

    Each scrollbar setting is stored with a key that's a TUPLE, not a normal string key.
    The settings are for pieces of the scrollbar and their associated piece of the theme.

    The whole ttk scrollbar feature is based on mapping parts of the scrollbar to parts of the theme.
    That is what the `ttk_part_mapping_dict` does, maps between the two lists of items.
    For example, the scrollbar arrow color may map to the theme input text color.

    """
    global ttk_part_mapping_dict, DEFAULT_TTK_THEME
    for ttk_part in TTK_SCROLLBAR_PART_LIST:
        value = freesimplegui_user_settings.get(json.dumps(('-ttk scroll-', ttk_part)), ttk_part_mapping_dict[ttk_part])
        ttk_part_mapping_dict[ttk_part] = value

    DEFAULT_TTK_THEME = freesimplegui_user_settings.get('-ttk theme-', DEFAULT_TTK_THEME)


def main_global_get_screen_snapshot_symcode():
    freesimplegui_user_settings = UserSettings(filename=DEFAULT_USER_SETTINGS_FREESIMPLEGUI_FILENAME, path=DEFAULT_USER_SETTINGS_FREESIMPLEGUI_PATH)

    settings = freesimplegui_user_settings.read()

    screenshot_keysym = ''
    for i in range(4):
        keysym = settings.get(json.dumps(('-snapshot keysym-', i)), '')
        if keysym:
            screenshot_keysym += "<{}>".format(keysym)

    screenshot_keysym_manual = settings.get('-snapshot keysym manual-', '')

    # print('BINDING INFO!', screenshot_keysym, screenshot_keysym_manual)
    if screenshot_keysym_manual:
        return screenshot_keysym_manual
    elif screenshot_keysym:
        return screenshot_keysym
    return ''


def main_global_freesimplegui_settings_erase():
    """ *** WARNING ***
    Deletes the framework settings file without asking for verification
    """
    print('********** WARNING - You are deleting your framework settings file! **********')
    print('The file being deleted is:', freesimplegui_user_settings.full_filename)


def main_global_freesimplegui_settings():
    """Window to set settings that will be used across all framework
        programs that choose to use them

    Use `set_options` to set the path to the folder for all framework settings.

    :return: True if settings were changed
    :rtype:  (bool)
    """
    global DEFAULT_WINDOW_SNAPSHOT_KEY_CODE, ttk_part_mapping_dict, DEFAULT_TTK_THEME

    key_choices = tuple(sorted(tkinter_keysyms))

    settings = freesimplegui_user_settings.read()

    editor_format_dict = {
        'pycharm': '<editor> --line <line> <file>',
        'notepad++': '<editor> -n<line> <file>',
        'sublime': '<editor> <file>:<line>',
        'vim': '<editor> +<line> <file>',
        'wing': '<editor> <file>:<line>',
        'visual studio': '<editor> <file> /command "edit.goto <line>"',
        'atom': '<editor> <file>:<line>',
        'spyder': '<editor> <file>',
        'thonny': '<editor> <file>',
        'pydev': '<editor> <file>:<line>',
        'idle': '<editor> <file>'}

    tooltip = 'Format strings for some popular editors/IDEs:\n' + \
              'PyCharm - <editor> --line <line> <file>\n' + \
              'Notepad++ - <editor> -n<line> <file>\n' + \
              'Sublime - <editor> <file>:<line>\n' + \
              'vim -  <editor> +<line> <file>\n' + \
              'wing - <editor> <file>:<line>\n' + \
              'Visual Studio - <editor> <file> /command "edit.goto <line>"\n' + \
              'Atom - <editor> <file>:<line>\n' + \
              'Spyder - <editor> <file>\n' + \
              'Thonny - <editor> <file>\n' + \
              'PyDev - <editor> <file>:<line>\n' + \
              'IDLE - <editor> <file>\n'

    tooltip_file_explorer = 'This is the program you normally use to "Browse" for files\n' + \
                            'For Windows this is normally "explorer". On Linux "nemo" is sometimes used.'

    tooltip_theme = 'The normal default theme for the framework is "Dark Blue 13\n' + \
                    'If you do not call theme("theme name") by your program to change the theme, then the default is used.\n' + \
                    'This setting allows you to set the theme that will be used for ALL of your programs that\n' + \
                    'do not set a theme specifically.'

    # ------------------------- TTK Tab -------------------------
    ttk_scrollbar_tab_layout = [
        [T('Default TTK Theme', font='_ 16'), Combo([], DEFAULT_TTK_THEME, readonly=True, size=(20, 10), key='-TTK THEME-', font='_ 16')],
        [HorizontalSeparator()],
        [T('TTK Scrollbar Settings', font='_ 16')]
    ]
    t_len = max([len(l) for l in TTK_SCROLLBAR_PART_LIST])
    ttk_layout = [[]]
    for key, item in ttk_part_mapping_dict.items():
        if key in TTK_SCROLLBAR_PART_THEME_BASED_LIST:
            ttk_layout += [[T(key, s=t_len, justification='r'), Combo(PSG_THEME_PART_LIST, default_value=settings.get(('-ttk scroll-', key), item), key=('-TTK SCROLL-', key))]]
        elif key in (TTK_SCROLLBAR_PART_ARROW_WIDTH, TTK_SCROLLBAR_PART_SCROLL_WIDTH):
            ttk_layout += [[T(key, s=t_len, justification='r'), Combo(list(range(100)), default_value=settings.get(('-ttk scroll-', key), item), key=('-TTK SCROLL-', key))]]
        elif key == TTK_SCROLLBAR_PART_RELIEF:
            ttk_layout += [[T(key, s=t_len, justification='r'), Combo(RELIEF_LIST, default_value=settings.get(('-ttk scroll-', key), item), readonly=True, key=('-TTK SCROLL-', key))]]

    ttk_scrollbar_tab_layout += ttk_layout
    ttk_scrollbar_tab_layout += [[Button('Reset Scrollbar Settings'), Button('Test Scrollbar Settings')]]
    ttk_tab = Tab('TTK', ttk_scrollbar_tab_layout)

    layout = [[T('Global Framework Settings', text_color=theme_button_color()[0], background_color=theme_button_color()[1],font='_ 18', expand_x=True, justification='c')]]

    # ------------------------- Interpreter Tab -------------------------
    interpreter_tab = Tab('Python Interpreter',
              [[T('Normally leave this blank')],
                [T('Command to run a python program:'), In(settings.get('-python command-', ''), k='-PYTHON COMMAND-', enable_events=True), FileBrowse()]], font='_ 16', expand_x=True)

    # ------------------------- Editor Tab -------------------------
    editor_tab = Tab('Editor Settings',
              [[T('Command to invoke your editor:'), In(settings.get('-editor program-', ''), k='-EDITOR PROGRAM-', enable_events=True), FileBrowse()],
              [T('String to launch your editor to edit at a particular line #.')],
              [T('Use tags <editor> <file> <line> to specify the string')],
              [T('that will be executed to edit python files using your editor')],
              [T('Edit Format String (hover for tooltip)', tooltip=tooltip),
               In(settings.get('-editor format string-', '<editor> <file>'), k='-EDITOR FORMAT-', tooltip=tooltip)]], font='_ 16', expand_x=True)

    # ------------------------- Explorer Tab -------------------------
    explorer_tab = Tab('Explorer Program',
              [[In(settings.get('-explorer program-', ''), k='-EXPLORER PROGRAM-', tooltip=tooltip_file_explorer)]], font='_ 16', expand_x=True,  tooltip=tooltip_file_explorer)

    # ------------------------- Debugging Tab -------------------------
    debugging_tab = Tab('Debugging',
              [
               [Checkbox('Print event & values after every window.read call', settings.get('-print event values-', False), k='-DEBUG PRINT-'),
                Checkbox('Do not print timeout events', settings.get('-do not print timeouts-', True), k='-DO NOT PRINT TIMEOUTS-')],
               [Checkbox('Enable Built-in Debugger', settings.get('-enable debugger-', False), k='-ENABLE DEBUGGER-' )]], font='_ 16', expand_x=True)

    # ------------------------- Snapshots Tab -------------------------
    snapshots_tab = Tab('Window Snapshots',
              [[Combo(('',)+key_choices, default_value=settings.get(json.dumps(('-snapshot keysym-', i)), ''), readonly=True, k=('-SNAPSHOT KEYSYM-', i), s=(None, 30)) for i in range(4)],
              [T('Manually Entered Bind String:'), Input(settings.get('-snapshot keysym manual-', ''),k='-SNAPSHOT KEYSYM MANUAL-')],
              [T('Folder to store screenshots:'), Push(), In(settings.get('-screenshots folder-', ''), k='-SCREENSHOTS FOLDER-'), FolderBrowse()],
              [T('Screenshots Filename or Prefix:'), Push(), In(settings.get('-screenshots filename-', ''), k='-SCREENSHOTS FILENAME-'), FileBrowse()],
              [Checkbox('Auto-number Images', k='-SCREENSHOTS AUTONUMBER-')]], font='_ 16', expand_x=True,)

    # ------------------------- Theme Tab -------------------------
    theme_tab = Tab('Theme',
              [[T('Leave blank for the framework default theme: {}'.format(OFFICIAL_FREESIMPLEGUI_THEME))],
              [T('Default Theme For All Programs:'),
               Combo([''] + theme_list(), settings.get('-theme-', None), readonly=True, k='-THEME-', tooltip=tooltip_theme), Checkbox('Always use custom Titlebar', default=freesimplegui_user_settings.get('-custom titlebar-',False), k='-CUSTOM TITLEBAR-')],
               [Frame('Window Watermarking',
                       [[Checkbox('Enable Window Watermarking', freesimplegui_user_settings.get('-watermark-', False), k='-WATERMARK-')],
                        [Checkbox('Disable FreeSimpleGUI 5 Watermarking', freesimplegui_user_settings.get('-watermark5-', True), k='-WATERMARK5-')],
                       [T('Prefix Text String:'), Input(freesimplegui_user_settings.get('-watermark text-', ''), k='-WATERMARK TEXT-')],
                       [Checkbox('FreeSimpleGUI Version', freesimplegui_user_settings.get('-watermark ver-', False), k='-WATERMARK VER-')],
                       [Checkbox('Framework Version',freesimplegui_user_settings.get('-watermark framework ver-', False), k='-WATERMARK FRAMEWORK VER-')],
                       [T('Font:'), Input(freesimplegui_user_settings.get('-watermark font-', '_ 9 bold'), k='-WATERMARK FONT-')],
                       # [T('Background Color:'), Input(freesimplegui_user_settings.get('-watermark bg color-', 'window.BackgroundColor'), k='-WATERMARK BG COLOR-')],
                        ],
                font='_ 16', expand_x=True)]])

    settings_tab_group = TabGroup([[theme_tab, ttk_tab, interpreter_tab, explorer_tab, editor_tab, debugging_tab, snapshots_tab,  ]])
    layout += [[settings_tab_group]]
    layout += [[B('Ok', bind_return_key=True), B('Cancel'), B('Mac Patch Control')]]

    window = Window('Settings', layout, keep_on_top=True, modal=False, finalize=True)

    # Fill in the theme list into the Combo element
    # Must do this AFTER the window is created or a tkinter temp window is auto created by it
    ttk_theme_list = ttk.Style().theme_names()

    window['-TTK THEME-'].update(value=DEFAULT_TTK_THEME, values=ttk_theme_list)

    while True:
        event, values = window.read()
        if event in ('Cancel', WIN_CLOSED):
            break
        if event == 'Ok':
            new_theme = OFFICIAL_FREESIMPLEGUI_THEME if values['-THEME-'] == '' else values['-THEME-']
            freesimplegui_user_settings.set('-editor program-', values['-EDITOR PROGRAM-'])
            freesimplegui_user_settings.set('-explorer program-', values['-EXPLORER PROGRAM-'])
            freesimplegui_user_settings.set('-editor format string-', values['-EDITOR FORMAT-'])
            freesimplegui_user_settings.set('-python command-', values['-PYTHON COMMAND-'])
            freesimplegui_user_settings.set('-custom titlebar-', values['-CUSTOM TITLEBAR-'])
            freesimplegui_user_settings.set('-theme-', new_theme)
            freesimplegui_user_settings.set('-print event values-', values['-DEBUG PRINT-'])
            freesimplegui_user_settings.set('-do not print timeouts-', values['-DO NOT PRINT TIMEOUTS-'])
            freesimplegui_user_settings.set('-enable debugger-', values['-ENABLE DEBUGGER-'])

            # TTK SETTINGS
            freesimplegui_user_settings.set('-ttk theme-', values['-TTK THEME-'])
            DEFAULT_TTK_THEME = values['-TTK THEME-']

            # Snapshots portion
            screenshot_keysym_manual = values['-SNAPSHOT KEYSYM MANUAL-']
            freesimplegui_user_settings.set('-snapshot keysym manual-', values['-SNAPSHOT KEYSYM MANUAL-'])
            screenshot_keysym = ''
            for i in range(4):
                freesimplegui_user_settings.set(json.dumps(('-snapshot keysym-',i)), values[('-SNAPSHOT KEYSYM-', i)])
                if values[('-SNAPSHOT KEYSYM-', i)]:
                    screenshot_keysym += "<{}>".format(values[('-SNAPSHOT KEYSYM-', i)])
            if screenshot_keysym_manual:
                DEFAULT_WINDOW_SNAPSHOT_KEY_CODE = screenshot_keysym_manual
            elif screenshot_keysym:
                DEFAULT_WINDOW_SNAPSHOT_KEY_CODE = screenshot_keysym

            freesimplegui_user_settings.set('-screenshots folder-', values['-SCREENSHOTS FOLDER-'])
            freesimplegui_user_settings.set('-screenshots filename-', values['-SCREENSHOTS FILENAME-'])

            # TTK Scrollbar portion
            for key, value in values.items():
                if isinstance(key, tuple):
                    if key[0] == '-TTK SCROLL-':
                        freesimplegui_user_settings.set(json.dumps(('-ttk scroll-', key[1])), value)

            theme(new_theme)

            _global_settings_get_ttk_scrollbar_info()

            window.close()
            return True
        elif event == '-EDITOR PROGRAM-':
            for key in editor_format_dict.keys():
                if key in values['-EDITOR PROGRAM-'].lower():
                    window['-EDITOR FORMAT-'].update(value=editor_format_dict[key])
        elif event == 'Mac Patch Control':
            main_mac_feature_control()
            # re-read the settings in case they changed
            _read_mac_global_settings()
        elif event == 'Reset Scrollbar Settings':
            ttk_part_mapping_dict = copy.copy(DEFAULT_TTK_PART_MAPPING_DICT)
            for key, item in ttk_part_mapping_dict.items():
                window[('-TTK SCROLL-', key)].update(item)
        elif event == 'Test Scrollbar Settings':
            for ttk_part in TTK_SCROLLBAR_PART_LIST:
                value = values[('-TTK SCROLL-', ttk_part)]
                ttk_part_mapping_dict[ttk_part] = value
            DEFAULT_TTK_THEME = values['-TTK THEME-']
            for i in range(100):
                Print(i, keep_on_top=True)
            Print('Close this window to continue...', keep_on_top=True)

    window.close()
    # In case some of the settings were modified and tried out, reset the ttk info to be what's in the config file
    style = ttk.Style(Window.hidden_master_root)
    _change_ttk_theme(style, DEFAULT_TTK_THEME)
    _global_settings_get_ttk_scrollbar_info()

    return False


# ..######..########..##....##....##.....##.########.##.......########.
# .##....##.##.....##.##...##.....##.....##.##.......##.......##.....##
# .##.......##.....##.##..##......##.....##.##.......##.......##.....##
# ..######..##.....##.#####.......#########.######...##.......########.
# .......##.##.....##.##..##......##.....##.##.......##.......##.......
# .##....##.##.....##.##...##.....##.....##.##.......##.......##.......
# ..######..########..##....##....##.....##.########.########.##.......

def main_sdk_help():
    """Display a window that will display the docstrings for each framework
        Element and the Window object if exists
    """
    online_help_links = {}

    NOT_AN_ELEMENT = 'Not An Element'
    element_classes = Element.__subclasses__()
    element_names = {element.__name__: element for element in element_classes}
    element_names['Window'] = Window
    element_classes.append(Window)
    element_arg_default_dict, element_arg_default_dict_update = {}, {}
    vars3 = [m for m in inspect.getmembers(sys.modules[__name__])]

    functions = [m for m in inspect.getmembers(sys.modules[__name__], inspect.isfunction)]
    functions_names_lower = [f for f in functions if f[0][0].islower()]
    functions_names_upper = [f for f in functions if f[0][0].isupper()]
    functions_names = sorted(functions_names_lower) + sorted(functions_names_upper)

    for element in element_classes:
        # Build info about init method
        args = inspect.getfullargspec(element.__init__).args[1:]
        defaults = inspect.getfullargspec(element.__init__).defaults

        if len(args) != len(defaults):
            diff = len(args) - len(defaults)
            defaults = ('NO DEFAULT',) * diff + defaults

        args_defaults = []
        for i, a in enumerate(args):
            args_defaults.append((a, defaults[i]))
        element_arg_default_dict[element.__name__] = args_defaults

        # Build info about update method
        try:
            args = inspect.getfullargspec(element.update).args[1:]
            defaults = inspect.getfullargspec(element.update).defaults
            if args is None or defaults is None:
                element_arg_default_dict_update[element.__name__] = (('', ''),)
                continue
            if len(args) != len(defaults):
                diff = len(args) - len(defaults)
                defaults = ('NO DEFAULT',) * diff + defaults
            args_defaults = []
            for i, a in enumerate(args):
                args_defaults.append((a, defaults[i]))
            element_arg_default_dict_update[element.__name__] = args_defaults if len(args_defaults) else (('', ''),)
        except Exception as e:
            pass

    # Add on the pseudo-elements
    element_names['MenubarCustom'] = MenubarCustom
    element_names['Titlebar'] = Titlebar

    buttons = [[B(e, pad=(0, 0), size=(22, 1), font='Courier 10')] for e in sorted(element_names.keys())]
    buttons += [[B('Func Search', pad=(0, 0), size=(22, 1), font='Courier 10')]]
    button_col = Col(buttons, vertical_alignment='t')
    mline_col = Column([[Multiline(size=(100, 46), key='-ML-', write_only=True, reroute_stdout=True, font='Courier 10', expand_x=True, expand_y=True)],
                        [T(size=(80, 1), font='Courier 10 underline', k='-DOC LINK-', enable_events=True)]], pad=(0, 0), expand_x=True, expand_y=True, vertical_alignment='t')
    layout = [[button_col, mline_col]]
    layout += [[CBox('Summary Only', enable_events=True, k='-SUMMARY-'), CBox('Display Only PEP8 Functions', default=True, k='-PEP8-')]]
    # layout = [[Column(layout, scrollable=True, p=0, expand_x=True, expand_y=True, vertical_alignment='t'), Sizegrip()]]
    layout += [[Button('Exit', size=(15, 1)), Sizegrip()]]

    window = Window('SDK API Call Reference', layout, resizable=True, use_default_focus=False, keep_on_top=True, icon=EMOJI_BASE64_THINK, finalize=True,
                    right_click_menu=MENU_RIGHT_CLICK_EDITME_EXIT)
    window['-DOC LINK-'].set_cursor('hand1')
    online_help_link = ''
    ml = window['-ML-']
    current_element = ''
    try:
        while True:  # Event Loop
            event, values = window.read()
            if event in (WIN_CLOSED, 'Exit'):
                break
            if event == '-DOC LINK-':
                if webbrowser_available and online_help_link:
                    webbrowser.open_new_tab(online_help_link)
            if event == '-SUMMARY-':
                event = current_element

            if event in element_names.keys():
                current_element = event
                window['-ML-'].update('')
                online_help_link = ''# online_help_links.get(event, '')
                window['-DOC LINK-'].update(online_help_link)
                if not values['-SUMMARY-']:
                    elem = element_names[event]
                    ml.print(pydoc.help(elem))
                    # print the aliases for the class
                    ml.print('\n--- Shortcut Aliases for Class ---')
                    for v in vars3:
                        if elem == v[1] and elem.__name__ != v[0]:
                            print(v[0])
                    ml.print('\n--- Init Parms ---')
                else:
                    elem = element_names[event]
                    if inspect.isfunction(elem):
                        ml.print('Not a class...It is a function', background_color='red', text_color='white')
                    else:
                        element_methods = [m[0] for m in inspect.getmembers(Element, inspect.isfunction) if not m[0].startswith('_') and not m[0][0].isupper()]
                        methods = inspect.getmembers(elem, inspect.isfunction)
                        methods = [m[0] for m in methods if not m[0].startswith('_') and not m[0][0].isupper()]

                        unique_methods = [m for m in methods if m not in element_methods and not m[0][0].isupper()]

                        properties = inspect.getmembers(elem, lambda o: isinstance(o, property))
                        properties = [p[0] for p in properties if not p[0].startswith('_')]
                        ml.print('--- Methods ---', background_color='red', text_color='white')
                        ml.print('\n'.join(methods))
                        ml.print('--- Properties ---', background_color='red', text_color='white')
                        ml.print('\n'.join(properties))
                        if elem != NOT_AN_ELEMENT:
                            if issubclass(elem, Element):
                                ml.print('Methods Unique to This Element', background_color='red', text_color='white')
                                ml.print('\n'.join(unique_methods))
                        ml.print('========== Init Parms ==========', background_color='#FFFF00', text_color='black')
                        elem_text_name = event
                        for parm, default in element_arg_default_dict[elem_text_name]:
                            ml.print('{:18}'.format(parm), end=' = ')
                            ml.print(default, end=',\n')
                        if elem_text_name in element_arg_default_dict_update:
                            ml.print('========== Update Parms ==========', background_color='#FFFF00', text_color='black')
                            for parm, default in element_arg_default_dict_update[elem_text_name]:
                                ml.print('{:18}'.format(parm), end=' = ')
                                ml.print(default, end=',\n')
                ml.set_vscroll_position(0)  # scroll to top of multoline
            elif event == 'Func Search':
                search_string = popup_get_text('Search for this in function list:', keep_on_top=True)
                if search_string is not None:
                    online_help_link = ''
                    window['-DOC LINK-'].update('')
                    ml.update('')
                    for f_entry in functions_names:
                        f = f_entry[0]
                        if search_string in f.lower() and not f.startswith('_'):
                            if (values['-PEP8-'] and not f[0].isupper()) or not values['-PEP8-']:
                                if values['-SUMMARY-']:
                                    ml.print(f)
                                else:
                                    ml.print('=========== ' + f + '===========', background_color='#FFFF00', text_color='black')
                                    ml.print(pydoc.help(f_entry[1]))
                ml.set_vscroll_position(0)  # scroll to top of multoline
    except Exception as e:
        _error_popup_with_traceback('Exception in SDK reference', e)
    window.close()


#                     oo
#
# 88d8b.d8b. .d8888b. dP 88d888b.
# 88'`88'`88 88'  `88 88 88'  `88
# 88  88  88 88.  .88 88 88    88
# dP  dP  dP `88888P8 dP dP    dP
#
#
# M""MMM""MMM""M oo                dP
# M  MMM  MMM  M                   88
# M  MMP  MMP  M dP 88d888b. .d888b88 .d8888b. dP  dP  dP
# M  MM'  MM' .M 88 88'  `88 88'  `88 88'  `88 88  88  88
# M  `' . '' .MM 88 88    88 88.  .88 88.  .88 88.88b.88'
# M    .d  .dMMM dP dP    dP `88888P8 `88888P' 8888P Y8P
# MMMMMMMMMMMMMM
#
# MP""""""`MM   dP                       dP               dP
# M  mmmmm..M   88                       88               88
# M.      `YM d8888P .d8888b. 88d888b. d8888P .d8888b.    88d888b. .d8888b. 88d888b. .d8888b.
# MMMMMMM.  M   88   88'  `88 88'  `88   88   Y8ooooo.    88'  `88 88ooood8 88'  `88 88ooood8
# M. .MMM'  M   88   88.  .88 88         88         88    88    88 88.  ... 88       88.  ...
# Mb.     .dM   dP   `88888P8 dP         dP   `88888P'    dP    dP `88888P' dP       `88888P'
# MMMMMMMMMMM

def _main_switch_theme():
    layout = [
        [Text('Click a look and feel color to see demo window')],
        [Listbox(values=theme_list(),
                 size=(20, 20), key='-LIST-')],
        [Button('Choose'), Button('Cancel')]]

    window = Window('Change Themes', layout)

    event, values = window.read(close=True)

    if event == 'Choose':
        theme_name = values['-LIST-'][0]
        theme(theme_name)


def _create_main_window():
    """Creates the home window

    :return: The Home window
    :rtype:  Window
    """
    # global version
    # version = __version()
    ver = version.split(' ')[0]
    #tkversion = tkinter.TkVersion
    #tclversion = tkinter.TclVersion
    #tclversion_detailed = tkinter.Tcl().eval('info patchlevel')

    # ------ Menu Definition ------ #
    menu_def = [['&File', ['!&Open', '&Save::savekey', '---', '&Properties', 'E&xit']],
                ['&Edit', ['&Paste', ['Special', 'Normal', '!Disabled'], 'Undo'], ],
                ['&Debugger', ['Popout', 'Launch Debugger']],
                ['!&Disabled', ['Popout', 'Launch Debugger']],
                ['&Toolbar', ['Command &1', 'Command &2', 'Command &3', 'Command &4']],
                ['&Help', '&About...'], ]

    button_menu_def = ['unused', ['&Paste', ['Special', 'Normal', '!Disabled'], 'Undo', 'Exit'], ]

    right_click_keys_menu = [[], ['!&Click', '&Menu', 'E&xit']]

    treedata = TreeData()

    treedata.Insert("", '_A_', 'Tree Item 1', [1, 2, 3], )
    treedata.Insert("", '_B_', 'B', [4, 5, 6], )
    treedata.Insert("_A_", '_A1_', 'Sub Item 1', ['can', 'be', 'anything'], )
    treedata.Insert("", '_C_', 'C', [], )
    treedata.Insert("_C_", '_C1_', 'C1', ['or'], )
    treedata.Insert("_A_", '_A2_', 'Sub Item 2', [None, None])
    treedata.Insert("_A1_", '_A3_', 'A30', ['getting deep'])
    treedata.Insert("_C_", '_C2_', 'C2', ['nothing', 'at', 'all'])

    for i in range(100):
        treedata.Insert('_C_', i, i, [])

    frame1 = [
        [Input('Input Text', size=(25, 1)), ],
        [Multiline(size=(30, 5), default_text='Multiline Input')],
    ]

    frame2 = [
        [Listbox(['Listbox 1', 'Listbox 2', 'Listbox 3'], select_mode=SELECT_MODE_EXTENDED, size=(20, 5), no_scrollbar=True),
         Spin([1, 2, 3, 'a', 'b', 'c'], initial_value='a', size=(4, 3), wrap=True)],
        [Combo(['Combo item %s' % i for i in range(5)], size=(20, 3), default_value='Combo item 2', key='-COMBO1-', )],
        [Combo(['Combo item %s' % i for i in range(5)], size=(20, 3), font='Courier 14', default_value='Combo item 2', key='-COMBO2-', )],
    ]

    frame3 = [
        [Checkbox('Checkbox1', True, k='-CB1-'), Checkbox('Checkbox2', k='-CB2-')],
        [Radio('Radio Button1', 1, key='-R1-'), Radio('Radio Button2', 1, default=True, key='-R2-', tooltip='Radio 2')]
    ]

    frame4 = [
        [Slider(range=(0, 100), orientation='v', size=(7, 15), default_value=40, key='-SLIDER1-'),
         Slider(range=(0, 100), orientation='h', size=(11, 15), default_value=40, key='-SLIDER2-'), ],
    ]
    matrix = [[str(x * y) for x in range(1, 5)] for y in range(1, 8)]

    frame5 = [vtop([
        Table(values=matrix, headings=matrix[0],
              auto_size_columns=False, display_row_numbers=True, change_submits=False, justification='right', header_border_width=4,
              num_rows=10, alternating_row_color='lightblue', key='-TABLE-',
              col_widths=[5, 5, 5, 5]),
        Tree(data=treedata, headings=['col1', 'col2', 'col3'], col_widths=[5, 5, 5, 5], change_submits=True, auto_size_columns=False, header_border_width=4,
             num_rows=8, col0_width=8, key='-TREE-', show_expanded=True)])]

    pop_test_tab_layout = [
        [Image(EMOJI_BASE64_HAPPY_IDEA), T('Popup tests? Good idea!')],
        [B('Popup', k='P '), B('No Titlebar', k='P NoTitle'), B('Not Modal', k='P NoModal'), B('Non Blocking', k='P NoBlock'), B('Auto Close', k='P AutoClose')],
        [T('"Get" popups too!')],
        [B('Get File'), B('Get Folder'), B('Get Date'), B('Get Text')]]

    GRAPH_SIZE = (500, 200)
    graph_elem = Graph(GRAPH_SIZE, (0, 0), GRAPH_SIZE, key='+GRAPH+')

    frame6 = [[VPush()], [graph_elem]]

    themes_tab_layout = [[T('You can see a preview of the themes, the color swatches, or switch themes for this window')],
                         [T('If you want to change the default theme for FreeSimpleGUI, use the Global Settings')],
                         [B('Themes'), B('Theme Swatches'), B('Switch Themes')],
                         [T('Test of see-through mode for windows:'),  B('See-through Mode', tooltip='Make the background transparent', pad=(1, 0)),]]

    tab_help_layout = [[B('SDK Reference Window')],
                       [B('Online 5.0 Docs')]]


    # ------------------------- Elements Tab -------------------------
    tab_elem_graph = Tab('Graph\n', frame6, tooltip='Graph is in here', title_color='red')
    tab_elem_basic = Tab('CB, Radio\nList, Combo',
                         [[Frame('Multiple Choice Group', frame2, title_color='#FFFFFF', tooltip='Checkboxes, radio buttons, etc', vertical_alignment='t', ),
                 Column([[Frame('Binary Choice Group', frame3, title_color='#FFFFFF', tooltip='Binary Choice', vertical_alignment='t', ), ],
                         [ButtonMenu('ButtonMenu', button_menu_def, pad=(1, 0), key='-BMENU-', tearoff=True, disabled_text_color='yellow'),
                          B('ttk Button', use_ttk_buttons=True, tooltip='This is a TTK Button', pad=(1, 0)),]])]])
    tab_elem_table_tree = Tab('Table,\nTree', [[Column(frame5, element_justification='l', vertical_alignment='t')]], tooltip='tab 3', title_color='red', k='-TAB TABLE-')
    tab_elem_mline_sliders = Tab('Multiline,\nSliders', [[Frame('TextInput', frame1, title_color='blue'), Frame('Variable Choice Group', frame4, title_color='blue')]], tooltip='tab 5', title_color='red', k='-TAB TEXT-')
    # tab6 = Tab('Udemy,\nSponsor', frame7, k='-TAB SPONSOR-')
    tab_elem_popups = Tab('Popups\n', pop_test_tab_layout, k='-TAB POPUP-')
    tab_themes = Tab('Themes\n', themes_tab_layout, k='-TAB THEMES-')
    tab_help = Tab('HELP\nDocs', tab_help_layout, k='-TAB HELP-')

    tab_elem_layout = [[Push(), Text('These sample controls show what\'s possible with FreeSimpleGUI'), Push()],
                        [TabGroup([[tab_elem_graph, tab_elem_basic, tab_elem_table_tree, tab_elem_mline_sliders, tab_elem_popups]], key='-TAB_GROUP-', expand_x=True, expand_y=True)]]

    tab_elem = Tab('Elements\n', tab_elem_layout, key='-TAB ELEMENTS-', expand_x=True, expand_y=True)

    # ------------------------- Settings Tab -------------------------
    tab_settings_layout = [[Text('Open the Global FreeSimpleGUI Settings Window')],
                           [B('Global\nSettings', size=(8,2), k='-GLOBAL SETTINGS-', tooltip='Settings across all FreeSimpleGUI programs'),]]

    tab_settings = Tab('Settings\n', tab_settings_layout, key='-TAB SETTINGS-', expand_x=True, expand_y=True)

    # ------------------------- VERSIONS Tab -------------------------
    """
        _|      _|                                _|
        _|      _|    _|_|    _|  _|_|    _|_|_|        _|_|    _|_|_|      _|_|_|
        _|      _|  _|_|_|_|  _|_|      _|_|      _|  _|    _|  _|    _|  _|_|
          _|  _|    _|        _|            _|_|  _|  _|    _|  _|    _|      _|_|
            _|        _|_|_|  _|        _|_|_|    _|    _|_|    _|    _|  _|_|_|
    """

    def VerLine(version, description, justification='r', size=(40, 1)):
        return [T(version, justification=justification, font='Any 10', text_color='yellow', size=size, pad=(0, 0)), T(description, font='Any 10', pad=(0, 0))]

    if running_mac():
        platform_name = 'Mac'
    elif running_windows():
        platform_name = 'Windows'
    elif running_linux():
        platform_name = 'Linux'
    else:
        platform_name= 'Unknown platorm'

    platform_ver = platform.platform()

    layout_top = Column([
        [Image(EMOJI_BASE64_HAPPY_BIG_SMILE, enable_events=True, key='-LOGO-', tooltip='This is FreeSimpleGUI logo'),
         Image(data=DEFAULT_BASE64_LOADING_GIF, enable_events=True, key='-IMAGE-'),
         Text('FreeSimpleGUI Test Harness', font='ANY 14',
              tooltip='My tooltip', key='-TEXT1-')],
        VerLine(ver, 'FreeSimpleGUI Version') + [Image(HEART_3D_BASE64, subsample=4)],
        # VerLine('{}/{}'.format(tkversion, tclversion), 'TK/TCL Versions'),
        VerLine(tclversion_detailed, 'detailed tkinter version'),
        VerLine(os.path.dirname(os.path.abspath(__file__)), 'FreeSimpleGUI Location', size=(40, None)),
        VerLine(sys.executable, 'Python Executable'),

        VerLine(sys.version, 'Python Version', size=(40,2)) +[Image(PYTHON_COLORED_HEARTS_BASE64, subsample=3, k='-PYTHON HEARTS-', enable_events=True)]], pad=0)

     # ------------------------- Bottom portion of Window (Tabs and Buttons) -------------------------
    layout_bottom = [[Column([
        [B(SYMBOL_DOWN, pad=(0, 0), k='-HIDE TABS-'),
         pin(Col([[TabGroup([[tab_versions, tab_elem, tab_settings, tab_themes, tab_help]], key='-TAB GROUP TOP LEVEL-', expand_x=True, expand_y=True)]], k='-TAB GROUP COL-', expand_x=True, expand_y=True), expand_x=True, expand_y=True)]], pad=0, expand_x=True, expand_y=True)]]

    layout = [[]]

    if not theme_use_custom_titlebar():
        layout += [[Menu(menu_def, key='-MENU-', font='Courier 15', background_color='red', text_color='white', disabled_text_color='yellow', tearoff=True)]]
    else:
        layout += [[MenubarCustom(menu_def, key='-MENU-', font='Courier 15', bar_background_color=theme_background_color(), bar_text_color=theme_text_color(),
                                  background_color='red', text_color='white', disabled_text_color='yellow')]]

    # layout += [[layout_top] + [ProgressBar(max_value=800, size=(20, 25), orientation='v', key='+PROGRESS+')]]
    layout = layout_top + layout_bottom

    # ------------------------- Create the Window -------------------------
    window = Window(
        'FreeSimpleGUI Home', layout, right_click_menu=right_click_keys_menu,
        resizable=True, keep_on_top=False, element_justification='left',  # justify contents to the left
        metadata='My window metadata', finalize=True,
        # grab_anywhere=True,
        enable_close_attempted_event=True, modal=False,
    )

    window.timer_start(50, repeating=True)      # Start a 50ms timer to drive the animated GIF

    window._see_through = False
    return window


# M"""""`'"""`YM          oo
# M  mm.  mm.  M
# M  MMM  MMM  M .d8888b. dP 88d888b.
# M  MMM  MMM  M 88'  `88 88 88'  `88
# M  MMM  MMM  M 88.  .88 88 88    88
# M  MMM  MMM  M `88888P8 dP dP    dP
# MMMMMMMMMMMMMM

def main():
    """The module's entry point"""

    forced_modal = DEFAULT_MODAL_WINDOWS_FORCED
    window = _create_main_window()
    set_options(keep_on_top=True)
    graph_elem = window['+GRAPH+']
    i = 0
    graph_figures = []

    while True:  # Event Loop
        event, values = window.read(timeout=None)
        if event != TIMEOUT_KEY and event != TIMER_KEY:
            print(event, values)
        if event == WIN_CLOSED or event == WIN_CLOSE_ATTEMPTED_EVENT or event == 'Exit' or (event == '-BMENU-' and values['-BMENU-'] == 'Exit'):
            break

        # --------------------------------- Animations update ---------------------------------
        window['-IMAGE-'].update_animation_no_buffering(DEFAULT_BASE64_LOADING_GIF, time_between_frames=50)

        if event == 'Button':
            window.Element('-TEXT1-').SetTooltip('NEW TEXT')
            window.Element('-MENU-').Update(visible=True)
        elif event == 'Popout':
            show_debugger_popout_window()
        elif event == 'Launch Debugger':
            show_debugger_window()
        elif event == 'About...':
            popup('About this program...', 'You are looking at the Home Window for the FreeSimpleGUI module', version, keep_on_top=True, image=DEFAULT_BASE64_ICON)
        elif event.startswith('See'):
            window._see_through = not window._see_through
            window.set_transparent_color(theme_background_color() if window._see_through else '')
        elif event == '-INSTALL-':
            _upgrade_gui()
        elif event == 'Popup':
            popup('This is your basic popup', keep_on_top=True)
        elif event == 'Get File':
            popup_scrolled('Returned:', popup_get_file('Get File', keep_on_top=True))
        elif event == 'Get Folder':
            popup_scrolled('Returned:', popup_get_folder('Get Folder', keep_on_top=True))
        elif event == 'Get Date':
            popup_scrolled('Returned:', popup_get_date(keep_on_top=True))
        elif event == 'Get Text':
            popup_scrolled('Returned:', popup_get_text('Enter some text', keep_on_top=True))
        elif event == 'Themes':
            search_string = popup_get_text('Enter a search term or leave blank for all themes', 'Show Available Themes', keep_on_top=True)
            if search_string is not None:
                theme_previewer(search_string=search_string)
        elif event == 'Theme Swatches':
            theme_previewer_swatches()
        elif event == 'Switch Themes':
            window.close()
            _main_switch_theme()
            window = _create_main_window()
            graph_elem = window['+GRAPH+']
        elif event == '-HIDE TABS-':
            window['-TAB GROUP COL-'].update(visible=window['-TAB GROUP COL-'].metadata == True)
            window['-TAB GROUP COL-'].metadata = not window['-TAB GROUP COL-'].metadata
            window['-HIDE TABS-'].update(text=SYMBOL_UP if window['-TAB GROUP COL-'].metadata else SYMBOL_DOWN)
        elif event == 'SDK Reference Window':
            main_sdk_help()
        elif event == '-GLOBAL SETTINGS-':
            if main_global_freesimplegui_settings():
                theme(freesimplegui_user_settings.get('-theme-', OFFICIAL_FREESIMPLEGUI_THEME))
                window.close()
                window = _create_main_window()
                graph_elem = window['+GRAPH+']
            else:
                Window('', layout=[[Multiline()]], alpha_channel=0).read(timeout=1, close=True)
        elif event.startswith('P '):
            if event == 'P ':
                popup('Normal Popup - Modal', keep_on_top=True)
            elif event == 'P NoTitle':
                popup_no_titlebar('No titlebar', keep_on_top=True)
            elif event == 'P NoModal':
                set_options(force_modal_windows=False)
                popup('Normal Popup - Not Modal', 'You can interact with main window menubar ',
                      'but will have no effect immediately', 'button clicks will happen after you close this popup', modal=False, keep_on_top=True)
                set_options(force_modal_windows=forced_modal)
            elif event == 'P NoBlock':
                popup_non_blocking('Non-blocking', 'The background window should still be running', keep_on_top=True)
            elif event == 'P AutoClose':
                popup_auto_close('Will autoclose in 3 seconds', auto_close_duration=3, keep_on_top=True)
        elif event == '-VERSIONS-':
            main_get_debug_data()

        i += 1

    print('event = ', event)
    window.close()
    set_options(force_modal_windows=forced_modal)

# Make home be an alias for main
home = main

# ------------------------ PEP8-ify The SDK ------------------------#
ChangeLookAndFeel = change_look_and_feel
ConvertArgsToSingleString = convert_args_to_single_string
EasyPrint = easy_print
Print = easy_print
eprint = easy_print
sgprint = easy_print
PrintClose = easy_print_close
sgprint_close = easy_print_close
EasyPrintClose = easy_print_close
FillFormWithValues = fill_form_with_values
GetComplimentaryHex = get_complimentary_hex
ListOfLookAndFeelValues = list_of_look_and_feel_values
ObjToString = obj_to_string
ObjToStringSingleObj = obj_to_string_single_obj
OneLineProgressMeter = one_line_progress_meter
OneLineProgressMeterCancel = one_line_progress_meter_cancel
Popup = popup
PopupNoFrame = popup_no_titlebar
popup_no_frame = popup_no_titlebar
PopupNoBorder = popup_no_titlebar
popup_no_border = popup_no_titlebar
PopupAnnoying = popup_no_titlebar
popup_annoying = popup_no_titlebar
PopupAnimated = popup_animated
PopupAutoClose = popup_auto_close
PopupCancel = popup_cancel
PopupError = popup_error
PopupGetFile = popup_get_file
PopupGetFolder = popup_get_folder
PopupGetText = popup_get_text
PopupNoButtons = popup_no_buttons
PopupNoTitlebar = popup_no_titlebar
PopupNoWait = popup_non_blocking
popup_no_wait = popup_non_blocking
PopupNonBlocking = popup_non_blocking
PopupOK = popup_ok
PopupOKCancel = popup_ok_cancel
PopupQuick = popup_quick
PopupQuickMessage = popup_quick_message
PopupScrolled = popup_scrolled
PopupTimed = popup_auto_close
popup_timed = popup_auto_close
PopupYesNo = popup_yes_no

RGB = rgb
SetGlobalIcon = set_global_icon
SetOptions = set_options
sprint = popup_scrolled
ScrolledTextBox = popup_scrolled
TimerStart = timer_start
TimerStop = timer_stop
test = main
sdk_help = main_sdk_help

freesimplegui_user_settings = UserSettings(filename=DEFAULT_USER_SETTINGS_FREESIMPLEGUI_FILENAME, path=DEFAULT_USER_SETTINGS_FREESIMPLEGUI_PATH)

# ------------------------ Set the "Main FreeSimpleGUI Theme Colors" ------------------------

theme(theme_global())

# ------------------------ Read the ttk scrollbar info ------------------------

_global_settings_get_ttk_scrollbar_info()

# See if running on Trinket. If Trinket, then use custom titlebars since Trinket doesn't supply any
if running_trinket():
    USE_CUSTOM_TITLEBAR = True

if tclversion_detailed.startswith('8.5'):
    warnings.warn(
        'You are running a VERY old version of tkinter {}.'+
        'You cannot use PNG formatted images for example.'+
        'Please upgrade to 8.6.x'.format(tclversion_detailed), UserWarning
    )

# Enables the correct application icon to be shown on the Windows taskbar
if running_windows():
    try:
        myappid = 'mycompany.myproduct.subproduct.version'
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)
    except Exception as e:
        print('Error using the taskbar icon patch (App ID)', e)

_read_mac_global_settings()

if _mac_should_set_alpha_to_99():
    # Mac OS 12.3+ Alpha Channel fix; sets the default Alpha Channel to 0.99
    set_options(alpha_channel=0.99)

# -------------------------------- ENTRY POINT IF RUN STANDALONE -------------------------------- #
if __name__ == '__main__':
    if len(sys.argv) > 1 and sys.argv[1] == 'help':
        main_sdk_help()
        exit(0)
    main()
    exit(0)

